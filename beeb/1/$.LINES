$START\ LINES\ ****************************************\\ **** MOVE / COPY / RENUMBER ****.'Move\ MOVE LINES, deleting source linesLDA#&FFBNE CO1.'COPY\ COPY LINES, not deletingLDA#0.CO1 STA MoveflagLDX#0STX Renum \Set flag falseJSR GetnumbersBCC @E+5 \IF C=1 Newstart lies between Start & finishJSR Synerr \JSR as synerr drops stackJSR Checkcrash \Checkcrash checks if newlines will overwrite existing linesBIT MoveflagBPL CO12 \CopyingJSR Rereference \If Moveing change any callsJSR News2_news.CO12 JSR Findstart \rtns Addr of first line in (Addr).MovelineJSR Newstoiac \Put rqd line# in 2A/2BJSR Lineiachi \Save line# of source lineLDY#3.ML1 INYLDA(Addr),YSTA&6FC,Y \Move line text into buffer 700CMP#13 \CR?BNE ML1LDY#0JSR INSERT \Insert line, # in IAC, text at 700,YJSR Iachi_loJSR Findline \Find new addr of source lineBIT MoveflagBPL CopyingLDA#13STA&700 \Line =CR onlyLDY#0JSR INSERT \Delete source lineJMP CO2 \If deleting (Addr) already = nextline.Copying JSR Nextline \Update (Addr).CO2 JSR UpNewsBCC Moveline \Not finished yetBIT MoveflagBPL @E+5 \CopyingJMP Choice \Moving all done\If Copying renumber any valid calls.'Copyrenumber\Check new lines for any reference to new lines and update.SECLDA NewstartSBC StepTAXLDY Newstart+1BCS @E+3DEYJSR News2_newsSTX News2STY News2+1 \Set News2 to last new# usedJSR NewstoiacJSR Findline \Find (Addr) of New lines startLDA AddrSTA TempLDA Addr+1STA Temp+1 \Save AddrJSR Findstart \Find (Addr) of Old lines start.CR1 JSR Lineiachi \Put old line# in 2C/DLDA TempSTA&BLDA Temp+1STA&C \Set (B) to start of new linesLDY#4.CR2 JSR Findcall2 \Search for any reference to line 2C/DBNE CR5 \No call found\Call found, check if its in a line past the last newlineLDY#1LDA(&B),YCMP News2+1 \Check Hi bytesBCC CR3 \Calling line is a new lineBNE CR5 \Calling line is not newINYLDA News2CMP(&B),YBCC CR5 \Calling line is not new.CR3 \Call of new line by a new line foundJSR NewstoiacJSR Insertline_no \Insert new#BNE CR2 \Continue looking for calls.CR5 \No (more) calls of line 2C/D foundJSR Nextline \Update (Addr)JSR UpNews \Add step to Newstart and check finishBCC CR1JMP Choice \Copy all done!.'UpNews \Update Newstart#LDA StepCLCADC Newstart \Add step to line#STA NewstartBCC @E+4INC Newstart+1.'CheckfinishLDY#1LDA(Addr),Y \Hibyte of line#BMI gonepast \TOP foundCMP Finish+1BCC notyetBNE gonepastINYLDA(Addr),Y \Lo byte of line#CMP FinishBCC notyetBEQ notyet.gonepast SECRTS \RTN C=1.notyet CLCRTS \RTN C=0\ ****************************************.'Getnumbers\GET Required line numbers\START,(FINISH),NEWSTART,(STEP)JSR Printmsg$EQUB 131$EQUS "Start,(Finish),Newstart,(Step)?"$EQUB 13$EQUB 0JSR Getline \Input line at 700BCS Out \EscapedLDY#0STY&F2LDA#7STA&F3 \Point (F2),Y to lineLDX#Lstart \Addr for resultLDA#&FFSTA Lstart+1STA Newstart+1JSR DECBIN \Rtns next chr in ABCS Numok.Synerr JSR Printmsg$EQUS "Syntax"$EQUB 0.Out PLAPLA \Drop rtn addrJMP Choice.Numok BEQ Synerr \IF CR line tooshortLDX Lstart+1BMI Synerr \If Hi byte still FF no number givenBIT RenumBMI GN1 \Leave Finish if RenumberingSTX Finish+1LDX LstartSTX Finish \Set default finish to start for MOVE/COPY only.GN1 LDX#10STX StepLDX #0STX Step+1 \default step 10JSR SkipcommaLDX #FinishJSR DECBINBCC Synerr \Too bigBEQ Synerr \CR, line too shortLDX Finish+1CPX Lstart+1BCC Synerr \If hibyte of Finish < Start!BNE GL1LDX Finish \If hibytes equal, check lowsCPX LstartBCC Synerr \Finish < Start!.GL1 JSR SkipcommaLDX#NewstartJSR DECBINBCC Synerr \Too bigBEQ GL3 \CR, Step not givenJSR SkipcommaLDX#StepJSR DECBINBNE Synerr \CR must follow stepBCC Synerr \Too bigLDA Step+1BNE Synerr \Step>255LDA StepBEQ Synerr \Step=0.GL3 JSR NewstoiacSTA News2+1STX News2 \Save 2nd copy of Newstart#\Check if line# in 2A/B lies between start and finish nos., if so rtn C=1.GL8 LDA&2BBMI Synerr \Line# not givenCMP Lstart+1BCC GL4 \RTS,C=0 if NS<SBNE GL5 \If NS>S check finishLDA&2A \If hibytes=, check lowsCMP LstartBCS GL5 \NewS>S, check F.GL4 RTS \Rtn C=0 if NS<S.GL5 \If NS>=S, check finishLDA Finish+1CMP&2BBCC GL6 \F<NS, rtn C=0BNE GL6 \F>NS, rtn C=1LDA FinishCMP&2A.GL6 RTS.'Skipcomma CMP#","BEQ commaPLAPLAJMP Synerr.comma JMP Skposcl \Get next non space chr\ ****************************************\.Nonexist JSR Nonexistent\JMP Out \Drop rtn addr\Checkcrash checks if newlines will overwrite existing lines, and if new#s go > 32767.'Checkcrash JSR Findstart\BNE Nonexist \Start line not thereBCC CC6 \TOPJSR NewstoiacJSR StartB \Point (B) to PAGEBEQ @E+5.CC1 JSR UpB \Update (B)LDY#1 \Find first existing line# after NewstartLDA(&B),YBMI CC6 \Top foundCMP&2B \First new numberBCC CC1 \Existing< newBNE foundit \Existing > newINYLDA(&B),Y \Check low bytes if hi bytes equalCMP&2ABCC CC1BNE foundit \existing>newBIT RenumBPL Crash \Existing=Newstart and not renumberingJSR LineB_iac \If renumbering check match is outside S&FJSR GL8BCC CrashBCS CC5.foundit \Found the first existing line# after Newstart#BIT RenumBPL CC3 \Not renumberJSR LineB_iac \Put line# in 2A/BJSR GL8 \See if line lies between start and finish.CC5 JSR Newstoiac \Replace Newstart in 2ABCS CC1 \If it does lie between S&F go on to find the first that isnt..CC6 JSR News2_newsJSR Newstoiac \For renumber put real newstart in news.CC3 JSR Nextline \Update (Addr)JSR CheckfinishBCS CC2 \FinishedLDA Step.CC4 CLCADC&2ASTA&2ATAX \Add Step to Newline#LDA&2BADC#0STA&2BBMI Linetobig \>32767LDY#1CMP(&B),Y \Hi byte of stop line#BCC CC3BNE Crash \gone past stop line#INYTXA \Check lo bytesCMP(&B),YBCC CC3.Crash JSR Printmsg$EQUS "Overlap at "$EQUB 0JSR OUTIAC \Print line# in 2A/BJMP Out \Drop rtn addr and exit.LinetobigJSR Printmsg$EQUS "Lines > 32767"$EQUB 0JMP Out.CC2 \Line#s OKRTS\ ****************************************.'RenumberLDX #&FFSTX RenumSTX FinishSTX Finish+1 \Set Finish to last lineJSR Getnumbers\Doesnt matter if NS lies between S&FLDA LstartSTA NewstartLDA Lstart+1STA Newstart+1JSR CheckcrashJSR CheckcrashJSR Rereference \Update all GOTOsJSR Findstart \Rtn addr of Start in (Addr)JSR News2_news \Restore Newstart.RN2 LDY#1LDA Newstart+1STA(Addr),Y \Insert new# hiINYLDA NewstartSTA(Addr),Y \Insert new# lo.RN3 JSR Nextline \Update (Addr)JSR UpNews \Update Newstart#BCC RN2 \Not finished yetJMP Choice \RENUMBER done.'Rereference\ Change any calls to lines about to be renumbered.JSR StartB \Set (B) to PAGEBEQ RF2.RF1 JSR UpB \Update (B).RF2 LDY #1LDA (&B),YBPL RF3RTS \TOP found, all done.RF3 LDY#3.RF4 INY.RF4a LDA(&B),YCMP#13 \CR?BEQ RF1CMP #&8D \Line#?BNE RF4\8D line marker foundJSR LINBINY \Convert to binary in 2A/B\Check if line# is < StartLDA&2ASECSBC LstartLDA&2BSBC Lstart+1\If line# is < Start, C=0BCS RF5.Nochange LDY &A \Left in A by LINBINYBNE RF4a.RF5 \Check if Line# > FinishSECLDA FinishSBC &2ALDA Finish+1SBC &2B\ If line# > Finish C=0BCC Nochange\Call to Renumbered line found\Calculate new number and insert it at callLDA&2A:STA&2CLDA&2B:STA&2D \Save line#JSR Findstart \Rtn (Addr) of Start lineJSR News2_news.RF6 LDY#1LDA (Addr),YCMP &2DBNE RFnotyetINYLDA(Addr),YCMP &2C \Line# lowBEQ Changeit.RFnotyet JSR Nextline \Update (Addr)JSR UpNews \Add Step to NewstartBCC RF6 \C should be 0BCS Nochange.Changeit \(B),A = addr of call to renumbered line, New# in NewstartJSR Newstoiac \Put new# in 2A/BJSR Insertline_no \Rtns Y offset correctJMP RF4a \Continue looking.'Insertline_no \Insert line# in 2A/B into line text at (B),A in internal format.LDY&ADEY \Offset into lineLDA&2BORA#&40 \Set 6 & 7STA(&B),YDEYLDA&2AAND#&3FORA#&40 \Set 6 & 7STA(&B),YDEYLDA&2AAND#&C0STA&2ALDA&2BAND#&C0LSR ALSR AORA&2ALSR ALSR AEOR#&54 \Set 7&6, invert 2&4STA(&B),YLDY&A \Rtn with original line offsetRTS.'Exit JMP Choice$END