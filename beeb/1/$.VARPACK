$START\ VARPACK.'Vptr=&7F.'SVp=&7A.'OldVartop=&4B6\ * VARPACK and VARXREF *.'VARXREF LDA#0STA Varpack.Xv1 JSR VARPACK.Xv2 JMP Choice.'VARPACK JSR ScanprogramLDA&2 \VartopSTA OldVartopLDA&3STA OldVartop+1 \Save current valueJSR Readstack.'Vclear LDX#&80LDA#0.Vcl1 STA&47F,X \Clear Link tableDEXBNE Vcl1STA Assmflag \Reset to +ve, offRTS.'Readstack JSR OSNEWLLDA#2STA Startchr \CtrlB, WCLDA#"@"STA FirstletterLDX# Fake MOD 256LDA# Fake / 256STA&8C \Set Variables flag -ve,onBNE SS2 \@% is not in chain.Fake $EQUW 0 \No link addr$EQUS "%"$EQUB 0.Newletter INC FirstletterLDA FirstletterCMP#123BCC Nxl4 \<=zBNE Nxl1 \FN yet to do?LDX#&F2 \PROC tokenLDA# &F6/2 \Offset to PROC chain/2BNE Nxl3.Nxl1 CMP#&A5 \FN done?BNE Nxl2 \No.Vend LDX#0STX SSLenINXSTX&500 \Set SSLens to 0LDA#13STA&501STA&556 \Set S$s to CRsRTS \Alldone.Nxl2 LDX#&A4 \FN tokenLDA#&F8/2 \Offset to FN chain/2.Nxl3 STX FirstletterLDY#0STY Startchr \Ctrl@, WC.Nxl4 ASL ATAY \Link offset addrLDX &400,Y \LSB in XLDA &401,Y \MSB of link.Nxl5 BEQ Newletter \No chain link.SetsearchCMP OldVartop+1 \Check not reading anyBCC SS2 \new single chr variablesBNE NewletterCPX OldVartopBCS Newletter.SS2 STA Vptr+1STX VptrBIT&FFBMI Vend \EscapedLDA StartchrSTA&556 \WC starts S$STA&5AB \and R$LDA Firstletter \A-z or tokenLDY#1STA&5AC \R$ first chr.Stuff STA&556,Y \Build S$JSR DECRUNCH \Print INYLDA(Vptr),YBNE Stuff \0 ends name\Y=Length of name+1STY SSLen \Length inc initial WCDEYCPY#1BEQ real \If Y=1 single chr real nameLDA(Vptr),Y \Last chr of nameJSR TypeX2BEQ notreal \rtns Z=1 if not letter or number, ie (%$\This is a real or PROC/FN name.real LDA#2STA &557,Y \Put in final CtrlB WCINC SSLen.notreal STY SSLenW \Length of S$ less end WCsJSR Count2 \Count occurencesJSR Printmsg$EQUS" ["$EQUB 0JSR OUTIAC \Print in 0 fieldLDA#"]"JSR OSWRCHLDA#134JSR OSBYTE \Read Cursor posTXASECSBC#16 \Tab to col 16 if possibleBCC Tb4LDA#&FE \else +2.Tb4 TAX.Tab JSR Space1 \Tab to next columnINXBNE TabBIT VarpackBMI ReplaceJSR Lines2 \Print match line#s for XREF.UpdateVp JSR OSNEWLLDY#0LDA (Vptr),YTAX \LSB of link addrINYLDA (Vptr),Y \MSB in AJMP Nxl5.Replace \Shorten variable names by global replaceLDX#3BIT FirstletterBPL @E+3INX \Min length=2 for PROC/FNCPX SSLenBCS UpdateVp \length short alreadyLDY#2STY NameptrLDA#"@"STA SecondchrLDA#13.NM0 STA &5AE,Y \Y=2 stillDEYBPL NM0 \Put 3 CR in as lenght of R$ varies\ Startchr and Firstletter already in 5AB/C\Try single chr name first if not PROC/FNBIT FirstletterBPL @E+5.NMJ JMP NewnameLDX SSLen \Check S$ not A%( or B$( etcLDA&554,X \2nd last chr of S$CMP#38 \% or $ ?BCS NMK \NoCPX#5 \X=4 for A%(BCC NMJ \Goto 2chr name.NMK LDY#&2STY&39 \Name len, A% etcINY \=3STY &5AA \R$ lenJSR NM2b \Check newname not usedBNE Newsingle \already in useJMP Substitute.Newsingle \Try for unused single chr nameBIT SingleuseBMI @E+5JMP Newname \Singles not requiredLDA#"@"STA&5AC \First chr of R$.Nextsingle \Check catalogue for other variables using their own start chr.INC&5ACLDA&5ACCMP#123 \>z?BCS Newname \Goto 2 chr nameCMP#91 \>Z?BNE SN1LDA#97 \Skip to aSTA&5AC.SN1 ASL ATAYLDA&401,YTAX \MSB of LinkLDA&400,Y.Setlink STA SVp \LSBTXASTA SVp+1 \MSBBEQ Foundsingle \End of chain, current R$ OK to useLDY#1LDA#&FF \dummy.Loop INYTAXLDA(SVp),YBNE Loop \Find 0 terminatorTXA \Last chr of nameLDX&5AA \R$ lengthCMP#"0"BCC Snotreal \<0=$(%\Name is real, is R$ real?LDA&5AA,XCMP#3BCC Nextsingle \YesBCS Linkup.Snotreal CMP#"(" \Array?BEQ SarrayCMP &5AA,XBEQ NextsingleBNE Linkup.Sarray CMP&5AA,X \Is R$ an array?BNE LinkupDEYDEYCPY#2BCC SrealarrayLDA(SVp),Y \2nd last chr of nameCMP#"0"BCS SrealarrayCMP&5A9,XBEQ NextsingleBNE Linkup.Srealarray LDA&5A9,XCMP#"0"BCS Nextsingle.Linkup LDY#1LDA(SVp),YTAX \MSB of Link addrDEYLDA(SVp),YJMP Setlink.Foundsingle \R$ is valid nameJSR SETVAR \37,38,39 are still setJSR Vf9 \Update VartopBCS Newname \No room leftJMP Substitute.Newname LDA FirstletterSTA&5AC \Restore R$ first letterLDX SSLenCPX#5BCS @E+5.Upstage JMP UpdateVp \Already 2 chr nameLDY#3STY&39 \Name len for stack searchINY \=4STY&5AA \R$ lenINC NameptrLDY NameptrLDA&555,Y \Next letter from S$CPY SSLen \At or Past end of S$?BCC NM1 \Not yet.Fiddle \Generate a nameINC SecondchrLDA SecondchrCMP#123 \ >z?BNE F2LDA#"0" \Try 0-9 lastSTA Secondchr.F2 CMP#&3ABEQ Upstage \Cant produce a new nameCMP#91BNE NM1LDA#95STA Secondchr \[\]^ are illegal, so skip to _.NM1 CMP#"$"BEQ Array \IF chr (not last) is $ or % must be an arrayCMP#"%"BNE NM2.Array CPY#5BCC Upstage \If Y<5 then name is NA%( or N$( etc, dont shortenBCS Fiddle \Start fiddling a name.NM2 STA&5AD \Insert new 2nd chrJSR NM2bBNE Newname \Name in useJMP Substitute.NM2b LDX SSLen \Check if R$ is already a variable nameLDA &555,X \Last chr of S$CMP#3BCS NM3 \Not a WCDEC &39 \Real names are only 2 chrs.NM3 LDY&554,X \Get 2nd to last chrLDX&5AA \R$ len 3 or 4CMP#"(" \Array?BNE NM4CPY#"%"BEQ NM5CPY#"$"BNE NM4.NM5 STA &5AB,X \Put the ( in as last chrINC &5AA \Add 1 to R$ lenINC&39 \and name lenTYA \% or $.NM4 STA &5AA,X  \Last chr of R$ or 2nd to last if $ or % arrayLDA#&ABSTA &37 \(&37) points to chr before NameLDA#5STA&38 \MSB\Length already in &39BIT FirstletterBPL NN2 \If -ve its a Token..JMP FINDPROC.NN2 JMP FINDVAR\Transfer new name to stack and print it.Substitute LDY#1LDX#2.NN4 LDA&5AA,XCMP#32BCC NN5 \CR or WC marks endJSR DECRUNCHCPY#1BEQ NN8 \First chr not on stackSTA (Vptr),Y.NN8 INY.NN7 INXBNE NN4.NN5 LDA#0STA Switch \Global replace switch ONSTA(Vptr),Y \End of name movesJSR Sure \Do a Global replaceJMP UpdateVp\Lexical analysis of Prgm to find variables.'ScanprogramJSR Vclear \Clear link table\Set VARTOP to LOMEM+64LDX&1 \Lomem MSBLDA&0 \Lomem LSBADC#64STA&2 \VARTOPBCC @E+3INXSTX&3JSR Start \Set (Addr) to PAGEBEQ Vnl2.Vnxtline JSR Nextline \Update (Addr).Vnl2 LDY#1LDA(Addr),YORA &FF \Test escape and TopBPL @E+3RTS \TOP or EscapedLDY#3.Vnxtchr INY.Vnxtchr2 LDA(Addr),Y \Line byteCMP#13 \CR?BEQ VnxtlineCMP#&22 \Quote?BNE Vnotq.Vq1 INYLDA(Addr),Y \Find..CMP#&22 \.Closing quoteBEQ VnxtchrCMP#13BEQ Vnxtline \ or CRBNE Vq1.Vnotq CMP#&8D \Line#?BNE VnotlinoINYINYINY \Skip next 3 bytesBNE Vnxtchr.Vnotlino BIT AssmflagBPL VnotasmbCMP#"\" \Comment?BNE Vnotcomm.Vc1 INYLDA(Addr),Y \Find..CMP#":" \.colonBEQ VnxtchrCMP#13BEQ Vnxtline \ or CRBNE Vc1.Vnotcomm CMP#"]" \End of assembler?BNE VnotasmbSTA AssmflagBEQ Vnxtchr \+ve = off.Vnotasmb CMP#"[" \Start of Assembler?BNE VRemLDA#&FFSTA Assmflag \-ve = onBNE Vnxtchr.VRem CMP#&F4 \REM?BEQ Vnxtline \Skip rest of lineCMP#&DC \DATA?BEQ VnxtlineCMP#"*" \Possible OS cmnd?BNE VnotosclTYATAX \Save Y.Vo2 DEY \Look for previous chrCPY#4 \Gone back into line len?BCC Vnxtline \If so * is first chr, Skip lineLDA(Addr),YCMP#32 \Space?BEQ Vo2CMP#":"BEQ Vnxtline \Colon* is OS cmndCMP#&8C \THEN?BEQ VnxtlineCMP#&8B \ELSE?BEQ VnxtlineTXATAY \Restore YBNE Vnxtchr \Variable cant start * anyway.Vnotoscl CMP#"&" \HEX?BNE Vnothex.Vn2 INY \Find end of Hex$LDA(Addr),YJSR TypeX2 \Rtns X=0 if not 0-9 or A-zBEQ Vnxtchr2 \Terminator found if X=0CMP#"G"BCC Vn2 \0-9 or A-F, still hexJMP Vnxtchr2 \>F, not hex.Vnothex CMP#&B8 \TO?BNE VnotopINYLDA(Addr),Y \Look at next chrCMP#"P" \TOP?BEQ Vnxt2 \YesDEY \Restore offsetLDA(Addr),Y \and byte.Vnotop CMP#&F2 \PROC?BEQ VfoundCMP#&A4 \FN?BEQ VfoundTAX \Set sign flagBPL Vn3 \Not a token if +ve.Vnxt2 JMP Vnxtchr.Vn3 JSR Type \Alpha?BCC Vnxt2 \Not A-z\START OF VARIABLE FOUND.Vfound DEY \Point back to chr before nameSTA Firstletter \Save first chr of nameTAXLDA(Addr),Y \Get previous chrCPY#4 \CheckBIT AssmflagBPL Vf2\If in assembler check for LabelBCC Vf3 \Not label if Y<4CMP#"." \Label?BEQ Vf2b \Yes.Vf3 INY \Restore YBNE Vnxt2 \Not label, continue.Vf2 \Check for Exponent, 3E6 etcBCC Vf2b \If Y=3 then okCPX#"E"BNE Vf2b \Not E, okJSR TypeX2 \Rtn X=1 for numbersDEXBNE Vf2b \Not a number before the E\This is an exponent, skip all following numbersINY \Offset to E.Ve INY \Next chrLDA(Addr),YJSR TypeX2DEXBNE Ve \Still numericJMP Vnxtchr2.Vf2b TYACLCADC AddrSTA&37 \Point(37) to byte before nameLDA#0STA &39 \Name len counterADC Addr+1STA&38INY \Restore offset to First chr.Vf4 INYINC&39LDA(Addr),Y \Next chr of name?JSR TypeX2 \X=0 if not letter or numberBNE Vf4 \Still valid name\Terminating chr foundBIT Firstletter \FN or PROC?BMI Vf8 \Yes, dont check %$(CMP#"%" \Integer?BEQ Vf5CMP#"$" \String?BNE Vf6.Vf5 INC&39INY \Include % or $ in nameLDA(Addr),Y \Next chr.Vf6 CMP#"(" \Array?BNE Vf7INC&39INY \Include ( in name.Vf7 \Y now points to next chr not in nameSTY Startchr \Save YJSR FINDVAR \Name already found?BNE Allset \YesJSR SETVAR \Set name on stackBEQ Vf88 \Z=1.Vf8 STY StartchrJSR FINDPROCBNE AllsetJSR SETPROC.Vf88 JSR Vf9BCC AllsetJSR Printmsg$EQUS"No Room, do partial?"$EQUB 0JSR YesNoBEQ @E+4 \YesPLAPLA \Drop Rtn address if NoRTS \Rtn from scanprgm early.Allset LDY StartchrJMP Vnxtchr2 \Continue search.Vf9 LDA#0INYSTA(&2),Y \Put zero terminator inTYASECADC&2STA&2 \Update VARTOP by Y+1BCC @E+4INC&3LDA&3CMP RAMTOPBCC Vf9b \VARTOP < Video, okLDA#0 \Stack clashing with screenLDY#1STA(&3A),Y \Block chain at previous point.Vf9b RTS \C=1 if No room$END