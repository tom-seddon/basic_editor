$START\ ********************************\ * MEMORY EDITOR\ * for ELECTRON\ ********************************.P=&80.'Sptr  = P.'Saddr =P+2.'MEStart =P+4.'MEFinish=P+6.'Width =P+8.'Char  =P+9.'Shift =P+10.'Ctrl  =P+11.'Writeflag =P+12.'RTemp =P+13.'Maxtrack =P+14.'MELines =P+15.'Wtop  =P+16.'MEPtr   =P+17.'MEAddr  =P+19.'MEOffset=P+21.'Side  =P+22.'Maxsector=P+23.Rom=P+24\ ******************************.'MEMEDIT TYA  \Save oscli ptr PHA LDA #252  \Set default parameters.. LDX #0 LDY #&FF JSR OSBYTE \Read lang rom no STX Rom LDA #131 JSR OSBYTE \Read OSHWM in XY STX Sptr STY Sptr+1 \Set default address STX Saddr STY Saddr+1 PLA TAY                                JSR Nextoscl BEQ ME2  \CR, no parameters JSR HEXBIN BCC ME3 \bad Hex LDX &AE \LSB STX Sptr STX Saddr LDX &AF \MSB STX Sptr+1   \Set users address STX Saddr+1.ME3 CMP#"@" \ROM #? BNE ME2 INY JSR HEXBIN  BCC ME2 \Bad hex LDA &AE STA Rom \Set user Rom#.ME2 LDX #0 STX MEStart STX MEStart+1 DEX \=FF STX MEFinish STX MEFinish+1 STX Wtop \Silly number, no window LDA #25 STA MELines JSR Modes \No Headings JSR Editor JMP E3.Medit LDA #15 TAX JSR OSBYTE \Flush ip buffers JSR Wait.E3 BIT &FF BMI MEdone \Escaped LDX Ctrl BMI Medit \Ignore ctrls.'MEdone JSR Curnorm LDX #0 LDA #4 JSR OSBYTE \Restore cursor keys LDX #0 LDY #24 JSR Tab JSR OSNEWL JMP Alldone \ ***************************** \ MEMORY EDITOR / DISPLAY \ USES MODES 3 or 6 DEPENDING ON \ ENTRY MODE \ LIMITS SET BY (START)/(FINISH) \ Initial Ptr in Sptr \ Apparent Addr in SADDR \ \ Top line of window in Wtop \ Number of lines in MELines .'Modes  LDA #135 JSR OSBYTE \Get display mode 0..7 LDX #&6 \Mode 6 LDA #8 \Width in columns CPY #4 \Mode BCS Mode \Use mode 6 for modes 4..7 LDX #&3  \Use Mode 3 for mode 0..3 ASL A \=16.Mode STA Width LDA #22 JSR OSWRCH TXA JSR OSWRCH \select mode  LDA #12 JMP OSWRCH \CLS as well\ * * * * * * * * * * * * * * * * * *.'Initial_Screen  JSR Windowon LDA #4 LDX #1 JSR OSBYTE \Set Cursor keys to asci JSR Blockcur \Print out initial screen full JSR Setptrs LDA MELines STA Ctrl \Line count.Line JSR Prntline JSR MECheckfinish BCS done JSR Updateptrs.A2 DEC Ctrl BNE Line.done JMP Setptrs \Reset MEPtr/MEAddr\ * * * * * * * * * * * * * * * * * *.'Editor JSR Copy_Selects JSR Initial_Screen LDX #6 \Tab to byte 1 Hex LDY #0 STY Side \0=Hex, FF=Asci STY MEOffset \(MEPtr),MEOffset 0-15 JSR Tab.'Wait \Wait for Key down JSR OSRDCH BCS Quit   \error, ie escaped.Gotkey STA Char LDA #121 LDX #(0 EOR &80) \Check shift JSR OSBYTE CPX #&FF BNE @E+4 LDX #0 \not down STX Shift \-ve = down LDX #(1 EOR &80) \Check Ctrl JSR OSBYTE CPX #&FF BNE @E+4 LDX #0  \not down STX Ctrl \-ve = down LDA Char CMP #&7F BCC @E+5 JMP Cursors CMP #13 BEQ CR CMP #9 BNE Key \Char=9, TAB LDX Ctrl BMI Key \Ctrl I \Toggle sides - Asci/Hex BIT Side BMI TLft \Move to asci on RHS JSR Goright JMP LL.TLft JSR Goleft.LL LDA Side EOR #&FF STA Side JMP Wait.CR \Char=13 LDX Ctrl BMI Key \Ctrl M.Quit RTS.Key BIT Side BPL Hex_edit.Asci_edit \Chr in A LDY MEOffset JSR Writeram \Alter ram JSR Goleft \Tab to Hex side LDA Char JSR Halfhex \Update Hex JSR Updateasci JMP CRight2 \Update offset etc..Updateasci LDA #&FF STA Writeflag JSR Goright \back to Asci LDA Char JMP Printasci_dot \Update asci.Hex_edit \Chr in A JSR Hex BCC Wait \Bad hex STA Ctrl \Temp store JSR Up_or_Low \Which nybble? PHP LDY MEOffset BCC Hexlow \C=0 if low nybble.Hexhigh LDA Ctrl ASL A ASL A ASL A ASL A STA Ctrl JSR Readram AND #&0F BCC HL2 \C=0 from ASL A.Hexlow JSR Readram AND #&F0.HL2 ORA Ctrl JSR Writeram STA Char \New chr JSR Updateasci JSR Goleft \back to hex, upper nybble LDA Char JSR Hex_asci \Update Hex PLP \C=0 if lower nybble edited BCC CR3 \Move on to next byte LDA #8 JSR OSWRCH \Back onto lower JMP Wait.Shifted CMP#139 BEQ Up8 CMP#135 BEQ Curcopy CMP#138 BNE JW .Down8 LDX #16 STX Shift.D8a JSR C_down DEC Shift BNE D8a BEQ JW.Up8 LDX #16 STX Shift.U8a JSR C_up DEC Shift BNE U8a BEQ JW.Cursors LDX Shift BMI Shifted LDX Ctrl BPL @E+3 RTS  \CTRL CURSORS CMP #136 BNE @E+5 JMP Curleft CMP #137 BEQ Curight CMP #138 BEQ Curdown CMP #139 BNE JW JMP Curup.Curcopy \Copy key, JSR Curposn TXA PHA TYA PHA LDA #26 JSR OSWRCH \No window JSR Copy_scr JSR Windowon PLA TAY PLA TAX JSR Tab.JW JMP Wait.Curight BIT Side BPL HexCR.CR3 LDA #9 BNE CR5.HexCR JSR Up_or_Low \Which nybble? PHP LDA #9 JSR OSWRCH \Forward 1 PLP BCS JW \C=1 if Upper.CR5 JSR OSWRCH \Forward.CRight2 INC MEOffset LDA MEOffset CMP Width BCC JW \Not line end LDA #0 STA MEOffset BIT Side BPL CR4 JSR Goright \Tab to column 0 in asci JMP Curdown \Newline.CR4 JSR Goleft \Tab to column 0 in Hex, then fall into Curdown...Curdown JSR C_down.JW2 JMP Wait.'C_down JSR MECheckfinish \See if a new line would exceed end addr BCS Rts JSR Updateptrs JSR Curposn INY CPY MELines \Bottom line? BEQ Rolldown LDA #10 JMP OSWRCH \and rts.Rolldown STX Ctrl \Temp save JSR Prntline \Newline LDY MELines DEY.Rollcom LDX Ctrl JSR Tab.Rts RTS.Curleft BIT Side BPL HexCL \Hex side LDA #8 BNE CL2.HexCL JSR Up_or_Low PHP LDA #8 JSR OSWRCH \Back 1 PLP \C=1 for Upper nybble BCC JW2 \Was lower, now upper.CL2 JSR OSWRCH \Back 1 DEC MEOffset BPL JW2 \Same line still LDY Width DEY STY MEOffset \Reset to 7/15 BIT Side BPL CL4 JSR Goright \Tab to New column in asci JMP Curup.CL4 JSR Goleft \Tab to New column in hex \Now fall into Cursor up.Curup JSR C_up JMP Wait.C_up JSR Checkstart BCC Rts \cant move JSR Updateptr2 JSR Curposn LDA #11 JSR OSWRCH \Up 1 CPY #0 \Top line? BNE Rts \No, done.Rollup STX Ctrl LDA #13 JSR OSWRCH JSR Prntln2 \New line LDY #0 BEQ Rollcom \Tab back to old X.Windowon \Set Textwindow LDA #28 JSR OSWRCH LDA #0 JSR OSWRCH \Left=0 LDX Wtop DEX TXA CLC ADC MELines JSR OSWRCH \Bottom= Wtop+MELines-1 LDA #39 LDX Width CPX #8 BEQ W2 LDA #79.W2 JSR OSWRCH \Right=39 or 79 LDA Wtop JMP OSWRCH \Top.Prntline JSR OSNEWL.Prntln2 LDY MEAddr+1 BEQ lsb TYA JSR Hex_asci \msb.lsb LDA MEAddr JSR Hex_asci \lsb TYA BNE L4 JSR Space2.L4 JSR Space2 LDY #0 LDX Width \8 or 16.Hexline JSR Readram JSR Halfhex.L2 JSR Space1 INY DEX BNE Hexline LDY #1 LDX Width CPX #8 BEQ L3 LDY #8 \Add 1 space if 40 col, 7 for 80.L3 JSR Space1 DEY BNE L3 \Y=0, X=Width.Ascline JSR Readram JSR Printasci_dot INY DEX BNE Ascline RTS.'Goright JSR Curposn LDA #31 LDX Width CPX #8 BEQ @E+3 ASL A \=62 CLC ADC MEOffset BNE Jump.Goleft JSR Curposn LDA MEOffset ASL A ADC MEOffset \x3 ADC #6 \Addr width.Jump TAX JMP Tab.Up_or_Low \See if cursor is on upper or lower nybble JSR Curposn TXA SEC.UL2 SBC #3 BEQ UL3 \Rtn C=1 for upper, 3/6/9.. BCS UL2.UL3 RTS \C=0 for lower.MECheckfinish \See if newline possible LDA MEPtr CLC ADC Width TAY \lsb LDA MEPtr+1 ADC #0 CMP MEFinish+1 BCC CF2 \Ok, rtn C=0 BNE CF2 \Past, C=1 CPY MEFinish.CF2 RTS \C=0 OK, C=1 too far.Updateptrs STA MEPtr+1 \msb STY MEPtr \lsb LDA MEAddr CLC ADC Width STA MEAddr BCC Ud2 INC MEAddr+1.Ud2 RTS.Checkstart LDA MEPtr SEC SBC Width TAY \lsb LDA MEPtr+1 SBC #0 CMP MEStart+1 BCC CS2 \Too far, C=0 BNE CS2 \Ok, C=1 CPY MEStart.CS2 RTS.Updateptr2 STA MEPtr+1 STY MEPtr LDA MEAddr SEC SBC Width STA MEAddr BCS UD3 DEC MEAddr+1.UD3 RTS.Setptrs LDX #3 \Transfer Saddr and Sptr.Sp2 LDA Sptr,X \to MEAddr and MEPtr STA MEPtr,X DEX BPL Sp2 RTS\ ********************************.'Halfhex CMP #&10 BCC Half JMP Hex_asci.Half PHA JSR Space1 PLA JMP Nybble.'Tab LDA #31 JSR OSWRCH TXA JSR OSWRCH TYA JMP OSWRCH.'Curposn LDA #134 JMP OSBYTE.'Printasci_dot \Print chr in A if possible, else dot. CMP #&7F BCS dot CMP #32 BCS print.dot LDA #".".print JMP OSWRCH.'Curnorm LDA #26 JSR OSWRCH \No window LDY #114 BNE Bc1.'Blockcur LDY #96.Bc1 RTS \ *** NO CURSOR CHANGES ***  LDX #9.Bc2 LDA Block,X BPL @E+3 TYA \Required size JSR OSWRCH DEX BPL Bc2 RTS.Block $EQUW 0 $EQUD 0 $EQUB &FF \Variable $EQUB 10 \Reg 10 $EQUB 0 \CRTC.. $EQUB 23 \Define chr\**********************************.Readram = &100.Writeram= &111.Copy_Selects \Copy read/write routines to ram LDX #0.C2 LDA Copystart,X STA &100,X INX CPX #Copyend-Copystart BCC C2 RTS            .Copystart  \ ELECTRON rom select is at FE05, BBC at FE30\Readram - LDA(MEPtr),Y after selecting swrom, preserves XY  SEI \No interrupts, as F4 is not correct.. LDA #&C STA &FE05  \page out basic by selecting a rom C to F LDA Rom STA &FE05 LDA (MEPtr),Y PHA LDA &F4 STA &FE05 \Reselect Probe rom PLA CLI RTS.Copymid\Writeram - STA(MEPtr),Y, Corrupts X LDX #&C SEI STX &FE05 LDX Rom STX &FE05 STA (MEPtr),Y LDX &F4 STX &FE05 CLI RTS  .Copyend$END