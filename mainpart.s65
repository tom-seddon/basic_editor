;-------------------------------------------------------------------------

KEEP_DELETE_LINE_MEMSET = false

; I strip out the memmove calls one at a time...
KEEP_BF73_MEMMOVE = false
KEEP_A8C0_MEMMOVE = false

;-------------------------------------------------------------------------

ENABLE_DEBUG = false
                
;-------------------------------------------------------------------------

LINE_NUMBER_TOKEN=$8d
REM_TOKEN=$f4

; max length of text of line, +1.
LINE_LENGTH_LIMIT=$fc           

; if true, CTRL+up/down = move cursor to first/last line of screen.
;
; if false, CTRL+up/down = move cursor between program lines
ORIGINAL_CTRL_UP_DOWN=true

; if X bit 7 clear: set options byte to X, return old value
; if X bit 7 set: leave options alone, return old value
OPTIONS_OSBYTE=26

OPTION_SHIFT_ESCAPE=1
OPTION_EDIT_MODE=2
                
;-------------------------------------------------------------------------

; Language entry point modes.
;
LANGUAGE_MODE_NORMAL=1
LANGUAGE_MODE_SHIFT_ESCAPE=2
                
LANGUAGE_MODE_ZSAVE=$80
LANGUAGE_MODE_ZRUN=$81

;-------------------------------------------------------------------------

FOREGROUND_COLOUR_INDEX=127
BACKGROUND_COLOUR_INDEX=0
                
;-------------------------------------------------------------------------
; SLRE---1-
; S=service
; L=language
; R=copro relocation
; E=electron soft key

.if HI||RELOCATABLE
ROM_FLAGS = %11100010
.else
ROM_FLAGS = %11000010
.endif

;-------------------------------------------------------------------------

                
;-------------------------------------------------------------------------
                
                .section service
                .block
                
osbyte_var: .function index
                .cerror index<$a6||index>$ff,"bad OSBYTE"
                .endf $190+index

                .if BUILD_TYPE==4

push_addrs: .macro
                .for i=0,i<len(\1),i+=1
                lda \1[i]
                pha
                .next
                .endm

pop_addrs: .macro
                .for i=len(\1)-1,i>=0,i-=1
                pla
                sta \1[i]
                .next
                .endm

push_and_copy_addrs: .macro
                .for i=0,i<len(\1),i+=1
                lda \1[i]
                pha
                lda \2+i
                sta \1[i]
                .next
                .endm

pop_and_copy_addrs: .macro
                .for i=len(\1)-1,i>=0,i-=1
                lda \1[i]
                sta \2+i
                pla
                sta \1[i]
                .next
                .endm

                ; Y/X points to string on entry. On exit, $70/$71
                ; holds result and $72 holds final status register
                ; value.
                jmp test_atoi   ;+0

                ; random thing I wanted to test.
                jmp language.clear_error_message_buffer ;+3

                ; random thing I wanted to test.
                jmp test_detokenize_one_line_memset ;+6

                ; random thing I wanted to test.
                jmp test_loc_9e1d_memset ;+9

                ; ; A/X/Y as per memset. Changes $70.
                jmp test_memset ;+12

                ; X=replacement byte
                ; Y=# chars to remove
                ; ($72) is pointer
                ; changes $70
                jmp test_B0BB   ;+15

test_B0BB: .proc
addrs:=(basic_ptr_0+0,basic_ptr_0+1,basic_ptr_1+0,basic_ptr_1+1)
                push_and_copy_addrs addrs,$70
                txa
                jsr language.sub_B0BB
                pop_and_copy_addrs addrs,$70
                rts
                .pend

test_loc_9e1d_memset: .proc
addrs:=(ptr0+0,ptr0+1,byte_3A)
                push_addrs addrs
                lda language.sub_9DEA.loc_9e2e
                pha
                lda #$60
                sta language.sub_9DEA.loc_9e2e
                jsr language.sub_9DEA.loc_9e1d
                pla
                sta language.sub_9DEA.loc_9e2e
                pop_addrs addrs
                rts
                
                .pend

test_detokenize_one_line_memset: .proc
addrs:=(ptr0+0,ptr0+1,byte_2C,byte_3A)
                push_addrs addrs
                lda #$ff        ;make it just do the memset
                sta byte_2C
                jsr language.detokenize_one_line
                pop_addrs addrs
                rts
                .pend

test_memset: .proc
addrs:=(ptr0+0,ptr0+1,byte_3A)
                sta $70
                push_addrs addrs
                lda $70
                jsr language.memset
                pop_addrs addrs
                rts
                .pend

test_atoi: .proc
addrs:=(ptr0+0,ptr0+1,input_ptr+0,input_ptr+1)
                push_addrs addrs
                stx ptr0+0
                sty ptr0+1
                jsr language.atoi
                php
                pla
                sta $72
                lda input_ptr+0
                sta $70
                lda input_ptr+1
                sta $71
                pop_addrs addrs
                rts
                .pend     

                .endif

rom_start:
                jmp     language.language_entry
                jmp     svc

                .byte ROM_FLAGS

                .byte  copyright-rom_start ;
                .byte     $FF
aTheBasicEditor_0:
                .text    "The "
                .if HI
                .text "HI"
                .endif
                .text "BASIC Editor"
                .if ENABLE_DEBUG
                .text " (DEBUG)"
                .endif
                .text 0
                .text VER
.if ELECTRON
				.text "E"
.endif
.if RELOCATABLE
                .text "r"
.endif
copyright:
                .byte 0
aC1984Acornsoft:
                ; was "(C) 1984 Acornsoft". Sorry, Acornsoft!
                .text "(C)",0
                .if HI
                .dword LANG_BASE
                .elsif RELOCATABLE
                ; the relocation address wants to be the HI address
                ; in all cases.
                .cerror (HI_ADDRESS&$ffff0000)!=0
                .word HI_ADDRESS
                .word relocation_descriptor

relocation_descriptor:
                .word 0         ; pointer to bitmap end
                .byte 0         ; ROM number
                .byte 0         ; reserved
                .endif
                
; A = code, X = ROM number, Y = parameter.

svc: .proc
                pha

                cmp #4
                beq svc_star

                .if !HI
                cmp #6
                beq svc_brk
                .endif

                cmp #7
                beq svc_osbyte
                
                cmp #9
                beq svc_help

done:
                pla
                ldx $f4
                rts

claimed:
                pla
                lda #0
                ldx $f4
                rts
                
                .pend

;-------------------------------------------------------------------------

svc_star: .proc
                tya
                pha

                .if HI
                ; if there's no Tube, just ignore the request - this
                ; gives the non-HI ROM a chance, if it's there, or a
                ; Bad Command, if it isn't (since the HI language code
                ; can't run in the IO processor).
                ldx osbyte_var($ea)
                inx
                bne ply_and_svc_done
                .endif
                
check_be:
                ; *...
                lda ($f2),y
                and #$df
                cmp #"B"
                bne ply_and_svc_done

                ; *B....
                iny
                iny
                lda ($f2),y
                cmp #13
                bne ply_and_svc_done

check_command:
                ; *B?|M
                dey
                lda ($f2),y
                and #$df
                
                ldx #LANGUAGE_MODE_NORMAL
                cmp #"E"
                beq enter_language

                ldx #LANGUAGE_MODE_ZSAVE
                cmp #"Z"
                beq enter_language

                ldx #LANGUAGE_MODE_ZRUN
                cmp #"R"
                beq enter_language
                ; fall through
                .pend
ply_and_svc_done: .block
                pla
                tay
                jmp svc.done
                .bend

;-------------------------------------------------------------------------

enter_language: .proc
                ; set the user flag for the language entry point.
                lda #1
                jsr osbyte

                ldx $f4
                lda #$8e        ;enter language ROM
                jmp osbyte
                .pend

;-------------------------------------------------------------------------

svc_help: .proc
                lda ($f2),y
                cmp #" "
                beq print_help
                cmp #13
                bne svc.done
print_help:
                tya
                pha
                jsr osnewl
                ldy #0
print_help_name_loop:
                lda aTheBasicEditor_0,y
                bne +
                lda #32
+
                jsr oswrch
                iny
                cpy #aC1984Acornsoft-aTheBasicEditor_0
                bne print_help_name_loop
                jsr osnewl
                jmp ply_and_svc_done
                .pend

;-------------------------------------------------------------------------

svc_brk: .proc
                tya
                pha

                jsr language.get_options
                and #OPTION_SHIFT_ESCAPE
                beq ply_and_svc_done ;taken if SHIFT+ESCAPE not enabled
                
                ldy osbyte_var($ba) ;ROM active at last BRK (MasRef
                                    ;D.2-56)
                cpy osbyte_var($bb) ;ROM number of socket containing
                                    ;BASIC (MasRef D.2-57)
                bne ply_and_svc_done;taken if not BRK in BASIC

                ; MasRef D.6-1
                lda $fd         ;error address LSB
                sta $f6         ;osrdsc address LSB
                
                lda $fe         ;... MSB
                sta $f7         ;... MSB

                ; Y=rom #
                jsr osrdsc

                cmp #17          ;was it Escape?
                bne ply_and_svc_done ;taken if not Escape

                jsr language.poll_shift
                bne ply_and_svc_done ;taken shift not pressed

                ; Shift+ESCAPE pressed during BASIC...
                lda #$7e        ;acknowledge escape (MasRef D.2-37)
                jsr osbyte
                
                ldx #LANGUAGE_MODE_SHIFT_ESCAPE
                jmp enter_language
                
                .pend

;-------------------------------------------------------------------------

svc_osbyte: .proc
                lda $ef
                cmp #OPTIONS_OSBYTE
                bne svc.done

                ; save off old value
                lda $df0,x
                pha

                ; update value, if X bit 7 clear
                lda $f0
                bmi +
                sta $df0,x
+

                ; return old value in X
                pla
                sta $f0
                jmp svc.claimed
                
                .pend

;-------------------------------------------------------------------------

osbyte_x00_yff:
                ldx #$00
osbyte_yff:
                ldy #$ff
                jmp osbyte

;-------------------------------------------------------------------------

; get_default_wordv: .proc
;                 lda $ffb7
;                 sta $a8
;                 lda $ffb8
;                 sta $a9
;                 ldy #<wordv
;                 lda ($a8),y     ;lsb
;                 tax
;                 lda ($a8),y     ;msb
;                 tay
;                 rts
;                 .pend

; osword_hook: .proc
;                 sta $ef
;                 stx $f0
;                 sty $f1
;                 jsr get_default_wordv
;                 jsr call_osword

;                 php
;                 pha
;                 txa
;                 pha
;                 tya
;                 pha
                
;                 bcc not_us

;                 lda #$fc        ;read language ROM number (AUG 243)
;                 jsr osbyte_x00_yff
;                 sta $ef
                
;                 lda #$bb        ;read BASIC ROM number
;                 jsr osbyte_x00_yff
;                 txa

;                 tsx
;                 cmp $ef
;                 bne not_us      ;taken if not BASIC ROM

;                 ; poll SHIFT
;                 lda #$81        ;poll for key (MasRef D.2-38)
;                 ldx #$ff        ;-1, shift
;                 jsr osbyte_yff
;                 inx
;                 bne not_us      ;taken if X!=$ff, i.e., shift not
;                                 ;pressed
                
;                 ; Shift+ESCAPE pressed during BASIC...
;                 lda #$7e        ;acknowledge escape (MasRef D.2-37)
;                 jsr osbyte
                
;                 ldx #LANGUAGE_MODE_NORMAL
;                 jmp enter_language

; not_us:
;                 pla
;                 tay
;                 pla
;                 tax
;                 pla
;                 sta $ef
;                 plp
;                 rts

; call_osword:
;                 lda $f0
;                 stx $f0
;                 tax
;                 lda $f1
;                 sty $f1
;                 tay
;                 lda $ef
;                 jmp ($f0)
                
                ; .pend

;-------------------------------------------------------------------------
                
                .bend
                .send service
;-------------------------------------------------------------------------

                .section language
language: .block
; .logical LANG_BASE+(*-SVC_BASE)

init_language_entry_mode: .proc
                ; read the user flag that was set by the service call
                ; 4 handler.
                lda #1
                ldx #0
                jsr osbyte

                stx language_entry_mode

                cpx #LANGUAGE_MODE_ZSAVE
                beq zsave

                cpx #LANGUAGE_MODE_ZRUN
                beq zrun
ret:
                rts

zsave:
                jsr saving_message
                jsr zsave_command
                jmp exit_and_OLD

zrun:
                jsr saving_message
                jsr zsave_command
                jmp exit_and_OLD_and_RUN

saving_message:
                lda #1
                sta editor_mode_id  ; 1=command mode, 2=edit mode
                
                jsr find_program_name
                bcc ret

                jsr print_next_string
                .text "Saving: ",255
                
                jsr print_program_name
                jmp osnewl

.pend
                
language_entry: .proc
                cmp     #1              ; normal language entry?
                beq     language_start
                rts

language_start:
                .if ENABLE_DEBUG
                jsr reset_debug_values
                .endif
                
                jsr     init_brkv_and_oshwm
                jsr     clear_line_commands
                jsr     sub_B358
                ldx     #5
                stx     tab_value
                ldx     #$60 ; '`'
                stx     cursor_size
                ldx     #0
                stx     search_string_length
                inx
                stx     is_insert_mode  ; 0=overtype 1=insert
                stx     is_scroll_on   ; 1=scroll, 0=noscroll
                lda     #$E4
                jsr     osbyte_with_y0
                jsr     clear_error_message_buffer
                ldx #$ff
                jsr     get_HIMEM_for_mode_X
                lda     #0
                sta     background_colour
                sta case_insensitive_search
                lda     #7
                sta     foreground_colour

                jsr     sub_8314
                jsr     find_program
                bcc     language_start_good_program
                jsr     clear_program
                jsr     clear_error_message_buffer

language_start_good_program:

                jsr init_language_entry_mode

                lda     #$D2
                jsr     osbyte_with_x0_y0 ;suppress sound
                
                jsr print_next_string
                .byte 254       ;allow control chars
                .byte 3         ;printer off
                .byte 6         ;enable VDU drivers
                .byte 4         ;use text cursor
                .byte 26        ;restore default windows
                .byte 12        ;CLS
                .byte 15        ;disable paged mode
                .byte 20        ;reset VDU19 stuff
                .byte 255

                ; The default windows are in effect, so text window
                ; right column is the edge of the screen. Try to
                ; detect 20-column modes, and switch to MODE 135 if
                ; necessary, putting you in a 40-column mode that
                ; definitely doesn't take up more memory than the old
                ; one.
                
                ldx #$0a        ;text window right column
                jsr read_vdu_variable

                cpx #39
                bcs display_initialized

                ; this does some pointless stuff, but it's fewer bytes
                ; than doing it manually...
                ldy #135
                jsr set_mode

display_initialized:
                jsr set_palette

command_prompt_loop:

                ldx     #$FF
                txs
                
                jsr     initialise
                jsr     find_program
                bcs     loc_8147
                jsr     is_program_empty ; sets C if no program
                bcs     loc_8147
                lda     current_line_no_msb
                sta     byte_2B
                lda     current_line_no_lsb
                sta     byte_2C
                jsr     find_line_by_number ; finds a line, given a line number
                                        ;
                                        ; Entry:
                                        ; byte_2B: line number MSB
                                        ; byte_2C: line number LSB
                                        ;
                                        ; Exit:
                                        ; (byte_2B) points to most suitable line
                ldy     #1
                lda     (byte_2B),y
                bpl     loc_8144
                jsr     sub_AA77        ; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_8144:                               
                jsr     save_line_number ; saves line number from program.
                                        ;
                                        ; Entry:
                                        ; (byte_2b) points to current line
                                        ;
                                        ; Exit:
                                        ; current_line_no_msb, current_line_no_lsb = the line number

loc_8147:
                ; do a one-time check for SHIFT+ESCAPE - if entered
                ; due to SHIFT+ESCAPE, and the options byte says edit
                ; mode was the last one used, go to edit mode.
                lda language_entry_mode
                cmp #LANGUAGE_MODE_SHIFT_ESCAPE
                bne +           ;not SHIFT+ESCAPE, or we already
                                ;checked

                ; pretend it was entered with LANGUAGE_MODE_NORMAL
                lda #LANGUAGE_MODE_NORMAL
                sta language_entry_mode

                jsr get_options
                and #OPTION_EDIT_MODE
                beq +           ;taken if last mode wasn't edit mode

                jmp enter_edit_mode
                
+
                
                jsr clear_edit_mode_option
                jsr     print_command_prompt
                jsr     do_command_line

command_loop:
                lda     editor_mode_id  ; 1=command mode, 2=edit mode
                cmp     #2              ; edit mode?
                bne     command_prompt_loop ; branch taken if command mode already
                
                ; leave edit mode
                lda     last_error_number
                beq     loc_8163
                
                lda     current_line_no_msb
                sta     byte_50
                lda     current_line_no_lsb
                sta     byte_51
                
                jmp     command_prompt_loop

loc_8163:                               
                lda     byte_6C1
                cmp     #-1
                beq     command_prompt_loop
                
                sta     byte_3A
                lda     byte_6C0
                sta     byte_39
                ldy     #1
                lda     (byte_39),y
                sta     byte_50
                iny
                lda     (byte_39),y
                sta     byte_51
                
                jmp     command_prompt_loop
; End of function language_entry
                .pend

;-------------------------------------------------------------------------

init_brkv_and_oshwm: .proc

                cli
                cld
                lda     #<brk_handler
                sta     brkv+0
                lda     #>brk_handler
                sta     brkv+1
                lda     #0
                sta     oshwm
                sta     unk_6AD
                lda     #$83
                jsr     OSBYTE          ; Read OSHWM
                sty     oshwm+1         ; $18 = MSB
                lda     #$82
                jsr     OSBYTE          ; Read machine higher order address
                stx     higher_order_address
                sty     higher_order_address+1
                lda     #0
                sta     unk_6B8
                lda     #$A
                sta     unk_6B9
                rts
.pend
                
get_HIMEM_for_mode_X: .proc
                ldy     higher_order_address
                iny
                bne     is_tube
                ldy     higher_order_address+1
                iny
                beq     is_not_tube

is_tube:
                lda #<LANG_BASE
                sta HIMEM+0
                lda #>LANG_BASE
                sta HIMEM+1                
                rts

is_not_tube:
                lda #132        ;read HIMEM for current MODE
                cpx #$ff
                beq get_HIMEM
                lda     #133    ;read HIMEM for given MODE
get_HIMEM:
                jsr     OSBYTE
                stx     HIMEM
                sty     HIMEM+1
                rts
; End of function validate_mode


.pend
print_command_prompt: .proc
                bit should_cls_before_command_prompt
                bpl +
                lsr should_cls_before_command_prompt
                lda #12
                jsr oswrch
+


                lda     last_error_number
                beq     loc_82CB
                jsr display_error_message

loc_82CB:
                jsr print_bytes_free
                
                jsr print_next_string
                .text ' '

                .if ENABLE_DEBUG
                .text 'D'
                .endif
                
                .text '>',255
                
                lda     is_insert_mode  ; 0=overtype 1=insert
                pha
                lda     cursor_size
                pha
.if !ELECTRON
                lda     #0
.else
                lda     #1
.endif
                sta     is_insert_mode  ; 0=overtype 1=insert
                lda     #$60 ; '`'
                sta     cursor_size
                jsr     reset_cursor_shape
                pla
                sta     cursor_size
                pla
                sta     is_insert_mode  ; 0=overtype 1=insert
                rts
.pend

display_error_message: .proc

                jsr     OSNEWL

                ldx     #79
                ldy     #40

loc_82AE:                               
                lda     error_message_buffer+38,y
                cmp     #' '
                bne     loc_82BA ;taken if not space
                dey
                bne     loc_82AE
                ldx     #39

loc_82BA:
                txa
                ldx     #<error_message_buffer
                ldy     #>error_message_buffer
                jsr     print_n_chars
                
                jsr     OSNEWL
                jsr     OSNEWL
                jmp     beep
.pend

get_text_window_left_bottom:            
                                        
                ldx     #8
                lda     #$A0
                jmp     OSBYTE
; End of function get_text_window_left_bottom




clear_program:                          
                                        
                ldy     #0
                lda     #$D
                sta     (oshwm),y
                iny
                lda     #-1
                sta     (oshwm),y
                jsr     find_program
                lda     #0
                sta     current_line_no_msb
                lda     #$A
                sta     current_line_no_lsb
                jsr     sub_B358
                jmp     clear_line_commands
; End of function clear_program




sub_8314:                               
                                        
                lda     #0
                sta     current_line_no_msb
                sta     current_line_no_lsb
                sta     byte_50
                sta     byte_51
                rts
; End of function sub_8314




find_program:                           
                                        
                lda     #0
                sta     is_bad_program
                sta     byte_38
                sta     ptr0+0
                sta     ptr0+1
                pha
                lda     #$FF
                pha
                pha
                lda     oshwm+1
                sta     byte_39

find_program_scan_line:                         
                ldy     #0
                lda     (byte_38),y     ; get first char in line
                cmp     #$D             ; is it the required 13?
                beq     line_start_ok

bad_program:                            
                pla
                pla
                pla
                inc     is_bad_program ;?is_bad_program=1
                lda     #1             ;"Bad program"
                jsr     get_error       ; A = error code
                sec                     ; bad program
                rts

line_start_ok:                          
                iny
                lda     (byte_38),y     ; line MSB
                bpl     scan_valid_line ; if +ve, not end
; reached end, so set TOP to just past the terminating $FF
                clc
                lda     byte_38
                adc     #2
                sta     TOP
                lda     #0
                adc     byte_39
; gone past the relevant HIMEM?
                sta     TOP+1
                cmp     HIMEM+1
                bcc     TOP_in_bounds
                bne     force_mode_7
                lda     HIMEM
                cmp     TOP
                bcs     TOP_in_bounds

force_mode_7:
                ; Switch to mode 135, in an attempt to get as much
                ; room as possible. Worst case, you just get Mode 7.
                
                jsr print_next_string
                .text 254
                .text 22,135
                .text 255
                
                ldx     #$ff
                jsr     get_HIMEM_for_mode_X
                
                lda     #3        ;"No room - Mode reset"
                jsr     get_error       ; A = error code

TOP_in_bounds:                          
                                        
                pla
                pla
                pla
                beq     find_program_good_program
                jsr     sub_8495

find_program_good_program:
                clc
                rts
; (seems to be maintaining its own notion of line numbering - not sure what for - it never does anything particular if it encounters a discrepancy)

scan_valid_line:                        
                lda     ptr0+0
                bmi     loc_8387
                clc
                lda     ptr0+1
                adc     #10
                sta     ptr0+1
                bcc     loc_8387
                inc     ptr0+0

loc_8387:                               
                                        
                pla
                bmi     loc_83A0
                cmp     (byte_38),y
                beq     loc_8392
                bcc     loc_83A0
                bcs     loc_839A

loc_8392:                               
                iny
                pla
                cmp     (byte_38),y
                bcs     loc_839B
                bcc     loc_83A1

loc_839A:                               
                pla

loc_839B:                               
                pla
                lda     #1
                pha
                pha

loc_83A0:                               
                                        
                pla

loc_83A1:                               
                ldy     #2

loc_83A3:                               
                lda     (byte_38),y
                pha
                dey
                bne     loc_83A3
                ldy     #3
                lda     (byte_38),y     ; get line length
                bmi     next_line       ; if >=128, it's fine
                cmp     #4
                bcc     bad_program     ; if <4, bad program

next_line:                              
                clc
                adc     byte_38
                sta     byte_38
                bcc     scan_next_line
                inc     byte_39

scan_next_line:                         
                jmp     find_program_scan_line
; End of function find_program




initialise:                             
                jsr     init_brkv_and_oshwm
                ldx     #$ff
                jsr     get_HIMEM_for_mode_X
                lda     #3              ; select output streams (AUG p119)
                jsr     osbyte_with_x0_y0; default output streams
                lda     #2              ; select input stream (AUG p118)
                jsr     osbyte_with_x0_y0; keyboard on, rs423 off
                lda     #4              ; enable/disable cursor editing (AUG p120)
                jsr     osbyte_with_x0_y0; enable cursor editing

                ; This seems a bit pointless - especially after it got
                ; in the way of some event-driven debug stuff of mine!
                ; - but maybe there's a good reason for it that I'll
                ; rediscover the hard way.
                
;                 LDA     #13             ; Disable events (AUG p129)
;                 LDX     #9
;                 STX     byte_3A

; disable_all_events_loop:                
;                 LDX     byte_3A
;                 JSR     osbyte_with_y0
; ; X=0 now
;                 DEC     byte_3A
;                 BPL     disable_all_events_loop

                
                lda     #200            ; set ESCAPE, BREAK effect (AUG p205)
                ldx #0
                ldy     #%11111110      ; normal ESCAPE action (bit 0 reset)
                jsr     OSBYTE
                lda     #219            ; read/write TAB key char (AUG p222)
                jsr     osbyte_with_x0_y0 ; TAB key produces CHR$0
                ldx     #27             ; ESCAPE key produces CHR$27
                lda     #220            ; read/write Escape char (AUG p223)
                jsr     osbyte_with_y0
                
                lda     #225            ; read/write function key status (AUG p225)
                jsr     osbyte_with_x0_y0 ; ignore key
                
                lda     #226            ; read/write SHIFT+function key status (AUG p225)
                jsr     osbyte_with_x0_y0  ; ignore key
                
                lda     #227            ; read/write CTRL+function key status (AUG p225)
                jsr     osbyte_with_x0_y0 ; ignore key
                
                lda     #229            ; read/write status of ESCAPE key (AUG p227)
                jsr     osbyte_with_x0_y0 ; ESCAPE has normal action
                
                lda     #230            ; read/write flags determining ESCAPE effects (AUG p228)
                jsr     osbyte_with_x0_y0 ; ESCAPE has normal effects

                lda     #1
                sta     editor_mode_id  ; 1=command mode, 2=edit mode
                lda     #0
                sta     byte_6B3
                rts
; End of function initialise


loc_8437:
; Set cursor keys and COPY to produce ASCII                 
                ldx     #2
                lda     #4
                jsr     OSBYTE
; Set function keys to produce ASCII $A0...$A9
                ldx     #$A0
                lda     #225
                jsr     osbyte_with_y0
; Set SHIFT+function keys (BBC) or FUNC+A-P (Electron) to produce ASCII $B0...$B9
                ldx     #$B0
                lda     #226
                jsr     osbyte_with_y0
; Set Ctrl+function keys (BBC) or FUNC+Q-Z+punctuation (Electron) to produce ASCII $C0...$C9
                ldx     #$C0 ; '�'
                lda     #227
                jmp     osbyte_with_y0

;-------------------------------------------------------------------------

brk_handler: .proc
                jsr     clear_error_message_buffer
                ldy     higher_order_address
                iny
                bne     loc_846C ;taken if in 2nd processor
                ldy     higher_order_address+1
                iny
                bne     loc_846C ;taken if in 2nd processor

                ; Allow error messages in page 1, presumed to be from
                ; the FS.
                lda     $FE
                cmp     #1
                beq     loc_846C ;taken if page 1 - assumed to be from
                                 ;DFS or something

                ; Disallow non-OS error messages.
                cmp     #$C0
                bcc     loc_848A ;taken if page 0 or 2-$bf

loc_846C:

                ; skip BRK error number
                sei
                inc     $FD
                bne     loc_8473
                inc     $FE

                ; copy BRK text
loc_8473:                               
                ldy     #0

loc_8475:                               
                lda     ($FD),y
                cmp     #$20 ; ' '
                bcc     loc_8483
		sta	error_message_buffer,y
		iny
		cpy	#error_message_buffer_size
		bcc	loc_8475

loc_8483:				
		cli
		lda	#$ff    ;arbitrary non-0 value
		sta	last_error_number
		bne	loc_848F ;(jmp)

loc_848A:				
		lda	#2        ;"Unknown error"
		jsr	get_error	; A = error code

loc_848F:
                jsr maybe_verbose_exit_on_error
                jmp	language_entry.command_loop

.pend
                
sub_8492:				
		jsr	find_program
; End of function sub_8492




sub_8495:				
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		cmp	#2
		bne	loc_849F
		jsr	make_cursor_invisible

loc_849F:				
		ldx	#10
		lda	ptr0+0
		bpl	loc_84A7
		ldx	#3

loc_84A7:				
		stx	byte_3A
		lda	oshwm
		sta	unk_33
		sta	basic_ptr_1+0
		lda	oshwm+1
		sta	basic_ptr_1+1

loc_84B3:				
		ldy	#1
		lda	(basic_ptr_1),y
		bpl	loc_84BC
		jmp	loc_854F

loc_84BC:				
		ldy	#3
		lda	(basic_ptr_1),y
		sta	unk_37
		lda	#0
		sta	byte_38
		iny
		sty	unk_34

loc_84C9:				
		ldy	unk_34
		clc
		tya
		adc	#3
		bcs	loc_84D5
		cmp	unk_37
		bcc	loc_84D8

loc_84D5:				
		jmp	loc_853F

loc_84D8:				
		lda	byte_38
		beq	loc_84DF

loc_84DC:				
		jmp	loc_852E

loc_84DF:				
		lda	(basic_ptr_1),y
		cmp	#$8D
		bne	loc_84DC
		jsr	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		jsr	sub_85AC

loc_84EB:				
		ldy	#1
		lda	(basic_ptr_0),y
		bpl	loc_8505
		ldx	#4
		stx	unk_33
		ldy	unk_34
		lda	#'@'

loc_84F9:				
		sta	(basic_ptr_1),y
		iny
		dex
		bne	loc_84F9
		dey

loc_8500:				
		sty	unk_34
		jmp	loc_852E

loc_8505:				
		cmp	byte_21
		bne	loc_8529
		iny
		lda	(basic_ptr_0),y
		cmp	byte_22
		bne	loc_8529
		ldx	byte_35
		ldy	byte_36
		jsr	sub_85D8
		stx	byte_36
		sty	byte_35
		ldy	unk_34
		ldx	#2

loc_851F:				
		iny
		sta	(basic_ptr_1),y
		lda	unk_34,x
		dex
		bpl	loc_851F
		bmi	loc_8500

loc_8529:				
		jsr	sub_85BF
		bne	loc_84EB

loc_852E:				
		lda	(basic_ptr_1),y
		cmp	#$22 ; '"'
		bne	loc_853A
		lda	byte_38
		eor	#1
		sta	byte_38

loc_853A:				
		inc	unk_34
		jmp	loc_84C9

loc_853F:				
		ldy	#3
		clc
		lda	(basic_ptr_1),y
		adc	basic_ptr_1+0
		sta	basic_ptr_1+0
		bcc	loc_854C
		inc	basic_ptr_1+1

loc_854C:				
		jmp	loc_84B3

loc_854F:				
		jsr	sub_85AC

loc_8552:				
		ldy	#1
		lda	(basic_ptr_0),y
		bmi	loc_858A
		ldx	#$11

loc_855A:				
		ldy	#2
		lda	byte_40,x
		cmp	(basic_ptr_0),y
		bne	loc_8575
		dex
		dey
		lda	byte_40,x
		cmp	(basic_ptr_0),y
		bne	loc_8576
		lda	byte_35
		ora	#$80 ; '�'
		sta	byte_40,x
		inx
		lda	byte_36
		sta	byte_40,x

loc_8575:				
		dex

loc_8576:				
		dex
		dex
		bpl	loc_855A
		ldy	#1
		lda	byte_35
		sta	(basic_ptr_0),y
		iny
		lda	byte_36
		sta	(basic_ptr_0),y
		jsr	sub_85BF
		bne	loc_8552

loc_858A:				
		ldx	#$10

loc_858C:				
		lda	byte_40,x
		and	#$7F ; ''
		sta	byte_40,x
		dex
		dex
		dex
		bpl	loc_858C
		lda	unk_33
		beq	locret_85BE
		lda	#7      ;"Target not found"

raise_error:				
					
		ldx	unk_6AD
		beq	loc_85A6
		sta	unk_6AD
		rts

loc_85A6:				
		jsr	get_error	; A = error code
		jmp	language_entry.command_loop;???
; End of function sub_8495




sub_85AC:				
		lda	oshwm
		sta	basic_ptr_0+0
		lda	oshwm+1
		sta	basic_ptr_0+1
		lda	unk_6B8
		sta	byte_35
		lda	unk_6B9
		sta	byte_36

locret_85BE:				
		rts
; End of function sub_85AC




sub_85BF:				
		ldy	#3
		clc
		lda	(basic_ptr_0),y
		adc	basic_ptr_0+0
		sta	basic_ptr_0+0
		bcc	loc_85CC
		inc	basic_ptr_0+1

loc_85CC:				
		clc
		lda	byte_3A
		adc	byte_36
		sta	byte_36
		bcc	locret_85D7
		inc	byte_35

locret_85D7:				
		rts
; End of function sub_85BF




sub_85D8:				
		stx	ptr0+0
		sty	ptr0+1
		ldx	#1
		stx	ptr1+0

loc_85E0:				
		lda	$C,x
		asl
		rol	ptr1+0
		asl
		rol	ptr1+0
		sec
		ror
		lsr
		sta	$C,x
		dex
		bpl	loc_85E0
		lda	ptr1+0
		asl
		asl
		eor	#$14
		ldx	ptr0+1
		ldy	ptr0+0
		rts
; End of function sub_85D8
; 0

error_message: .macro text
                .text \text|$80
                .endm
                
error_messages_table:
                .error_message "Bad program" ;1
                .error_message "Unknown error" ;2
                .error_message "No room - Mode reset" ;3
                .error_message "Line too long" ;4
		.error_message "No room"   ;5
                .error_message "Missing line command" ;6
                .error_message "Target not found" ;7
                .error_message "String not found" ;8
                .error_message "Bad command" ;9
                .error_message "Bad argument" ;10
                .error_message "Bad number" ;11
                .error_message "Too many arguments" ;12
                .error_message "Bad mode" ;13
                .error_message	"No room for this mode" ;14
                .error_message "No references to labels were found" ;15
                .error_message "Unresolved labels - please check" ;16
                .error_message "Line too long to be numbered" ;17
                .error_message	"Line too long to contain label" ;18
                .error_message "No labels reinstated" ;19
                .error_message "Lines too long to be joined" ;20
                .error_message "Only [NRGYBMCW] are valid" ;21
                .error_message	"Bad line number" ;22
                .error_message "Replace string missing" ;23
                .error_message "Only two strings allowed" ;24
                .error_message "Start line/Increment too big" ;25
                .error_message "Too many line commands" ;26
                .error_message "Incompatible line commands" ;27
                .error_message "Bad delete command" ;28
                .error_message "Bad destination" ;29
                .error_message "Destination missing" ;30
                .error_message "Incomplete line command" ;31
                .error_message "Argument missing" ;32
                .error_message "Tab stop must be 0-80" ;33
                .error_message "No marked line" ;34
                .error_message "No search string set up" ;35
                .error_message "Line has been truncated" ;36
                .error_message "Updates would make line too long" ;37
                .error_message "Increment must be 1-255" ;38
                .error_message "No REM>"                 ;39
                .byte  $FF ;
                
empty_program_string:.byte  $1F	;
		.byte	 3 ;
		.byte	 0 ;
		.byte  $31 ; 1
		.byte  $30 ; 0
nur_dlo_string:	.byte	$D 
		.byte  $4E ; N
		.byte  $55 ; U
		.byte  $52 ; R
		.byte	$D ;
		.byte  $44 ; D
		.byte  $4C ; L
		.byte  $4F ; O
six_spaces_string:.byte	 $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
                .byte  $20 ;
colour_chars:
                .text "NRGYBMCW"

colour_names_table: .proc
base:
                .byte black-base,red-base,green-base,yellow-base,blue-base,magenta-base,cyan-base,white-base,end-base
black:
                .text "black"
red:
                .text "red"
green:
                .text "green"
yellow:
                .text "yellow"
blue:
                .text "blue"
magenta:
                .text "magenta"
cyan:
                .text "cyan"
white:
                .text "white"
end:
                .pend

aMarkedLine:
                .text "Marked line: "
aMarkedLineEnd:
                .text "None"
aMarkedLineNoneEnd:
                
aPendingCommands:
                .text "Pending commands: "
aPendingCommandsEnd:
                .text "None"
aPendingCommandsNoneEnd:
                
aLastSearch:
                .text "Last search : "
aLastSearchEnd:
                .text "None"
aLastSearchNoneEnd:
                
TENS:=(1,10,100,1000,10000)
tensL:
                .byte <TENS
tensH:
                .byte >TENS

;-------------------------------------------------------------------------

print_on_off: .proc
                ; prints "Off" if Z set, "On" if Z clear
                beq off

                jsr print_next_string
                .text "On",255
                
                rts

off:
                jsr print_next_string
                .text "Off",255
                
                rts
                
                .pend

;-------------------------------------------------------------------------

do_command_line .proc		
		jsr	clear_error_message_buffer
		lda	#<unk_700
		sta	readline_ptr_lsb
		lda	#>unk_700
		sta	readline_ptr_msb
		lda	#max_command_line_length
		jsr	read_line
		bcc got_command_line
                
; ESCAPE was pressed at command line

                jsr poll_shift
                beq bye
                
		lda	is_bad_program
		bne do_command_line_done
		jmp	enter_edit_mode

got_command_line:			
		jsr	parse_command_line
		jmp	execute_command	; unk_6BD = command to run

do_command_line_done:					
                rts

bye:
                lda #CMD_EXIT
                sta current_command_id
                jmp run_or_exit_command
                
                
; End of function do_command_line
                .pend

;-------------------------------------------------------------------------

command: .macro text,flags,id
                .text \text,0
                .byte \flags
                .byte \id
                .endm
                
command_table:
                .command "APPEND",9,CMD_APPEND
                .command "BACK",$21,CMD_BACK
                .command "CHANGE",$15,CMD_CHANGE
                .command "END",0,CMD_END
                .command "EDIT",5,CMD_EDIT
                .command "EXIT",0,CMD_EXIT 
                .command "FIND",5,CMD_FIND
                .command "FORE",$21,CMD_FORE
                .command "GOTO",0,CMD_GOTO
                .command "HELP",0,CMD_HELP
                .command "ICHANGE",$15,CMD_ICHANGE
                .command "IE",0,CMD_IE
                .command "IFIND",5,CMD_IFIND
                .command "INFO",0,CMD_INFO
                .command "INSERT",0,CMD_INSERT
                .command "IT",0,CMD_IT
                .command "LOAD",9,CMD_LOAD
                .command "LABEL",0,CMD_LABEL
                .command "MODE",3,CMD_MODE
                .command "NEW",0,CMD_NEW
                .command "NOSCROLL",0,CMD_NOSCROLL
                .command "NUMBER",0,CMD_NUMBER
                .command "OLD",0,CMD_OLD
                .command "OVERTYPE",0,CMD_OVERTYPE
                .command "QICHANGE",$15,CMD_QICHANGE
                .command "QCHANGE",$15,CMD_QCHANGE
                .command "RUN",0,CMD_RUN
                .command "RENUMBER",$45,CMD_RENUMBER
                .command "SAVE",9,CMD_SAVE
                .command "SCROLL",0,CMD_SCROLL
                .command "TOP",0,CMD_TOP
                .command "TAB",3,CMD_TAB
                .command "ZSAVE",0,CMD_ZSAVE
                .command "ZRUN",0,CMD_ZRUN

		.byte  $FF
byte_8C95:	.byte $A		
					
byte_8C96:	.byte 9			

;-------------------------------------------------------------------------

parse_command_line: .proc		
		ldy	#0
		sty	current_command_id
		lda	#<unk_700
		sta	ptr0+0
		lda	#>unk_700
		sta	ptr0+1
; Skip spaces at the start of the command line

skip_initial_spaces_loop:		
		lda	(ptr0),y
		cmp	#' '
		bne	found_non_space
		inc	ptr0+0
		bne	+
		inc	ptr0+1
+
		bne	skip_initial_spaces_loop

found_non_space:			
		cmp	#13
		beq	done2

try_star:				; is it	looking	like a * command?
		cmp	#'*'
		bne	try_number	; branch taken if it's not a * command
		lda	#CMD_star	; ok, it IS a *	command

store_current_command:			
					
		sta	current_command_id

done2:					
		rts

try_number:				
		jsr	atoi    ; entry: (unk_C) points to text; exit:
                                ; C set if error, or (input_ptr) holds
                                ; value
		bcs	try_command ; branch taken if command doesn't look like
                                    ; a number
		ldy	#0

skip_number_loop:			
		lda	(ptr0),y	; get number char
		cmp	#13
		beq	is_line_number	; branch taken if end of command line
		cmp	#32
		beq	skip_post_number_spaces_loop ; branch taken if end of number
		iny
		bne	skip_number_loop

skip_post_number_spaces_loop:		
					
		iny
		lda	(ptr0),y	; get whitespace char
		cmp	#13		; end of command line?
		beq	is_line_number	; branch taken if end of command line
		cmp	#32            ; just a space?
		beq	skip_post_number_spaces_loop ; keep going if so
; any non-space chars after the line number are invalid.
		lda	#22		; "Bad line number"
		jmp	raise_error

is_line_number:				
					
		lda	#CMD_goto_line
		bne	store_current_command ;	JMP, in	effect

try_command:				
		jsr	find_first_non_alpha_char
		lda	#<command_table
		sta	ptr1+0
		lda	#>command_table
		sta	ptr1+1

try_this_command:			
		ldy	#0
		lda	(ptr1),y	; get next char	from command table
		bmi	invalid_command	; invalid, if reached end of table
		jsr	compare_cmd_char_to_input_char ; entry:	(unk_C)	points to input	char, (unk_E) points to	command	table char
					; exit:	C set if matched
		bcs	char_matched
; advance to next command in table

find_end_of_command_name_loop:		
		lda	(ptr1),y
		beq	found_end_of_command_name
		iny
		bne	find_end_of_command_name_loop

found_end_of_command_name:		
		iny			; skip terminating 0
		iny			; skip args byte
		iny			; skip command ID
; add Y to table pointer
		clc
		tya
		adc	ptr1+0
		sta	ptr1+0
		bcc	loc_8D12
		inc	ptr1+1

loc_8D12:				
		bne	try_this_command ; JMP,	in effect

invalid_command:			
		lda	#9		; "Bad command"
		jmp	raise_error

char_matched:				
		sty	byte_3A

find_end_of_command_name_loop_2:	
		lda	(ptr1),y
		beq	found_end_of_command_name_2
		iny
		bne	find_end_of_command_name_loop_2

found_end_of_command_name_2:		
		iny			; skip terminating 0
		sty	byte_39		; $39 =	Y pointing into	data
		lda	(ptr1),y		; get first byte of command data
		sta	command_flags		; $49 =	first byte of command data
		ldy	byte_3A
		lda	(ptr0),y		; get last matched input char
		ldx	#0
		cmp	#13		; end of line there?
		beq	loc_8D52
		cmp	#'.'            ; abbreviated input?
		bne	skip_spaces	; branch taken if not abbreviated
		iny			; just skip the	'.'
; Skip spaces after command

skip_spaces:				
					
		lda	(ptr0),y
		cmp	#32
		bne	spaces_skipped
		iny
		bne	skip_spaces

spaces_skipped:				
		cmp	#13		; end of command line?
		beq	loc_8D52
		inx			; X=1
; Set (input_ptr) to point to remainder of command line
		clc
		tya
		adc	ptr0+0
		sta	input_ptr+0
		lda	ptr0+1
		adc	#0
		sta	input_ptr+1

loc_8D52:				
					
		txa			; get 0	(no args entered) or 1 (args entered)
		eor	command_flags		; Set bit 0 if state differs from command's requirements
		and	#1		; Extract bit 0
		beq	loc_8D69	; Branch taken if command wants	args and some were entered/it doesn't and there weren't
		lda	command_flags
		and	#4		; String arg?
		bne	loc_8D69	; branch taken if string arg wanted but	one wasn't supplied
; "Invalid argument" if an unnecessary one was specified; "Argument missing" if a necessary one wasn't.
		lda	#$A		; "Invalid argument"
		dex
		beq	loc_8D66
		lda	#$20 ; ' '      ; "Argument missing"

loc_8D66:				
		jmp	raise_error

loc_8D69:				
					
		txa			; get 0	(no args entered) or 1 (args entered)
		beq	no_args_entered	; branch taken if no args entered
		lda	command_flags		; get args byte
		and	#2		; test bit 1 (single numeric arg)
		beq	loc_8D94	; branch taken if command wants	something else
; command wants single numeric argument
		jsr	atoi_from_command_line ; entry:	(input_ptr) points to command line;
					; exit:	C set if error,	or (input_ptr+0, input_ptr+1) holds result.
		bcc	skip_post_number_spaces
		lda	#$B		; "Bad number"
		jmp	raise_error

skip_post_number_spaces:		
					
		lda	(ptr0),y
		cmp	#32
		bne	skipped_post_number_spaces
		iny
		bne	skip_post_number_spaces

skipped_post_number_spaces:		
		cmp	#13		; end of command line after the	number?
		beq	loc_8D94	; branch taken if so
					;
					; (This	branch is wrong, I think, as 8D94...
					; keeps	scanning from (input_ptr), even
					; though that now contains the number.
					; It wants to go to got_command	instead.)
		lda	#$C		; "Too many arguments"
		jmp	raise_error

no_args_entered:			
		lda	#$FF		; mark lack of args ($FF isn't the MSB of any valid number)
		sta	input_ptr+1
		bne	got_command	; JMP, in effect

loc_8D94:				
					
		ldy	#0

find_end_of_command_line_loop:		
		lda	(input_ptr),y
		cmp	#$D
		beq	found_end_of_command_line
		iny
		bne	find_end_of_command_line_loop

found_end_of_command_line:		
		dey

find_end_of_last_argument_loop:		
		lda	(input_ptr),y
		cmp	#$20 ; ' '
		bne	found_end_of_last_argument
		dey
		jmp	find_end_of_last_argument_loop

found_end_of_last_argument:		
		iny
		sty	input_length

got_command:				
		ldy	byte_39		; get index into table (currently pointing at args byte)
		iny
		lda	(ptr1),y		; get command ID
		jmp	store_current_command

                .endproc

; Gets string representation of	16-bit number.
;
; Entry:
; Y,X =	value
;
; Exit:
; unk_0	holds digit count
; unk_1... filled with string

itoa: .proc

                stx itoa_value
                sty itoa_value+1

                ldy #4          ;tens column index
                ldx #0          ;output digit index
                lda #'0'
                sta itoa_uninteresting
input_loop:
                jsr digit

                ; get digit in this column, and skip it if not
                ; interesting.
                lda 1,x                
                cmp itoa_uninteresting 
                beq next_digit

                ; move to next output digit.
                inx

                ; effectively, make all digits interesting. 
                dec itoa_uninteresting
next_digit:
                ; next tens column.
                dey             
                bpl input_loop

                ; if 0 digits produced, it was 0, so actually 1 digit.
                txa
                bne +
                inx
+
                
                ; save output digit count.
                stx 0           
                rts

digit: .proc
                lda #'0'
                sta 1,x
output_loop:
                ; subtract current tens value, but don't store it in
                ; memory, in case there's a borrow.
                sec
                lda itoa_value+0
                sbc tensL,y
                pha
                lda itoa_value+1
                sbc tensH,y

                ; if borrow, done.
                bcc borrow

                ; store new value in memory.
                sta itoa_value+1
                pla
                sta itoa_value+0

                ; increment digit count and repeat.
                inc 1,x
                bne output_loop
                
borrow:
                ; discard new value and done.
                pla
                rts
                .pend

                .pend



; entry: (unk_C) points	to input char, (unk_E) points to command table char
; exit:	C set if matched

compare_cmd_char_to_input_char:		
		ldy	#0

compare_cmd_char_to_input_char_loop:					
		lda	(ptr0),y	; input	char
		cmp	#'A'
		bcc	not_alpha
		cmp	#'Z'+1
		bcs	not_alpha
		lda	(ptr1),y	; command table	char
		beq	didnt_match	; end of command?
		lda	(ptr0),y	; input	char
		cmp	#'.'
		bne	loc_8E35 ;taken if not abbreviated

not_alpha:				
					
		cpy	#0		; non-alpha at start?
		beq	didnt_match	; if so, didn't match
		sec			; otherwise, did match (e.g., "MO6" = "MO.6" = "MODE 6")
		rts

loc_8E35:				
		cmp	(ptr1),y
		bne	didnt_match
		iny
		bne	compare_cmd_char_to_input_char_loop		; input	char

didnt_match:				
					
		clc
		rts
; End of function compare_cmd_char_to_input_char




find_first_non_alpha_char:		
		ldy	#0

find_first_non_alpha_char_loop:					
		lda	(ptr0),y
		cmp	#'A'
		bcc	locret_8E6B
		cmp	#'Z'+1
		bcc	next_char
		cmp	#'a'
		bcc	locret_8E6B
		cmp	#'z'+1
		bcs	locret_8E6B
		eor	#$20
		sta	(ptr0),y

next_char:				
		iny
		bne	find_first_non_alpha_char_loop		; don't think Y is ever supposed to get to 0 again...
; End of function find_first_non_alpha_char




toggle_case:				
		cmp	#'A'
		bcc	locret_8E6B
		cmp	#'Z'+1
		bcc	loc_8E69
		cmp	#'a'
		bcc	locret_8E6B
		cmp	#'z'+1
		bcs	locret_8E6B

loc_8E69:				
		eor	#$20

locret_8E6B:				
					
		rts
; End of function toggle_case



; Set memory to	value.
;
; (ptr0) points to memory	to clear.
; X holds number of pages to clear.
; Y holds number of bytes to clear in Xth page.
; A holds value	to write.

memset: .proc
					
		sta	byte_3A
		tya
		pha			; save old Y
		lda	byte_3A
		ldy	#0
		cpx	#0
		beq	fill_last_page

fill_pages_loop:			
		sta	(ptr0),y		; write	byte
		iny			; next byte...
		bne	fill_pages_loop	; do a whole page
		inc	ptr0+1		; next page
		dex			; done all pages?
		bne	fill_pages_loop	; taken	if not all pages done yet

fill_last_page:				
		tay			; Y = value to store
		pla			; get original Y back
		beq	memset_done		; if 0 bytes to	fill in	last page, done
		tax			; X = #	bytes to fill in last page
		tya			; A = value to store
		ldy	#0

fill_last_page_loop:			
		sta	(ptr0),y		; write	byte
		iny			; next byte...
		dex			; done all bytes?
		bne	fill_last_page_loop ; taken if not all bytes done yet

memset_done:					
                rts
                .pend



osbyte_with_x0_y0:.proc
                ldx #0
                ; fall through
.pend
                
osbyte_with_y0:.proc
					
		ldy	#0
		jsr	OSBYTE
                rts
.pend
; End of function osbyte_with_y0



; print_itoa_result.
;
; Suitable for use with	the result of itoa.
;
; Entry:
; unk_0	= digit	count
; unk_1... = digits

; print_itoa_result: .proc
					

;                 .pend

;-------------------------------------------------------------------------
; move (maybe overlapping) memory regions.
;
; Entry:
; (ptr0) points to src
; (ptr1) points to dest
; X is MSB of size
; Y is LSB of size


memmove_8bit:
                .if ENABLE_DEBUG
                cpx #0
                beq memmove

                ; This is fine, sort of, in that it will copy the
                ; right number of bytes. But it wants noting, because
                ; obviously I've got something wrong...
                stx debug_flag
                
                .endif
                
memmove: .block
                .if ENABLE_DEBUG
                
                jsr inc_debug_counter

                pla
                sta debug_ptr+1
                pla
                sta debug_ptr+0
                pha
                lda debug_ptr+1
                pha
                
                .endif
                
		lda	ptr0+1		; get src MSB
		cmp	ptr1+1		; compare to dest MSB
		bcc	copy_down	; taken	if src<dest
		beq	copying_same_page ; taken if src MSB==dest MSB

copy_up:				
		tya
		pha			; save original	Y
		ldy	#0
		cpx	#0		; Any whole pages?
		beq	copy_up_last_page ; branch taken if no whole pages to copy

copy_up_pages_loop:			
		lda	(ptr0),y	; load from src...
		sta	(ptr1),y	; store	to dest...
		iny
		bne	copy_up_pages_loop ; branch taken if not copied	whole page yet
		inc	ptr0+1		; next src page
		inc	ptr1+1		; next dest page
		dex			; one more page	done
		bne	copy_up_pages_loop ; branch taken if not done all pages	yet

copy_up_last_page:			
		pla
		tax			; get original Y in X
		bne	copy_up_last_page_loop ; branch	taken if any bytes to copy in last page
		rts

copy_up_last_page_loop:			
		lda	(ptr0),y	; load from src...
		sta	(ptr1),y	; store	to dest...
		iny
		dex			; one more byte	done
		bne	copy_up_last_page_loop ; branch	taken if not done all bytes yet
		rts

copying_same_page:			
		lda	ptr0+0		; get src LSB
		cmp	ptr1+0		; compare to dest LSB
		bcs	copy_up		; branch taken if src>=dest

copy_down:				
		txa			; get page count
; Point src and dest at last page of each
		clc
		adc	ptr0+1
		sta	ptr0+1
		txa
		clc
		adc	ptr1+1
		sta	ptr1+1
		cpy	#0		; any bytes to copy at the end?
		beq	copy_down_pages	; branch taken if no bytes to copy at the end

copy_down_last_page_loop:		
		dey
		lda	(ptr0),y	; load from src...
		sta	(ptr1),y	; store	to dest...
		cpy	#0		; was that the last byte just copied?
		bne	copy_down_last_page_loop ; branch taken	if not on last byte

copy_down_pages:			
		cpx	#0		; any pages to copy?
		beq	memmove_done		; branch taken if no pages to copy

copy_down_pages_loop:			
		dec	ptr0+1		; point	to last	whole page in src
		dec	ptr1+1		; point	to last	whole page in dest

copy_down_page_loop:			
		dey
		lda	(ptr0),y	; load from src...
		sta	(ptr1),y	; store	to dest...
		cpy	#0		; was that the last byte just copied?
		bne	copy_down_page_loop ; branch taken if not on last byte
		dex			; one more page	done
		bne	copy_down_pages_loop ; branch taken if more pages to copy

memmove_done:					
		rts
                .bend

;-------------------------------------------------------------------------

gotoxy .proc					
					
		lda	#31		; set cursor location
		jsr	OSWRCH
		txa
		jsr	OSWRCH
		tya
		jmp	OSWRCH
; End of function gotoxy



.pend

prepare_for_print_1_char: .proc
                jsr is_bitmap_mode
                ror print_1_char_not_teletext ;set bit 7 if bitmap mode
                rts
                .pend

; print char in A.
print_1_char: .proc
                sta print_1_char_a
                sty print_1_char_y

                lda editor_mode_id
                beq done

                ldy #0
                cmp #1
                beq start
                ldy #' '
                
start:
                sty byte_3A

                lda print_1_char_a
                cmp #$7f
                beq print_space

                bit print_1_char_not_teletext
                bmi not_teletext

teletext:
                lda print_1_char_a
                cmp #141
                beq print_space

not_teletext:
                lda print_1_char_a
                cmp byte_3A
                bcs print_char

print_space:
                lda #' '

print_char:
                jsr oswrch
                
done:
                ldy print_1_char_y
                lda print_1_char_a
                rts
                
.pend

incz: .proc
                inc 0,x
                bne done
                inc 1,x
done:
                rts
.pend

print_next_string: .proc
                jsr prepare_for_print_1_char

                pla
                sta ptr0+0
                pla
                sta ptr0+1
                
                ldy #0
                ldx #ptr0+0
                jsr incz

                ; lda editor_mode_id
                ; pha

                ; If the first byte of the string is 254, take a
                ; different path that doesn't process control chars.
                lda (0,x)
                cmp #254
                beq print_control_chars

loop:
                lda (ptr0),y
                jsr incz
                cmp #255
                beq done
                jsr print_1_char
                jmp loop

done:
                ; pla
                ; sta editor_mode_id
                
                jmp (ptr0)

print_control_chars:
                jsr incz
-
                lda (0,x)
                jsr incz
                cmp #255
                beq done
                jsr oswrch
                jmp -

                .pend

print_5_spaces: .proc                               
                                        
                lda     #5

                ; fall through
.pend

print_n_spaces: .proc
					
                ldx     #<six_spaces_string
                ldy     #>six_spaces_string

                ; fall through
.pend

print_n_chars: .proc
                pha
                stx ptr0+0
                sty ptr0+1
                jsr prepare_for_print_1_char
                pla
                pha
                tax
                beq done


                ldy #0
loop:
                lda (ptr0),y
                jsr print_1_char
                iny
                dex
                bne loop
done:
                pla
                rts
.pend


;-------------------------------------------------------------------------

; work out dimensions of line.
;
; Entry:
; X=line length
; Y=starting Y
;
; Exit:
; X=line length	MOD screen width
; Y=ending Y
get_line_dimensions .proc
					
		lda	byte_39
		pha
		lda	byte_3A
		pha
		stx	byte_39
		sty	byte_3A
		ldy	#0

loc_8F5A:				
		lda	byte_3A		; get Y
		bne	loc_8F65	; taken	if Y not zero
		lda	byte_39		; get X
		cmp	code_area_width	; reached effective screen width?
		bcc	loc_8F74	; taken	if effective screen width not yet reached.

loc_8F65:				
		sec
		lda	byte_39		; get X
		sbc	code_area_width	; subtract effective screen width
		sta	byte_39		; save X
		bcs	loc_8F71	; taken	if no borrow
		dec	byte_3A		; borrow occurred, so decrement	Y

loc_8F71:				
		iny
		bne	loc_8F5A

loc_8F74:				
		ldx	byte_39
		pla
		sta	byte_3A
		pla
		sta	byte_39
                rts
                .pend

;-------------------------------------------------------------------------


; entry: (input_ptr) points to command line;
;
; exit: C set if error, or (input_ptr) holds result and Y is
; index of terminating char.

atoi_from_command_line:	.proc		
					
		lda	input_ptr+0
		sta	ptr0+0
		lda	input_ptr+1
                sta	ptr0+1

                ; fall through
                .pend


; entry: (unk_C) points	to text;
; exit:	C set if error,	or (input_ptr) holds value

atoi: .proc
                ldy #0
                sty input_ptr+0
                sty input_ptr+1

                ; keep going until terminator, non-digit, or too many
                ; digits.
count_digits_loop:
                lda (ptr0),y
                cmp #' '
                beq got_digits  ;taken if space
                cmp #13
                beq got_digits  ;taken if CR
                cmp #'0'
                bcc atoi_error  ;taken if not digit
                cmp #'9'+1
                bcs atoi_error  ;taken if not digit
                iny
                cpy #6
                bcc count_digits_loop
atoi_error:
                sec
                rts

got_digits:
                cpy #0
                beq atoi_error

                sty atoi_y      ;index of terminating char

                ldx #0          ;tens column counter
                dey             ;string offset

columns_loop:
                
                lda (ptr0),y  ;get digit

add_column_loop:
                cmp #'0'        
                beq column_done
                
                pha

                clc
                lda input_ptr+0
                adc tensL,x
                sta input_ptr+0
                lda input_ptr+1
                adc tensH,x
                sta input_ptr+1

                asl a
                pla
                bcs atoi_error  ;taken if >32767

                ; C is clear here. Branch with BNE is OK; the
                ; accumulator holds an ASCII value so it'll never end
                ; up zero.
                sbc #0          
                bne add_column_loop
column_done:
                inx             ;next tens column
                dey
                bpl columns_loop
atoi_done:
                ldy atoi_y
                clc
		rts
                .pend


; unk_6BD = command to run

execute_command:			
					
		lda	#<command_jump_table
		sta	byte_39
		lda	#>command_jump_table
		sta	byte_3A

loc_8FEF:				
		ldy	#0
		lda	(byte_39),y	; get control byte
		sta	command_flags		; ?unk_49 = control byte
		cmp	#$FF		; end of table?
		bne	loc_8FFA	; branch taken if not end of table

execute_command_done:					
		rts

loc_8FFA:				
		iny
		lda	(byte_39),y		; get command ID
		cmp	current_command_id ; is	it the desired command?
		beq	loc_9005	; branch taken if desired command found
		jmp	next_command
; Create thunk at unk_6B0: JMP <command routine>

loc_9005:				
		lda	#$4C		; JMP absolute
		sta	unk_6B0
		sta	byte_6A7
		iny
		lda	(byte_39),y		; get command routine ptr LSB
		sta	unk_6B1		; store	JMP target LSB
		iny
		lda	(byte_39),y		; get command routine ptr MSB
		sta	unk_6B2		; store	JMP target MSB
		lda	command_flags		; get control byte
		and	#1		; extract bit 0
		sta	byte_6AB	; ?unk_6AB = unknown byte bit 1

check_bit_1:				; get control byte
		lda	command_flags
		and	#2		; extract bit 1
		bne	check_bit_2	; branch taken if bit 1	reset
; bit 1 set
		lda	is_bad_program
		bne	execute_command_done

check_bit_2:				
		lda	command_flags		; get control byte
		and	#4		; extract bit 2
		beq	check_bit_3	; branch taken if bit 2	reset
; bit 2 set
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		cmp	#2		; edit mode?
		beq	check_bit_3	; branch taken if edit mode
; not in edit mode
		jsr	init_edit_mode
		lda	command_flags		; get control byte
		and	#$10		; extract bit 4
		beq	check_bit_6	; branch taken if bit 4	reset
; bit 4 set
		jsr	is_program_empty ; sets	C if no	program
		bcc	check_bit_6	; branch taken if program is present
		jmp	loc_9DA8

check_bit_3:				
					
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		cmp	#2		; edit mode?
		bne	check_bit_6     ;taken if command mode
		lda	command_flags         ;get control byte
		and	#8              ;test bit 3
		beq	check_bit_4     ;taken if bit 3 reset
		jsr	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		bcs	check_bit_4
		jsr	sub_A8C0

check_bit_4:				
					
		lda	command_flags
		and	#$10
		beq	check_bit_5
		jsr	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		bcc	check_bit_5
		jmp	loc_9DA8

check_bit_5:				
					
		lda	command_flags
		and	#$20 ; ' '
		beq	check_bit_6
		sta	byte_6B3
		jsr	sub_A8C0

check_bit_6:				
					
		lda	command_flags
		and	#$40
		eor	#$40
		sta	byte_6A7
		jmp	unk_6B0

next_command:				
		clc
		lda	byte_39		; ptr LSB
		adc	#4		; add 4	(size of each entry)
		sta	byte_39
		bcc	command_ptr_ok
		inc	byte_3A

command_ptr_ok:				
		jmp	loc_8FEF
; End of function execute_command




clear_error_message_buffer: .proc

		lda	#0      ;indicate no error
		sta	last_error_number
                
                ldx #error_message_buffer_size-1
                lda #0
loop:
                sta error_message_buffer,x
                dex
                bpl loop
                
                rts
                
                .pend
; End of function clear_error_message_buffer

;-------------------------------------------------------------------------

; A = error code

get_error:				
					
		pha
		lda	last_error_number		; already got an error?
		beq	copy_error	; taken	if no error yet
		pla
		rts

copy_error:				
		jsr	clear_error_message_buffer
		pla
		sta	last_error_number		; store	error code
		lda	#<error_messages_table
		sta	ptr0+0
		lda	#>error_messages_table
		sta	ptr0+1
		ldy	#0		; offset into errors table
		ldx	#0		; current error	index

find_error_loop:			
					
		lda	(ptr0),y		; next byte from table
		bpl	loc_90C5	; taken	if still looking at the	current	error
; hit a negative char, so this means it's looking at the next error, so bump the error index.
		inx

loc_90C5:				
		cpx	last_error_number		; reached the desired error?
		beq	found_error	; taken	if desired error reached
		inc	ptr0+0
		bne	find_error_loop
		inc	ptr0+1
		bne	find_error_loop

found_error:				
		ldx	#0

copy_error_loop:			
		and	#$7F		; mask out top bit (in case)
		sta	error_message_buffer,x	; store	in error message buffer
		iny			; next source byte...
		inx			; next dest byte...
		lda	(ptr0),y		; load next byte from error table
                bpl	copy_error_loop	; taken	if haven't ended up in the next error
                jsr maybe_verbose_exit_on_error
		rts
; End of function get_error

;-------------------------------------------------------------------------

ifind_command:
                lda #$80        ;case-insensitive
                bne find_or_ifind_command
find_command:
                lda #$00        ;case-sensitive
                ; fall through
find_or_ifind_command: .proc
                sta case_insensitive_search        
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	byte_50
		pha
		lda	byte_51
		pha
		ldx	input_ptr+1		; get MSB of pointer to	arg
		inx			; X=0 if it was	FF before
		bne	got_search_string ; branch taken if pointer to arg appears valid
		jsr	get_search_string ; gets search	string.
					;
					; Exit:
					; (input_ptr) points to result
					; ?input_length is length of input excluding	final CR.
					; C set	if nothing entered.
		bcs	loc_912C

got_search_string:			
		ldy	input_length
		sty	search_string_length

copy_search_string_loop:		
		dey
		lda	(input_ptr),y
		sta	search_string,y
		cpy	#0
		bne	copy_search_string_loop
		lda	#0
		sta	byte_6AF
; point (byte_2B) at OSHWM
		sta	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_910F:				
		lda	#0
		sta	byte_3B		; reset	"found anything" flag

loc_9113:				
		ldy	#1		; index	of MSB of line number
		sty	cursor_offset	; offset of cursor in detokenized buffer
		lda	(byte_2B),y	; fetch	MSB of line number
		bpl	line_valid	; branch taken if line appears valid
; reached end of program
		lda	byte_3B		; was anything found?
		beq	loc_9122	; branch taken if nothing was found
		jmp	find_mode_ui

loc_9122:				
		lda	byte_6AF
		bne	loc_912C
		lda	#8		; "String not found"
		jsr	get_error	; A = error code

loc_912C:				
					
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		lda	byte_2B
		sta	byte_6C0
		lda	byte_2C
		sta	byte_6C1
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jmp	language_entry.command_loop

line_valid:				
		jsr	detokenize_one_line
		jsr	find_text_in_detokenized_line
		bcc	loc_91A0
		ldy	byte_6AF
		bne	loc_918A
		iny
		sty	byte_6AF
		jsr	init_edit_mode
		lda	current_command_id
                cmp	#CMD_EDIT ;was this EDIT?
                bne	loc_918A  ;taken if not EDIT (i.e., FIND)
                
loc_9163:
                ; command was EDIT.
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	cls_and_reset_6c0_to_6ff
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		lda	#0
		sta	byte_3B
		clc
		jsr	sub_9DEA
		ldx	#1
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	sub_A069
		jsr	position_edit_mode_cursor
		jmp	edit_mode_loop

loc_918A:				

                ; command was FIND.
		lda	byte_3B
		bne	loc_9191
		jsr	cls_and_reset_6c0_to_6ff

loc_9191:				
		jsr	sub_9E5F
		bcc	find_mode_ui
		jsr	sub_9E82
		clc
		lda	byte_3B
		adc	byte_2D
		sta	byte_3B

loc_91A0:				
		jsr	advance_2b_to_next_line
		jmp	loc_9113

find_mode_ui:
					
		lda	#0
		sta	byte_3B ;reset Y coordinate

find_mode_loop:

                ; position cursor appropriately		
		ldx	#0
		ldy	byte_3B
		jsr	gotoxy
                jsr	find_mode_getch

		cmp	#27     ;Escape?
		bne	check_for_top_screen
		jmp	loc_912C ;leave find mode

check_for_top_screen:
		cmp	#CMD_TOP_SCREEN ;f7
                beq edit_found_line ;
                cmp #13
                bne check_for_up
edit_found_line:
		jsr	save_line_number_for_current_line
		jmp	loc_9DA8

check_for_up:
		cmp	#CMD_UP
		bne	check_for_down

                ; Move up
		lda	byte_3B ;get Y coordinate
		bne	decrement_Y_coordinate ;taken if A!=0
                ; A=0
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30

                ; search for the $0000 padding, either finding the
                ; bottom of the screen (padding not found) or the
                ; bottom of the visible lines (padding found).
		sta	byte_2B ;A=0
		sta	byte_2C ;A=0
		jsr	sub_BA69
		txa
		lsr
		sta	byte_3B
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30

decrement_Y_coordinate:
		dec	byte_3B ;decrement Y
		jmp	find_mode_loop

check_for_down:
		cmp	#CMD_DOWN
		bne	check_for_continue
		ldx	byte_3B ;Y coord
		inx             ;next Y coord
		cpx	text_window_bottom_y ;bottom of screen?
		beq	loc_91F5             ;taken if on last line
		bcc	loc_91F5             ;taken if on screen
		ldx	#0                   ;go back to Y=0
		beq	loc_91FE             ;jmp, in effect

loc_91F5:				
					
		txa                ;A=Y coord
		asl                ;A=Y coord*2
		tay                ;Y=Y coord*2
		lda	byte_6C1,y ;get MSB of address of line on that row
		bne	loc_91FE   ;taken if valid line
		tax                ;

loc_91FE:				
					
		stx	byte_3B

jmp_find_mode_loop:
		jmp	find_mode_loop

check_for_continue:
		cmp	#CMD_CONTINUE
		bne	check_for_top_key
		jmp	loc_910F

check_for_top_key:
		cmp	#CMD_TOP_KEY
		bne	check_for_end_key
		jmp	top_edit_mode_command

check_for_end_key:
		cmp	#CMD_END_KEY
		bne	check_for_goto_key
		jmp	end_edit_mode_command

check_for_goto_key:
		cmp	#CMD_GOTO_KEY
		bne	check_for_mark
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		jsr	goto_edit_mode_command
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jmp	find_mode_loop

check_for_mark:
		cmp	#CMD_MARK
		bne	jmp_find_mode_loop
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		jsr	save_line_number_for_current_line
		jsr	mark_edit_mode_command
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jmp	find_mode_loop
; End of function find_command
                .endproc


;-------------------------------------------------------------------------
;
; Find current line selected in FIND/QCHANGE mode, and call
; save_line_number on it.
;
save_line_number_for_current_line: .proc
					
		lda	byte_3B
		asl
		tax
		inx
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jmp	save_line_number ; saves line number from program.
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
                .endproc

;-------------------------------------------------------------------------

advance_2b_to_next_line:		
					
		ldy	#3		; offset of line length
		clc
		lda	(byte_2B),y		; get line length
		adc	byte_2B
		sta	byte_2B
		bcc	+
		inc	byte_2C
+
		rts

;-------------------------------------------------------------------------

normalize_search_case .proc
                bit case_insensitive_search
                bpl done
                cmp #'a'
                bcc done
                cmp #1+'z'
                bcs done
                and #$df
done:
                rts
.pend

;-------------------------------------------------------------------------
;
; Find text in detokenized line
;
; Entry:
; ?byte_400 = detokenized length
; unk_401... = detokenized text
; ?cursor_offset = location to start searching
; input_ptr = search text
; input_length = search text length
;
; Exit:
; C=0 if no match
; C=1 if match; ?cursor_offset is offest of start of match
; 
find_text_in_detokenized_line .proc			
					
		lda	cursor_offset	; offset of cursor in detokenized buffer
		cmp	byte_400
		beq	loc_926B ;taken if eol
		bcc	loc_926B ;taken if before eol

not_found:
		clc

locret_926A:				
		rts

loc_926B:				
		clc
		adc	input_length ;A=cursor_offset+input_length
		bcc	loc_9275     ;no obvious overflow
		cmp	#$26         ;
		bcs	not_found    ;taken if >=$126...????

loc_9275:

                ; set (ptr0) to cursor position in line
		lda	cursor_offset	; offset of cursor in detokenized buffer
		clc
		adc	#<byte_400
		sta	ptr0+0
                lda	#0
                tax
                tay
		adc	#>byte_400
		sta	ptr0+1

loc_9286:
                ; fetch program char
                lda (ptr0,x)
                jsr normalize_search_case
                sta search_tmp

                ; fetch search text char
                lda (input_ptr),y
                jsr normalize_search_case

                ; 
                cmp search_tmp
                bne	loc_929A ;taken if no match
next_byte:
		iny
		inc	ptr0+0
		bne	loc_9293
		inc	ptr0+1

loc_9293:				
		cpy	input_length ;at end?
		bcs	locret_926A  ;taken if match - return with C=1
		bcc	loc_9286     ;els, keep looping

loc_929A:
                ; move to next char and keep searching.
		inc	cursor_offset	; offset of cursor in detokenized buffer
                bne	find_text_in_detokenized_line
.pend

;-------------------------------------------------------------------------

qichange_or_ichange_command:
                lda #$80        ;case-insensitive
                bne change_or_qchange_or_ichange_or_qichange_command
                
change_or_qchange_command:
                lda #$00        ;case-sensitive
                ; fall through
change_or_qchange_or_ichange_or_qichange_command .block
                sta case_insensitive_search
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	byte_50
		pha
		lda	byte_51
		pha
		ldx	input_ptr+1
		inx
		beq	loc_9308
		ldy	#0

                ; Find end of search text
find_end_of_search_text_loop:
		lda	(input_ptr),y
		cmp	#$20
		beq	found_end_of_search_text
		cmp	#$D
		beq	raise_replace_string_missing_error
		iny
		bne	find_end_of_search_text_loop

raise_replace_string_missing_error:
		lda	#23     ;Replace string missing

jmp_raise_error:
		jmp	raise_error

found_end_of_search_text:
		sty	input_length ;truncate command line at end of search text

find_start_of_replace_text_loop:
		lda	(input_ptr),y
		cmp	#$D
		beq	raise_replace_string_missing_error
		cmp	#$20 ; ' '
		bne	found_start_of_replace_text
		iny
		bne	find_start_of_replace_text_loop

found_start_of_replace_text:
		clc
		tya
		adc	input_ptr+0
		sta	replace_text_ptr+0
		lda	input_ptr+1
		adc	#0
		sta	replace_text_ptr+1
		ldx	#0

find_end_of_replace_text_loop:
		lda	(input_ptr),y
		cmp	#$20 ; ' '
		beq	check_end_of_command_line_loop
		cmp	#$D
		beq	found_end_of_replace_text
		inx
		iny
		bne	find_end_of_replace_text_loop

check_end_of_command_line_loop:
		lda	(input_ptr),y
		cmp	#$D
		beq	found_end_of_replace_text
		cmp	#$20 ; ' '
		bne	raise_only_two_strings_allowed_error
		iny
		bne	check_end_of_command_line_loop

raise_only_two_strings_allowed_error:
		lda	#24     ;Only two strings allowed
		bne	jmp_raise_error

found_end_of_replace_text:
		stx	replace_text_length
		jmp	loc_932C

loc_9308:				
		jsr	get_search_string ; gets search	string.
					;
					; Exit:
					; (input_ptr) points to result
					; ?input_length is length of input excluding final CR.
					; C set	if nothing entered.
		bcs	loc_9312
		jsr	get_replace_string
		bcc	loc_932C

loc_9312:				
					
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		lda	byte_2B
		sta	byte_6C0
		lda	byte_2C
		sta	byte_6C1
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		rts

loc_932C:				
		lda	#0
		sta	byte_6AF
		sta	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_9337:				
		ldy	#0
		sty	byte_6B3
		sty	cursor_offset_msb
		iny
		sty	cursor_offset	; offset of cursor in detokenized buffer
		lda	(byte_2B),y
		bmi	loc_9369
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line

loc_934B:				
					
		jsr	find_text_in_detokenized_line
		bcs	loc_9359 ;taken if found
		jsr	sub_93CF
		jsr	advance_2b_to_next_line
		jmp	loc_9337

loc_9359:				
		lda	current_command_id
		sta	byte_6AF
		cmp	#CMD_QCHANGE
		beq	loc_937E ;taken if command was QCHANGE
                cmp #CMD_QICHANGE
                beq loc_937e    ;taken if command was QICHANGE
		jsr	sub_BDD3
		jmp	loc_934B

loc_9369:				
		lda	byte_6AF
		bne	loc_9312
		pla
		pla
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		lda	#8        ;"String not found"
		jsr	get_error	; A = error code

loc_937B:				
		jmp	language_entry.command_loop
                
loc_937E:				
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		cmp	#2
		beq	loc_9388 ;taken if edit mode already
		jsr	init_edit_mode ;switch to edit mode

loc_9388:				
		jsr	cls_and_reset_6c0_to_6ff
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		lda	#0
		sta	byte_3B
		clc
		jsr	sub_9DEA
		ldx	#1
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	sub_A069
		jsr	position_edit_mode_cursor

loc_93A9:				
		jsr	find_mode_getch
		cmp	#27
		beq	loc_937B
		cmp	#$A7
		bne	loc_93B7
		jmp	edit_mode_loop

loc_93B7:				
		and	#$DF
		cmp	#'Y'
		bne	loc_93C6
		jsr	sub_BDD3
		jsr	sub_93CF
		jmp	loc_934B

loc_93C6:				
		cmp	#'N'
		bne	loc_93A9
		inc	cursor_offset	; offset of cursor in detokenized buffer
		jmp	loc_934B
; End of function find_text_in_detokenized_line



;-------------------------------------------------------------------------

sub_93CF:				
					
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		jsr	sub_A8C0
		pla
		sta	byte_2C
		pla
		sta	byte_2B
                rts
.bend
; End of function sub_93CF

;-------------------------------------------------------------------------



load_command .proc				
		lda	#$FF
		jsr	do_osfile_from_oshwm
		jsr	clear_line_commands
                jsr	sub_B358
                jmp sub_8314
.pend
                
append_command .proc
		jsr	is_program_empty ; sets	C if no	program
		bcs	load_command
		jsr	loc_946F
		lda	#$FF
		jsr	do_osfile
		jsr	find_program
		bcc	locret_9424
		jsr	loc_946F
		stx	ptr0+0
		sty	ptr0+1
		ldy	#0
		lda	#$D
		sta	(ptr0),y
		iny
		lda	#$FF
		sta	(ptr0),y

locret_9424:				
                rts
.pend

save_command
		lda	TOP
		sta	basic_ptr_1+0		; save end address LSB
		lda	TOP+1
		sta	basic_ptr_1+1		; save end address MSB
		lda	#0		; OSFILE save memory block

do_osfile_from_oshwm:				
		ldx	oshwm
		ldy	oshwm+1
                jmp	do_osfile

do_osfile .proc
		pha			; save OSFILE code
		lda	input_ptr+0
		sta	readline_ptr_lsb ; filename ptr	LSB
		lda	input_ptr+1
		sta	readline_ptr_msb ; filename ptr	MSB
		stx	unk_1B		; load address LSB
		stx	unk_1F		; exec address LSB
		stx	byte_23		; save start address LSB
		sty	unk_1C		; load address MSB
		sty	byte_20		; exec address MSB
		sty	byte_24		; save start address MSB
		lda	higher_order_address
		sta	unk_1D		; load address bits 16...23
		sta	byte_21		; exec address bits 16...23
		sta	basic_ptr_0+0		; save start address bits 16...23
		sta	unk_29		; save end address bits	16...23
		lda	higher_order_address+1
		sta	unk_1E		; load address bits 24...31
		sta	byte_22		; exec address bits 24...31
		sta	basic_ptr_0+1		; save start address bits 24...31
		sta	unk_2A		; save end address bits	24...31
		pla			; get OSFILE code
		tax			; OSFILE code in X
		inx			; 1 if load, 0 if save
		bne call_osfile	; branch if not	save
		stx	unk_1F		; when loading - use load address provided, not	file's default

call_osfile				
		ldx	#<readline_ptr_lsb
		ldy	#>readline_ptr_lsb
                jmp	OSFILE		; OSFILE
.pend
; End of function save_command


loc_946F .proc
		ldy	TOP+1
		sec
		lda	TOP
		sbc	#2
		tax
		bcs	locret_947A
		dey

locret_947A:				
                rts
.pend

; entry: (byte_19) points to buffer
;
; exit:	C=0 if Return, C=1 if Escape
; A is line length+1

read_line .proc
					
		sta	unk_1B		; maximum line length
		lda	#$20
		sta	unk_1C		; min acceptable char
		lda	#$FF
		sta	unk_1D		; max acceptable char
		lda	#0		; read input line
		ldx	#$19
		ldy	#0
		jsr	OSWORD
		php
		iny
		tya
		pha
		bcc	loc_9497
		jsr	OSNEWL

loc_9497:				
		jsr	clear_escape_condition
		pla
		plp
                rts
.pend
; End of function read_line



; read <100 chars to $700; points (input_ptr) at result, sets input_length to	length.

read_line_700:				
		lda	#<unk_700
		sta	readline_ptr_lsb
		sta	input_ptr+0
		lda	#>unk_700
		sta	readline_ptr_msb
		sta	input_ptr+1
		lda	#max_command_line_length
		jsr	read_line
		sta	input_length
		rts
; End of function read_line_700




read_line_780:				
		lda	#<unk_780
		sta	readline_ptr_lsb
		sta	replace_text_ptr+0
		lda	#>unk_780
		sta	readline_ptr_msb
		sta	replace_text_ptr+1
		lda	#max_command_line_length
		jsr	read_line
		sta	replace_text_length
		rts
; End of function read_line_780



; gets search string.
;
; Exit:
; (input_ptr) points to result
; ?input_length is length of input excluding final CR.
; C set	if nothing entered.

get_search_string:			

                jsr print_next_string
                .text "  Search string  : ",255
		jsr	read_line_700	; read <100 chars to $700; points (input_ptr) at result, sets input_length to	length.
		bcs	locret_94DD
		dec	input_length	; ignore 13
		bne	locret_94DD
		sec			; set carry if empty

locret_94DD:				
					
		rts
; End of function get_search_string




get_replace_string:
                jsr print_next_string
                .text "  Replace string : ",255
		jsr	read_line_780
		dec	replace_text_length		; ignore 13
		rts
; End of function get_replace_string




reset_keys_settings:			
					
		ldx	#0		; Enable cursor	editing	(default)
		lda	#4		; Enable/disable cursor	editing	(AUG P120)
		jsr	OSBYTE
		ldx	#9
		lda	#219		; set TAB key to 9
		jsr	osbyte_with_y0
		jsr	kbflush
		ldx	#1
		lda	#225		; reset	F key status?
		jsr	osbyte_with_y0
.if !ELECTRON
		ldx	#128
		lda	#226		; reset	Shift+F	key status?
		jsr	osbyte_with_y0
		lda	#227
		jmp	osbyte_with_x0_y0
.else
		ldx #1
		lda #226		; reset FUNC+A-P
		jsr osbyte_with_y0
		ldx #1
		lda #227		; reset FUNC+Q-Z+punctuation
		jmp osbyte_with_y0
.endif
; End of function reset_keys_settings




run_star_command:			
		ldx	#7
		jsr	get_HIMEM_for_mode_X
		jsr	reset_keys_settings
		ldx	#<unk_700
		ldy	#>unk_700
		jsr	OSCLI
		jmp	clear_error_message_buffer
; End of function run_star_command




getch:					
					
		jsr	OSRDCH
; End of function getch




clear_escape_condition:			
		pha
		lda	#$7E ; '~'
		jsr	OSBYTE
		pla
; End of function clear_escape_condition

		rts

;-------------------------------------------------------------------------

escape_key_command: .proc
                jsr poll_shift
                bne language_entry.command_loop
                jmp do_command_line.bye
                .pend
                
;-------------------------------------------------------------------------
;
; command flag masks: (a work in progress...)
;
; $04 - enter edit mode
; $08 - if in edit mode, tokenize line before executing
; $10 - program must be non-empty - do a NEW first if $04 set
; 

command_jump: .macro flags,id,addr
                .byte \flags
                .byte \id
                .word \addr
                .endm
                
command_jump_table:
                .command_jump $20,CMD_return_key,return_key_command
                .command_jump $24,CMD_IE,ie_cmd
                .command_jump $24,CMD_IT,it_cmd
                .command_jump 8,$1B,escape_key_command
                .command_jump 0,CMD_TOGGLE_INS_OVER,toggle_insert_overtype_command
                .command_jump $19,CMD_TOP_KEY,top_edit_mode_command
                .command_jump $19,CMD_END_KEY,end_edit_mode_command
                .command_jump $19,CMD_RENUMBER_KEY,renumber_edit_mode_command
                .command_jump $A,CMD_EXIT,run_or_exit_command
                .command_jump 2,CMD_NEW,new_command
                .command_jump 1,CMD_OLD,old_command
                .command_jump 0,CMD_UNDO,undo_edit_mode_command
                .command_jump 0,CMD_EXTEND_STMNT,extend_statement_edit_mode_command
                .command_jump 0,CMD_SWAP_CASE,swap_case_edit_mode_command
                .command_jump $19,CMD_TOP_SCREEN,top_of_screen_edit_mode_command
                .command_jump 0,CMD_EXECUTE,execute_edit_mode_command
                .command_jump 0,CMD_BACK_KEY,background_edit_mode_command
                .command_jump 0,CMD_FORE_KEY,foreground_edit_mode_command
                .command_jump 0,CMD_DELETE_EOL,delete_to_end_of_line_edit_mode_command
                .command_jump 1,CMD_delete_key,delete_key_command
                .command_jump 1,CMD_shift_delete_key,loc_AAC8
                .command_jump 1,CMD_DELETE_FWDS,loc_AAC8
                .command_jump 0,CMD_LEFT,cursor_left_edit_mode_command
                .command_jump 0,CMD_RIGHT,cursor_right_edit_mode_command
                .command_jump 0,CMD_DOWN,cursor_down_edit_mode_command
                .command_jump 0,CMD_UP,cursor_up_edit_mode_command
                .command_jump 0,CMD_LINE_START,shift_cursor_left_edit_mode_command
                .command_jump 0,CMD_LINE_END,shift_cursor_right_edit_mode_command
                .command_jump $18,CMD_SCREEN_DOWN,shift_cursor_down_edit_mode_command
                .command_jump $18,CMD_SCREEN_UP,shift_cursor_up_edit_mode_command
                .command_jump 0,CMD_PREV_STMNT,move_to_prev_stmt_edit_mode_command
                .command_jump 0,CMD_NEXT_STMNT,move_to_next_stmt_edit_mode_command
                .if ORIGINAL_CTRL_UP_DOWN
                .command_jump $10,CMD_SCREEN_BOTTOM,move_to_bottom_of_screen_edit_mode_command
                .command_jump $10,CMD_SCREEN_TOP,move_to_top_of_screen_edit_mode_command
                .else
                .command_jump $10,CMD_LINE_NEXT,move_to_next_line_edit_mode_command
                .command_jump $10,CMD_LINE_PREV,move_to_prev_line_edit_mode_command
                .endif
                .command_jump 2,CMD_LOAD,load_command
                .command_jump 0,CMD_APPEND,append_command
                .command_jump 0,CMD_SAVE,save_command
                .command_jump 0,CMD_FIND,find_command
                .command_jump $40,CMD_CHANGE,change_or_qchange_command
                .command_jump $40,CMD_QCHANGE,change_or_qchange_command
                .command_jump 2,CMD_star,run_star_command
                .command_jump 0,3,set_primary_line_command
                .command_jump 0,4,set_primary_line_command
                .command_jump 0,$D,set_primary_line_command
                .command_jump 1,1,loc_A245
                .command_jump 1,2,loc_A245
                .command_jump 1,5,loc_A245
                .command_jump 1,$14,loc_A245
                .command_jump 1,$12,loc_A258
                .command_jump 0,$63,loc_AD39
                .command_jump 0,$64,loc_AEB9
                .command_jump 0,$6D,loc_AD39
                .command_jump 0,CMD_DELETE_FWDS,copy_key_edit_mode_command
                .command_jump 0,CMD_tab_key,tab_key_command
                .command_jump 0,CMD_RUN,run_or_exit_command
                .command_jump 0,CMD_MODE,mode_command
                .command_jump 0,CMD_MARK,mark_edit_mode_command
                .command_jump $1D,CMD_GOTO_KEY,goto_edit_mode_command
                .command_jump $40,CMD_NUMBER,number_command
                .command_jump $40,CMD_LABEL,label_command
                .command_jump 0,CMD_SPLIT_STMNT,split_statement_edit_mode_command
                .command_jump 1,CMD_JOIN_STMNT,join_statements_edit_mode_command
                .command_jump $21,CMD_REPEAT,repeat_edit_mode_command
                .command_jump 0,CMD_SCROLL,scroll_command
                .command_jump 0,CMD_NOSCROLL,noscroll_command
                .command_jump 2,CMD_HELP,help_command
                .command_jump 0,CMD_FORE,fore_command
                .command_jump 0,CMD_BACK,back_command
                .command_jump 0,CMD_INSERT,insert_command
                .command_jump 0,CMD_OVERTYPE,overtype_command
                .command_jump 2,CMD_INFO,info_command
                .command_jump $49,CMD_LABEL_KEY,label_edit_mode_command
                .command_jump $49,CMD_NUMBER_KEY,number_edit_mode_command
                .command_jump $14,CMD_goto_line,goto_line_command
                .command_jump 0,CMD_RENUMBER,renumber_command
                .command_jump 0,CMD_TAB,tab_command
                .command_jump 0,CMD_GOTO,goto_command
                .command_jump 8,CMD_CONTINUE,continue_edit_mode_command
                .command_jump 0,CMD_EDIT,find_command
                .command_jump $14,CMD_TOP,top_command
                .command_jump $14,CMD_END,end_command
                .command_jump 0,CMD_shift_tab_key,loc_9783
                .command_jump 8,CMD_ZSAVE,zsave_command
                .command_jump 0,CMD_IFIND,ifind_command
                .command_jump 0,CMD_ICHANGE,qichange_or_ichange_command
                .command_jump 0,CMD_QICHANGE,qichange_or_ichange_command
                .command_jump 8,CMD_ZRUN,zrun_command
                .if ENABLE_DEBUG
                .command_jump 8,CMD_MODE_KEY,print_debug_stuff_edit_mode_command
                .endif
		.byte $FF

;-------------------------------------------------------------------------

loc_967A:				
		jsr	sub_9698
		bcs	loc_9695
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		jsr	sub_9706
		sec
		jsr	sub_9DEA
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jmp	sub_9FD8

loc_9695:				
		jmp	loc_9DA8



sub_9698:				
		lda	byte_6C0
		sta	basic_ptr_1+0
		lda	byte_6C1
		sta	basic_ptr_1+1
		cmp	#-1
		beq	loc_96BB
		ldy	#1
		lda	current_line_no_msb
		cmp	(basic_ptr_1),y
		bcs	loc_96B0

loc_96AE:				
		sec
		rts

loc_96B0:				
		bne	loc_96BD
		iny
		lda	current_line_no_lsb
		cmp	(basic_ptr_1),y
		bcc	loc_96AE
		bne	loc_96BD

loc_96BB:				
		clc
		rts

loc_96BD:				
		ldx	#$3F ; '?'

loc_96BF:				
		lda	byte_6C0,x
		sta	unk_700,x
		dex
		bpl	loc_96BF
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	#0
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		jsr	sub_9706
		sec
		jsr	sub_9DEA
		lda	#2
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	sub_BA69
		txa
		lsr
		cmp	text_window_bottom_y
		beq	loc_96F7
		bcs	loc_96F8

loc_96F7:				
		clc

loc_96F8:				
		php
		ldx	#$3F ; '?'

loc_96FB:				
		lda	unk_700,x
		sta	byte_6C0,x
		dex
		bpl	loc_96FB
		plp
		rts
; End of function sub_9698




sub_9706:				
		lda	#0
		sta	byte_3B
		ldx	#1
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		rts
; End of function sub_9706


tab_key_command:			
		lda	tab_value
		sta	unk_6AA

loc_9720:				
		jsr	make_cursor_invisible
		lda	byte_39
		pha
		ldx	unk_6AA
		beq	loc_976D
		inx
		stx	byte_39
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		ldy	cursor_offset_msb
		jsr	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		txa
		bne	loc_973C
		lda	code_area_width
		tax

loc_973C:				
		cmp	byte_39
		bcc	loc_9745
		sbc	unk_6AA
		bne	loc_973C

loc_9745:				
		sta	byte_3A
		sec
		lda	byte_39
		sbc	byte_3A
		tay
		stx	byte_3A
		clc
		adc	byte_3A
		cmp	code_area_width
		beq	loc_9762
		bcc	loc_9762
		lda	code_area_width
		sbc	byte_3A
		clc
		adc	#1
		tay

loc_9762:				
		sty	unk_6AA

loc_9765:				
		jsr	cursor_right_edit_mode_command
		dec	unk_6AA
		bne	loc_9765

loc_976D:				
		pla
		sta	byte_39
		rts

tab_command:				
		lda	input_ptr+1
		beq	loc_977A

loc_9775:				
		lda	#$21 ; '!'
		jmp	raise_error

loc_977A:				
		lda	input_ptr+0
		cmp	#$51 ; 'Q'
		bcs	loc_9775
		sta	tab_value
		rts

loc_9783:				
		lda	#$50 ; 'P'
		sta	unk_6AA
		jmp	loc_9720

continue_edit_mode_command:		
		lda	search_string_length
		bne	loc_9794
		lda	#$23 ; '#'

loc_9791:				
		jmp	raise_error

loc_9794:				
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_979D

loc_9799:				
		lda	#8
		bne	loc_9791

loc_979D:				
		lda	#<search_string
		sta	input_ptr+0
		lda	#>search_string
		sta	input_ptr+1
		lda	search_string_length
		sta	input_length
		inc	cursor_offset	; offset of cursor in detokenized buffer
		bne	loc_97B0
		inc	cursor_offset_msb

loc_97B0:				
		lda	cursor_offset_msb
		beq	loc_97C4
		bne	loc_97F0

loc_97B6:				
		ldy	#0
		sty	cursor_offset_msb
		iny
		sty	cursor_offset	; offset of cursor in detokenized buffer
		lda	(byte_2B),y
		bmi	loc_9799
		jsr	detokenize_one_line

loc_97C4:				
		jsr	find_text_in_detokenized_line
		bcc	loc_97F0
		lda	byte_2B
		cmp	byte_6C0
		bne	loc_97ED
		lda	byte_2C
		cmp	byte_6C1
		bne	loc_97ED
		lda	byte_6B3
		beq	loc_97EA
		jsr	sub_AA17
		ldx	#1
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	sub_A069

loc_97EA:				
		jmp	position_edit_mode_cursor

loc_97ED:				
		jmp	find_or_ifind_command.loc_9163

loc_97F0:				
		jsr	advance_2b_to_next_line
		jmp	loc_97B6

split_statement_edit_mode_command:	
		jsr	rstrip_detokenized_line
		cpy	#0
		beq	loc_9801
		lda	cursor_offset_msb
		beq	loc_9804

loc_9801:				
		jmp	beep

loc_9804:				
		lda	cursor_offset	; offset of cursor in detokenized buffer
		cmp	#1
		beq	loc_9801
		cmp	byte_400
		beq	loc_9811
		bcs	loc_9801

loc_9811:				
		ldy	#0

loc_9813:				
		lda	byte_400,y
		sta	unk_700,y
		dey
		bne	loc_9813
		jsr	sub_A8C0
		ldy	#0

loc_9821:				
		lda	unk_700,y
		sta	byte_400,y
		dey
		bne	loc_9821
		jsr	sub_9968
		pha
		cmp	#0
		bne	loc_9835
		jmp	loc_98DB

loc_9835:				
		lda	byte_400
		cmp	#-5 ; '�'
		bne	loc_9840

loc_983C:				
		pla
		jmp	renumber_edit_mode_command

loc_9840:				
		ldy	byte_400

loc_9843:				
		lda	unk_401-1,y
		cmp	#7
		beq	loc_983C
		dey
		bne	loc_9843
		ldy	byte_400

loc_9850:				
		lda	unk_401-1,y
		sta	unk_401,y
		cpy	cursor_offset	; offset of cursor in detokenized buffer
		beq	loc_985D
		dey
		bne	loc_9850

loc_985D:				
		lda	#7
		sta	unk_401-1,y
		inc	byte_400
		lda	#1
		sta	byte_6B3
		lda	#0
		sta	byte_6A7
		jsr	sub_A8C0
		inc	byte_6A7
		lda	#-1
		sta	unk_6AD
		jsr	sub_8492
		lda	unk_6AD
		cmp	#-1
		beq	loc_9892
		jsr	sub_999A

loc_9887:				
		lda	unk_6AD
		ldx	#0
		stx	unk_6AD
		jmp	raise_error

loc_9892:				
		jsr	detokenize_one_line
		lda	unk_6AD
		cmp	#-1
		beq	loc_98B5
		jsr	sub_999A
		lda	#-1
		sta	unk_6AD
		jsr	detokenize_one_line
		lda	unk_6AD
		cmp	#-1
		bne	loc_9887
		inc	unk_6AD
		pla
		jmp	loc_967A

loc_98B5:				
		inc	unk_6AD
		ldy	byte_400

loc_98BB:				
		lda	unk_401-1,y
		cmp	#7
		beq	loc_98C5
		dey
		bne	loc_98BB

loc_98C5:				
		sty	cursor_offset	; offset of cursor in detokenized buffer

loc_98C7:				
		lda	unk_401,y
		sta	unk_401-1,y
		iny
		cpy	byte_400
		bne	loc_98C7
		lda	#' '
		sta	unk_401-1,y
		dec	byte_400

loc_98DB:				
		pla
		sta	byte_36
		clc
		lda	#<byte_400
		adc	cursor_offset	; offset of cursor in detokenized buffer
		sta	ptr0+0
		lda	#>byte_400
		adc	#0
		sta	ptr0+1
		lda	#<unk_700+1
		sta	ptr1+0
		lda	#>unk_700+1
		sta	ptr1+1
		sec
		lda	byte_400
		sbc	cursor_offset	; offset of cursor in detokenized buffer
		tay
		iny
		sty	unk_700
		ldx	#0
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		dex
		stx	byte_400
		lda	#1
		sta	byte_6B3
		jsr	sub_A8C0
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		stx	byte_35
		lda	#<unk_700
		sta	ptr0+0
		lda	#>unk_700
		sta	ptr0+1
		lda	#<byte_400
		sta	ptr1+0
		lda	#>byte_400
		sta	ptr1+1
		ldy	unk_700 ;Y=line length
		iny             ;+1 to include count byte
		ldx	#0
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_992F:				
		ldx	current_line_no_msb
		ldy	current_line_no_lsb
		inc	current_line_no_lsb
		bne	loc_9939
		inc	current_line_no_msb

loc_9939:				
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		txa
		pha
		tya
		pha
		lda	byte_36
		pha
		ldx	byte_35
		jmp	loc_AFBB



repeat_edit_mode_command:		
		jsr	sub_995B
		sta	byte_36
		jsr	detokenize_one_line
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		stx	byte_35
		jmp	loc_992F
; End of function repeat_edit_mode_command




sub_995B:				
		jsr	sub_9968
		pha
		cmp	#0
		beq	loc_9966
		jsr	sub_8492

loc_9966:				
		pla
		rts
; End of function sub_995B




sub_9968:				
		jsr	is_program_empty ; sets	C if no	program
		bcs	loc_9997
		ldy	#3
		clc
		lda	(byte_2B),y
		adc	byte_2B
		sta	ptr0+0
		lda	byte_2C
		adc	#0
		sta	ptr0+1
		ldx	current_line_no_msb
		ldy	current_line_no_lsb
		iny
		bne	loc_9986
		inx
		bmi	loc_9993

loc_9986:				
		tya
		ldy	#2
		cmp	(ptr0),y
		bne	loc_9997
		dey
		txa
		cmp	(ptr0),y
		bne	loc_9997

loc_9993:				
		lda	#1
		bne	locret_9999

loc_9997:				
		lda	#0

locret_9999:				
		rts
; End of function sub_9968




sub_999A:				
		jsr	find_program
		ldy	#4

loc_999F:				
		lda	(byte_2B),y
		cmp	#7
		beq	loc_99A8
		iny
		bne	loc_999F

loc_99A8:				
		tya
		clc
		adc	byte_2B
		sta	ptr0+0
		sta	ptr1+0
		lda	byte_2C
		adc	#0
		sta	ptr0+1
		sta	ptr1+1
		inc	ptr0+0
		bne	loc_99BE
		inc	ptr0+1

loc_99BE:				
		sec
		lda	TOP
		sbc	ptr0+0
		tay
		lda	TOP+1
		sbc	ptr0+1
		tax
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		ldy	#3
		lda	(byte_2B),y
		sec
		sbc	#1
		sta	(byte_2B),y
		rts
; End of function sub_999A


renumber_command:			
		lda	#$A
		sta	unk_6B9
		tax
		lda	#0
		sta	unk_6B8
		lda	input_ptr+1
		bpl	loc_99E8
		jmp	loc_9A8B

loc_99E8:				
		ldy	#1

loc_99EA:				
		lda	(input_ptr),y
		cmp	#$D
		beq	loc_99FD
		cmp	#$2C ; ','
		bne	loc_99FA
		lda	#$20 ; ' '
		sta	(input_ptr),y
		bne	loc_99FD

loc_99FA:				
		iny
		bne	loc_99EA

loc_99FD:				
		lda	input_ptr+0
		pha
		lda	input_ptr+1
		pha
		jsr	atoi_from_command_line ; entry:	(input_ptr) points to command line;
					; exit:	C set if error,	or (input_ptr+0, input_ptr+1) holds result.
		bcc	loc_9A0D
		lda	#$B
		jmp	raise_error

loc_9A0D:				
		lda	input_ptr+1
		sta	unk_6B8
		lda	input_ptr+0
		sta	unk_6B9
		pla
		sta	input_ptr+1
		pla
		sta	input_ptr+0
		ldy	#0

loc_9A1F:				
		lda	(input_ptr),y
		cmp	#$D
		beq	loc_9A39
		cmp	#$20 ; ' '
		beq	loc_9A2C
		iny
		bne	loc_9A1F

loc_9A2C:				
		lda	(input_ptr),y
		cmp	#$D
		beq	loc_9A39
		cmp	#$20 ; ' '
		bne	loc_9A3E
		iny
		bne	loc_9A2C

loc_9A39:				
		ldx	#$A
		jmp	loc_9A99

loc_9A3E:				
		clc
		tya
		adc	input_ptr+0
		sta	input_ptr+0
		pha
		bcc	loc_9A49
		inc	input_ptr+1

loc_9A49:				
		lda	input_ptr+1
		pha
		jsr	atoi_from_command_line ; entry:	(input_ptr) points to command line;
					; exit:	C set if error,	or (input_ptr+0, input_ptr+1) holds result.
		bcc	loc_9A56
		lda	#$B
		jmp	raise_error

loc_9A56:				
		lda	input_ptr+1
		beq	loc_9A5F

loc_9A5A:				
		lda	#$26 ; '&'
		jmp	raise_error

loc_9A5F:				
		lda	input_ptr+0
		beq	loc_9A5A
		tax
		pla
		sta	input_ptr+1
		pla
		sta	input_ptr+0
		ldy	#0

loc_9A6C:				
		lda	(input_ptr),y
		cmp	#$D
		beq	loc_9A99
		cmp	#$20 ; ' '
		beq	loc_9A79
		iny
		bne	loc_9A6C

loc_9A79:				
		lda	(input_ptr),y
		cmp	#$D
		beq	loc_9A99
		cmp	#$20 ; ' '
		bne	loc_9A86
		iny
		bne	loc_9A79

loc_9A86:				
		lda	#$C
		jmp	raise_error

loc_9A8B:				
		jsr	is_program_empty ; sets	C if no	program
		bcs	locret_9AD7
		jsr	sub_9AAD
		lda	byte_39
		bpl	loc_9AAA
		ldx	#3

loc_9A99:				
		jsr	is_program_empty ; sets	C if no	program
		bcs	locret_9AD7
		jsr	sub_9AAD
		lda	byte_39
		bpl	loc_9AAA
		lda	#$19
		jmp	raise_error

loc_9AAA:				
		jmp	loc_84A7



sub_9AAD:				
		lda	unk_6B8
		sta	byte_39
		lda	unk_6B9
		sta	byte_3A
		lda	oshwm
		sta	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_9ABF:				
		jsr	advance_2b_to_next_line
		ldy	#1
		lda	(byte_2B),y
		bmi	locret_9AD7
		clc
		txa
		adc	byte_3A
		sta	byte_3A
		bcc	loc_9AD4
		inc	byte_39
		bmi	locret_9AD7

loc_9AD4:				
		jmp	loc_9ABF

locret_9AD7:				
		rts
; End of function sub_9AAD




edit_mode_loop:				
					
		ldx	#$FF
		txs
		stx	byte_6A7
		lda	byte_6AB
		beq	loc_9AE6
		jsr	kbflush

loc_9AE6:				
		ldx	#0
		ldy	#$FF
		lda	#216		; read length of soft key string
		jsr	OSBYTE		; flush	pending	soft key expansion
		stx	byte_3A		; save old value (??)
		jsr	reset_cursor_shape
		jsr	getch

check_return_key:			; return?
		cmp	#13
		bne	check_tab_key
		lda	#CMD_return_key
		bne	run_command

check_tab_key:				
		cmp	#9
		bne	check_delete_key
		lda	#CMD_tab_key
		bne	run_command

check_delete_key:			
		cmp	#$7F ; ''
		bne run_command
                lda	#CMD_delete_key

; check_copy_key:
;                 cmp #$ab
;                 bne run_command
;                 lda #CMD_shift_delete_key
                
run_command:				
					
		sta	current_command_id
		ldx	#0
		ldy	#$FF
		lda	#216
		jsr	OSBYTE
		txa
		ora	byte_3A		; check	if both	soft key expansion states were 0
		beq	loc_9B2C	; branch taken if both were
		lda	current_command_id
		cmp	#$20 ; ' '
		bcc	loc_9B28

loc_9B25:				
					
		jmp	dispatch_command

loc_9B28:				
		lda	#$20 ; ' '
		bne	set_command	; JMP, in effect

loc_9B2C:				
		ldx	#$FF		; query	keyboard buffer
		ldy	#$FF
		lda	#128
		jsr	OSBYTE		; get ADVAL/buffer status (AUG p151)
		txa
		bne	loc_9B25	; branch taken if any keys in keyboard buffer
		lda	current_command_id
		cmp	#CMD_return_key
		bne	loc_9B4E
		ldx	#$9A
		jsr	poll_key	; poll state of	key.
					;
					; Entry:
					; X = -ve INKEY	value
					;
					; Exit:
					; X = 0	and Z set if key pressed
		bne	loc_9B25
		lda	#$D

set_command:				
					
		sta	current_command_id
		jmp	dispatch_command

loc_9B4E:				
		cmp	#CMD_tab_key
		bne	loc_9B5D
		ldx	#$DA		; I key
		jsr	poll_key	; poll state of	key.
					;
					; Entry:
					; X = -ve INKEY	value
					;
					; Exit:
					; X = 0	and Z set if key pressed
		bne	loc_9B5D	; branch taken if I not	pressed
		lda	#9		; set command 9	(think this is some kind of fudge to stop Ctrl+I doing anything)
		bne	set_command

loc_9B5D:				
					
		ldx	#0		; Don't change anything
		ldy	#$FF		; Read old value
		lda	#202
		jsr	OSBYTE		; Read keyboard	status byte (AUG p207)
		stx	byte_38		; bit 3	- 1 if SHIFT pressed
					; bit 4	- 0 if CAPS LOCK engaged
					; bit 5	- 0 if SHIFT LOCK engaged
					; bit 6	- 1 if CTRL pressed
					; bit 7	- 1 if SHIFT is	to reverse CAPS	LOCK/SHIFT LOCK	status

check_shift_delete_key:
		lda	current_command_id
		cmp	#CMD_delete_key
		bne	check_shift_tab_key
		lda	#8
		bit	byte_38		; Check	SHIFT state
		beq	dispatch_command ; Branch taken	if SHIFT not pressed
		lda	#CMD_shift_delete_key
		sta	current_command_id
		bne	dispatch_command ; JMP,	in effect

check_shift_tab_key:			
		cmp	#CMD_tab_key
		bne	dispatch_command
		lda	#8
		bit	byte_38		; Check	SHIFT state
		beq	dispatch_command ; Branch taken	if SHIFT not pressed
		lda	#CMD_shift_tab_key
		sta	current_command_id

dispatch_command:			
					
		lda	current_command_id
		cmp	#$20 ; ' '
		bcc	execute_non_key_command
		cmp	#$A0
		bcs	execute_non_key_command
		jsr	execute_key_command ; treats command ID	as ASCII char and puts that char into the current line as appropriate.
		jmp	edit_mode_loop

execute_non_key_command:		
					
		jsr	execute_command	; unk_6BD = command to run
		jmp	edit_mode_loop
; End of function edit_mode_loop

;-------------------------------------------------------------------------
;
; poll SHIFT state.
;
; *this routine is also used by the service code*
;
; Exit:
; X = 0	and Z set if SHIFT pressed
poll_shift:
                ldx #$ff        ;must be position-independent
                ; fall through
                
;-------------------------------------------------------------------------
;
; poll state of	key.
;
; *this routine is also used by the service code*
; 
; Entry:
; X = -ve INKEY	value
;
; Exit:
; X = 0	and Z set if key pressed

poll_key:                       ;must be position-independent
		ldy	#$FF    ;must be position-independent
		lda	#129    ;must be position-independent
		jsr	OSBYTE  ;must be position-independent
		inx             ;must be position-independent
		rts             ;must be position-independent

;-------------------------------------------------------------------------

print_xy000000: .proc
                txa
                jsr oswrch      ;register

                tya
                jsr oswrch      ;value

                lda #0
                ldx #6
-
                jsr oswrch
                dex
                bne -

		rts
                .endproc

;-------------------------------------------------------------------------


make_cursor_invisible:			

.if !ELECTRON

		ldx	#10
		ldy	#32
; End of function make_cursor_invisible


; X = CRTC register
; Y = value

write_crtc:
                pha
                
                lda #23
                jsr oswrch

                lda #0
                jsr oswrch

                jsr print_xy000000

                pla
                rts

; End of function write_crtc

.else

		ldy #0
; End of function make_cursor_invisible


; Y = VDU 23,1,Y,0;0;0;0;

set_cursor_state:

		pha			; save A
		tya
		pha			; save Y
		lda #23
		jsr OSWRCH
		lda #1
		jsr OSWRCH
		tya
		jsr OSWRCH
		ldy #8
		lda #0
set_cursor_shape_8zeros:
		jsr OSWRCH
		dey
		bne set_cursor_shape_8zeros
		pla
		tay
		pla
		rts

.endif

; entry: C=1 if bitmap mode
;        X = mode
;        A = value to use for teletext mode
;            (value for bitmap modes is always $07)
; exit: A = value to use for mode
get_cursor_value: .proc
                pha
                jsr is_bitmap_mode
                pla
                bcc +
                lda #7
+
                rts
                .endproc
                

reset_cursor_shape: .proc

.if !ELECTRON

                ; Pick cursor start scanline
                lda #0
                ldy is_insert_mode ;0=overtype 1=insert
                bne +              ;taken if insert mode - block cursor
                ; overtype mode - line cursor
                lda #$12
                jsr get_cursor_value
+
                ora cursor_size
                tay
                ldx #10
                jsr write_crtc

                ; Pick cursor end scanline
                lda #$13
                jsr get_cursor_value
                tay
                ldx #11
                jmp write_crtc
                
.else

		ldy #1	; show cursor
		jsr set_cursor_state

		lda is_insert_mode ; 0=overtype 1=insert
		ora #2 ; to give 2=steady 3=flashing
		tay
		jmp set_cursor_state

.endif
                .endproc


; End of function reset_cursor_shape

;-------------------------------------------------------------------------

is_bitmap_mode:
                ldx #$4f        ;bytes per character
                jsr read_vdu_variable
                cpx #2          ;C=1 if bitmap mode
                rts
                
read_vdu_variable:
                lda #160        ;read VDU variables (AUG 179)
                jmp osbyte

;-------------------------------------------------------------------------

kbflush:				
					
		ldx	#0		; Flush	keyboard buffer
		stx	byte_6AB
		lda	#21		; Flush	specific buffer	(AUG p138)
		jsr	OSBYTE
		lda	#216		; Read/write length of soft key	string
		jsr	osbyte_with_y0	; Cancel any current soft key expansion
		jmp	clear_escape_condition
; End of function kbflush


;-------------------------------------------------------------------------
; 
; Detokenize one line of the program.
;
; entry:
; (byte_2B) - pointer to line data
;
; exit:
;
; ?byte_400 - length of detokenized text
; unk_401... - detokenized text
                
detokenize_one_line: .proc

                ; Clear $401...$4ff inclusive
                ldx #1
                lda #$20
loop400:
                sta byte_400,x
                inx
                bne loop400

                ; Clear $500...$524 inclusive
loop500:
                sta unk_500,x
                inx
                cpx #$25
                bne loop500

		ldx	#0
		stx	byte_400 ;reset line length
		stx	line_was_truncated ;line was not truncated

		ldx	byte_2C		; get MSB of address
		inx
		bne	loc_9C26 ; branch taken if MSB of address wasn't
                                 ; $FF...???

locret_9C25:				
		rts

loc_9C26:				
		jsr	detokenize_line	; detokenize line and store result.
					;
					; Entry:
					; (byte_2B) points to line
					;
					; Exit:
					; $400 = line length
					; $401... = line text
					; unk_6A8 incremented if line too long
		lda	line_was_truncated	; line too long?
		beq	locret_9C25	; branch taken if line not too long
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	#4		; "Line	too long"
		jmp	raise_error
                .pend

;-------------------------------------------------------------------------

; detokenize line and store result.
;
; Entry:
; (byte_2B) points to line
;
; Exit:
; $400 = line length
; $401... = line text
; unk_6A8 incremented if line too long

detokenize_line: .proc
					
		clc
; Point (basic_ptr_1) at start of data of current line
		lda	byte_2B
		adc	#4		; +4 - skip 13,	line MSB, line LSB, line length.
		sta	basic_ptr_1+0
		lda	byte_2C
		sta	basic_ptr_1+1
		bcc	+
		inc	basic_ptr_1+1
+

		lda	#0
		sta	byte_400      ;reset line length count
		sta	byte_23		; index	in body	of line
		sta	basic_ptr_0+0   ; not inside quotes
		ldy	#3		; index	of line	length
		lda	(byte_2B),y	; get total line length
		sec
		sbc	#4 ; subtract 4 as the metadata is already
                           ; considered
		sta	byte_24 ; ?unk_24 = length of body of line
		beq	detokenize_line_done ; branch taken if line is empty

loc_9C59:
                ; point (ptr1) at eol
		lda	#>unk_401
		sta	ptr1+1
		clc
		lda	#<unk_401
		adc	byte_400
		sta	ptr1+0
		bcc	+
		inc	ptr1+1
+
		ldx	byte_24		; get line length
		dex			; -1 to	get index of last byte
		cpx	byte_23		; compare to current index
		bcs	loc_9C71	; branch taken if there's still more data to go

detokenize_line_done:					
		rts

loc_9C71:				
		lda	basic_ptr_0+0		; in string?
		beq	copy_tokenized	; branch taken if not in string
; point (ptr0) at byte in program

not_token:				
					
		lda	basic_ptr_1+1 ;data ptr MSB
		sta	ptr0+1        ;data ptr MSB
		lda	byte_23       ;index in body of line
		clc
		adc	basic_ptr_1+0 ;add data ptr LSB
		sta	ptr0+0        ;data ptr LSB
		bcc +
		inc	ptr0+1  ;update data ptr MSB
+

                ; Copy quoted data
		ldy	byte_23         ;index in body of line
		lda	(basic_ptr_1),y	; get next byte
		cmp	#'"'            ; quotes?
		bne	copy_quoted_byte
                
                ; Toggle quotes flag. Also still copy the quote char.
		lda	basic_ptr_0+0
		eor	#1
		sta	basic_ptr_0+0

copy_quoted_byte:
		ldy	#1        ;copy 1 byte
		bne	copy_data ;JMP, in effect

copy_tokenized:				
		ldy	byte_23         ;index in body of line
		lda	(basic_ptr_1),y	; get next byte	from line
		bpl	not_token	; if positive, not a taken
		cmp	#LINE_NUMBER_TOKEN
		bne	token		; branch taken if not a	line number

                ; Handle line number
		tya             ;index in body of line
		clc
		adc	#3		; +3 - skip line number	data
		bcs	not_token	; if carry set,	assume end of line
		cmp	byte_24		; past end of line?
		bcs	not_token	; branch taken if past end of line
		jsr	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		ldx	byte_22         ;line number MSB
		ldy	byte_21         ;line number LSB
		jsr	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string

                ; point the detokenized text pointer/length at the
                ; itoa result, then copy it.
		lda	#<unk_1
		sta	ptr0+0
		lda	#>unk_1
		sta	ptr0+1
; Skip 3 bytes (line number data)
		inc	byte_23
		inc	byte_23
		inc	byte_23
		ldy	byte_0    ;length of number
		bne	copy_data		; JMP, in effect, I think...

token:
                ; Handle a token
		sta	basic_ptr_0+1 ; basic_ptr_0?1 = token being searched for

                ; (ptr0) points into the token table, ready for
                ; copy_data
		lda	#<token_table
		sta	ptr0+0
		lda	#>token_table
		sta	ptr0+1

find_token_in_table_loop:
		ldy	#0

find_token_value_loop:
                ; Work through the token name to find its length (in
                ; Y) and value.
		lda	(ptr0),y	; get next byte	from token table
		bmi	found_token_value ; branch taken if it's a token value
		iny
		bne	find_token_value_loop

found_token_value:			
		cmp	basic_ptr_0+1 ; is it	the desired token?
		beq	copy_data     ; branch taken if token found
		cmp	#$D3 ;was that entry token $D3
		beq	not_token ; branch taken if so - $D3 is the last entry
                                  ; in the table
		iny			; skip token ID
		iny			; skip flags byte
; advance (ptr0) to next entry in token table
		tya
		clc
		adc	ptr0+0
		sta	ptr0+0
		bcc	+
		inc	ptr0+1
+
		bne	find_token_in_table_loop ;jmp, in effect

copy_data:
                ; Copy data into detokenized buffer, making sure
                ; there's space.
		tya			; get length of	data
		clc
		adc	byte_400	; add to current length
		bcs	overflow	; branch taken if line too long...
		cmp	#LINE_LENGTH_LIMIT
		bcs	overflow	; branch taken if line too long...
		sta	byte_400	; store	new current length
		dey			; Y = index of last char of token
		jsr	copy_detokenized_text ;	copy text whilst detokenizing.
					;
					; Entry:
					; (ptr0) points to source text
					; (ptr1) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		inc	byte_23		; next byte in line
		jmp	loc_9C59

overflow:				
					
		inc	line_was_truncated
		rts

; copy text whilst detokenizing.
;
; Entry:
; (ptr0) points to source text
; (ptr1) points to space in dest buffer
; Y is index of	last byte in each case (bytes are copied until Y<0)
                
copy_detokenized_text:			
		lda	(ptr0),y	
		sta	(ptr1),y
		dey
		bpl	copy_detokenized_text
		rts
                .pend

;-------------------------------------------------------------------------

; decode line number from program.
;
; Entry:
; (basic_ptr_1),Y points to 8D token
;
; Exit:
; unk_21.w is line number.

decode_line_number: .proc		
					
		iny
		lda	(basic_ptr_1),y	; get first line number	byte
		pha			; store
		ldx	#1

decode_line_number_loop:					
		pla			; get last byte
		rol
		rol			; <<2
		pha			; save
		and	#%11000000
		iny
		eor	(basic_ptr_1),y
		sta	byte_21,x
		dex
		bpl	decode_line_number_loop
		pla
		rts
                .pend

;-------------------------------------------------------------------------

init_edit_mode: .proc
					
		lda	#1
		sta	byte_6AB

loc_9D2D:
		jsr	find_program
		bcc	loc_9D3F
		jmp	language_entry.command_loop;ok

loc_9D3F:				
		jsr	set_palette
		lda	#2
		sta	editor_mode_id	; 1=command mode, 2=edit mode
                lda #$80
                sta should_cls_before_command_prompt
		lda	#13
		jsr	OSWRCH
		ldx	#9		; VDU variable 9 - text	window coordinates, bottom (X) + right (Y) (AUG	p275)
                jsr read_vdu_variable
		stx	text_window_bottom_y	; store	screen height
		tya			; get screen width in A
		sec
		sbc	#6		; subtract 6 to	account	for line number	display
		sta	code_area_width	; store	usable screen width
		ldx	#9		; set TAB key to produce CHR$9
		lda	#219		; Read/write character value returned by pressing TAB key (AUG p222)
		jsr	osbyte_with_y0
		jmp	loc_8437
                .pend

;-------------------------------------------------------------------------

set_edit_mode_option:
                jsr get_options
                ora #OPTION_EDIT_MODE
                bne set_options

clear_edit_mode_option:
                jsr get_options
                and #(~OPTION_EDIT_MODE)&$ff
                ; fall through
set_options:
                tax
                ; fall through
do_options_osbyte:                    ;must be position-independent
                lda #OPTIONS_OSBYTE   ;must be position-independent
                jsr osbyte            ;must be position-independent
                txa                   ;must be position-independent
                rts                   ;must be position-independent
get_options:                          ;must be position-independent
                ldx #$ff              ;must be position-independent
                bne do_options_osbyte ;must be position-independent
                
;-------------------------------------------------------------------------

enter_edit_mode:
		jsr	init_edit_mode
		jsr	is_program_empty ; sets	C if no	program
		bcs	loc_9DA8
		lda	byte_50
		sta	byte_2B
		lda	byte_51
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
                ; end of program?
		ldy	#1
		lda	(byte_2B),y
		bmi	loc_9DA8
                
		lda	byte_2B
		sta	byte_6C0
		lda	byte_2C
		sta	byte_6C1
		jsr	sub_9698
		bcs	loc_9DA8
                
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		jsr	sub_9706
		jsr	cls_and_reset_6c0_to_6ff
		clc
		jsr	sub_9DEA
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jmp	loc_9DE4

loc_9DA8:
					
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_9DC9
		jsr	clear_program
		jsr	cls_and_reset_6c0_to_6ff
		ldx	#<empty_program_string
		ldy	#>empty_program_string
		lda	#5
		jsr	print_n_chars
		ldx	#$FF
		stx	byte_6C0
		stx	byte_6C1
		stx	byte_2C
		jmp	loc_9DE4

loc_9DC9:				
		lda	current_line_no_lsb
		sta	byte_2C
		lda	current_line_no_msb
		sta	byte_2B
		jsr	cls_and_reset_6c0_to_6ff
		lda	#0
		sta	byte_3B
		clc
		jsr	sub_9DEA
		ldx	#1
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number

loc_9DE4:				
		jsr	sub_9FD8
                jsr set_edit_mode_option
		jmp	edit_mode_loop

;-------------------------------------------------------------------------
;
; entry:
; C = ???
; ?byte_2B = top line number MSB
; ?byte_2C = top line number LSB
;
; 
sub_9DEA: .proc
					
		php
		jsr	make_cursor_invisible
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

loc_9DF1:
		ldy	#1
		lda	(byte_2B),y ;get line no MSB
		bmi	loc_9E19    ;taken if end of program
		jsr	detokenize_one_line ;detokenize this line
		jsr	sub_9E5F
		bcc	loc_9E19
		plp
		php
		bcc	loc_9E09
		jsr	sub_9F00
		jmp	loc_9E0C

loc_9E09:				
		jsr	sub_9E82

loc_9E0C:				
		clc
		lda	byte_3B
		adc	byte_2D
		sta	byte_3B
		jsr	advance_2b_to_next_line
		jmp	loc_9DF1

loc_9E19:				
		plp
		php
		bcc	loc_9E5D

loc_9e1d:

                lda #' '
                ldx #79
loc_9e1d_fill_401_loop:
                sta unk_401-1,x
                dex
                bne loc_9e1d_fill_401_loop
                
loc_9E2E:				
		lda	byte_3B
		cmp	text_window_bottom_y
		beq	loc_9E37 ;ok if exactly at bottom
		bcs	loc_9E5D ;taken if off bottom of screen

loc_9E37:				
		asl             ;line number*2
		tay             ;Y=line number*2
		lda	byte_6C1,y ;get MSB of address
		beq	loc_9E5D   ;done if no line there
		ldx	#0
		txa
		sta	byte_6C0,y ;clear LSB
		sta	byte_6C1,y ;clear MSB
		ldy	byte_3B    ;get Y coordinate
		jsr	gotoxy     ;go to (0,Y)

                ; TODO - this could be a loop 
		clc
		lda	code_area_width
		adc	#6
		ldx	#<unk_401
		ldy	#>unk_401
		jsr	print_n_chars
		inc	byte_3B ;next Y coordinate
		bne	loc_9E2E ;jmp, in effect

loc_9E5D:				
		pla             ;discard saved P
		rts
                .pend


;-------------------------------------------------------------------------

sub_9E5F: .proc
					
		jsr	calculate_screen_chars_in_line
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	text_window_bottom_y
		sec
		sbc	byte_3B ;text_window_bottom_y-y
		clc
		adc	#1      ;text_window_bottom_y-y+1
		cmp	byte_2D ;height of line
		bcc	locret_9E81 ;taken if y+height<=text_window_bottom_y
		lda	byte_3B
		asl
		tay
		lda	byte_2B
		sta	byte_6C0,y
		lda	byte_2C
		sta	byte_6C1,y
		sec

locret_9E81:				
		rts
                .endproc

;-------------------------------------------------------------------------


sub_9E82:				
					
		lda	#1
		ldx	byte_400
		ldy	#0
		jsr	sub_A0B1
		jmp	redraw_line_number
; End of function sub_9E82


;-------------------------------------------------------------------------

; finds	a line,	given a	line number
;
; Entry:
; byte_2B: line	number MSB
; byte_2C: line	number LSB
;
; Exit:
; (byte_2B) points to most suitable line

find_line_by_number: .proc
					
		lda	byte_2B
		sta	byte_39
		lda	byte_2C
		sta	byte_3A
		lda	oshwm
		sta	unk_30
		sta	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_9EA1:				
		ldy	#1
		lda	(byte_2B),y	; get line MSB
		bmi	find_line_by_number_done		; -ve =	done
		cmp	byte_39
		bcc	loc_9EB4	; MSB<?39 -> 9eb4
		bne	find_line_by_number_done
		iny			; offset of line LSB
		lda	(byte_2B),y	; get line LSB
		cmp	byte_3A
		bcs	find_line_by_number_done
; MSB<?39 && LSB<=?3A

loc_9EB4:				
		lda	byte_2B
		sta	unk_2F
		lda	byte_2C
		sta	unk_30
		jsr	advance_2b_to_next_line
		jmp	loc_9EA1

find_line_by_number_done:					
					
		rts
                .pend

;-------------------------------------------------------------------------

; get height of	current	line
;
; Entry:
; ?byte_400 = line length
;
; Exit:
; X = line height

get_line_height: .proc
					
		ldy	#0
		ldx	byte_400	; get line length
		jsr	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		txa			; get width
		beq	loc_9ECF	; taken	if it fits exactly
		iny			; add an extra line, because it	needs it

loc_9ECF:				
		tya
		tax			; X = line height
		bne	locret_9ED4
		inx			; set height to	1 if line is empty

locret_9ED4:				
		rts
                .pend
                
;-------------------------------------------------------------------------

set_palette:
                jsr print_next_string
                .byte 254       ;allow control chars
                .byte 17,FOREGROUND_COLOUR_INDEX
                .byte 17,$80|BACKGROUND_COLOUR_INDEX
                .byte 255
					
		ldx	#BACKGROUND_COLOUR_INDEX
		ldy	background_colour ; get	BACK colour
                jsr	set_palette_entry ; X=logical colour, Y=physical colour

                ldx #FOREGROUND_COLOUR_INDEX
                ldy foreground_colour ;get FORE colour

set_palette_entry:			
		lda	#19		; X=logical colour, Y=physical colour
		jsr	OSWRCH

                ; the extra chars are no problem
                jmp print_xy000000

;-------------------------------------------------------------------------

sub_9F00:				
		jsr	make_cursor_invisible
		lda	#1
		ldx	screen_chars_in_line+0
		ldy	screen_chars_in_line+1
		jsr	sub_A0B1
		ldx	#0
		stx	byte_36

loc_9F10:				
		ldx	#0
		clc
		lda	byte_36
		beq	loc_9F26
		adc	byte_3B
		tay
                jsr	gotoxy
                lda #6
                jsr print_n_spaces

loc_9F26:				
		inc	byte_36
		lda	byte_36
		cmp	byte_2D
		bne	loc_9F10
		jmp	redraw_line_number

;-------------------------------------------------------------------------
; 
; treats command ID as ASCII char and puts that char into the current
; line as appropriate.
;

execute_key_command: .proc
		lda	cursor_offset_msb
		bne	beep    ;can't insert past 256th char
		jsr	sub_AB1E
		ldx	byte_400	; X = line length
		lda	is_insert_mode	; 0=overtype 1=insert
		beq	loc_9F5C	; branch taken if overtype mode
		lda	cursor_offset	; get cursor offset (?)
		cmp	byte_400	; compare to line length
		beq	loc_9F48
		bcs	loc_9F58	; branch taken if cursor offset	> line length

loc_9F48:				
		ldy	byte_400	; get line length
		beq	loc_9F55
		dey
		lda	unk_401,y
		cmp	#$20 ; ' '
		beq	sub_9F6F

loc_9F55:				
		inx
		bne	loc_9F65

loc_9F58:				
					
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		bne	loc_9F65

loc_9F5C:				
		lda	cursor_offset	; offset of cursor in detokenized buffer
		cmp	byte_400
		beq	sub_9F6F
		bcs	loc_9F58

loc_9F65:				
					
		cpx	#LINE_LENGTH_LIMIT
		bcc	sub_9F6F
                ; fall through to beep
                .pend

beep: .block
					
		lda	#7
		jmp	OSWRCH
                .endblock
; End of function beep


;-------------------------------------------------------------------------
;
; 
; 
; Entry:
;
; X = line length
; ?cursor_offset = where to insert char
; ?current_command_id = char to insert

sub_9F6F: .proc
					
		txa
		pha                   ; X
		lda	cursor_offset	; offset of cursor in detokenized buffer
		pha                     ; c_o X
		pha                     ; c_o c_o X
		lda	is_insert_mode	; 0=overtype 1=insert
		beq	store_char	; branch taken if overtype
		lda	cursor_offset	; offset of cursor in detokenized buffer
		cmp	byte_400
		beq	insert		; branch taken if at end of line
		bcs	store_char	; branch taken if past end of line

insert:					
		pla             ; A=cursor_offset
		txa             ; X=cursor_offset
		pha             ; c_o c_o X

                ; ptr0.w = 255
		ldx	#-1    ;src offset=cursor_offset-1
		stx	ptr0+0
		inx             ;X=0
		stx	ptr1+0  ;dest offset=cursor_offset

                ; rather involved lda#1 - make_space_in_line doesn't use X
		inx
		txa
		jsr	make_space_in_line

store_char:				
		lda	current_command_id ; get char to write
		ldy	cursor_offset	; offset of cursor in detokenized buffer
		dey			; make relative	to text
		sta	unk_401,y       ; store char
		lda	#1
		sta	byte_6B3
		pla              ;A = c_o
		tax              ;X = c_o
		pla              ;A = c_o
		tay              ;Y = c_o
		pla              ;A = X
		sta	byte_400 ;
		tya              ;A = c_o
		ldy	#0
		inc	cursor_offset	; advance to next char
		jsr	sub_A0B1
		jmp	position_edit_mode_cursor
                .endproc

;-------------------------------------------------------------------------
;
; Make space in line to insert data at cursor position.
;
; Entry:
;
; A = number of bytes of space required
; ptr0?0 = cursor-relative signed offset of source
; ptr1?0 = cursor-relative signed offset of dest

make_space_in_line: .proc	
		pha
		ldx	#2
		jsr	adjust_pointer ;adjust ptr1
		ldx	#0
		jsr	adjust_pointer ;adjust ptr0
; X=0
		pla             ;restore original A
		clc
		adc	byte_400	; add line length
		sec
		sbc	cursor_offset	; subtract cursor offset
		tay			; LSB of size (X=0)
		jmp	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size

adjust_pointer:
                ; add 1+cursor offset to ptr and set up MSB of address.
                ;
                ; X=0 for ptr0, X=2 for ptr1.
		clc
		lda	ptr0+0,x	; get pointer LSB
		adc	#1		; increment
		clc
		adc	cursor_offset
		sta	ptr0+0,x	; store
		lda	#>byte_400
		sta	ptr0+1,x	; copying in page 4.
		rts
                .endproc

;-------------------------------------------------------------------------

sub_9FD8:				
		jsr	sub_A069
		ldx	#1
		stx	cursor_offset	; offset of cursor in detokenized buffer
		dex
		stx	cursor_offset_msb
		ldx	#6
		ldy	byte_3B
		jmp	gotoxy
; End of function sub_9FD8



; sets C if no program

is_program_empty: .proc
					
		clc
		ldy	#1
		lda	(oshwm),y
		bpl	locret_9FF1
		sec

locret_9FF1:				
		rts
                .pend

;-------------------------------------------------------------------------

; check if there's room to store (basic_ptr_1) bytes past TOP. Causes a
; 'No room' error if not.
check_for_room: .proc
		clc
		lda	TOP     ;get TOP LSB
		adc	basic_ptr_1+0 ;add size of update LSB
		tax             ;save new TOP LSB
		lda	TOP+1   ;get TOP MSB
		adc	basic_ptr_1+1 ;add size of update MSB
		cmp	HIMEM+1 ;has new TOP MSB gone past HIMEM MSB?
		bcc	locret_A00D ;taken if definitely not
		beq	loc_A007    ;taken if it's equal

                ; No room...
no_room:				
		lda	#5      ;No room
		jmp	raise_error

loc_A007:				
		cpx	HIMEM   ;compare new TOP LSB to HIMEM LSB
		beq	locret_A00D ;taken if equal
		bcs	no_room     ;taken if greater

locret_A00D:				
		rts
                .pend




cls_and_reset_6c0_to_6ff:		
					
		lda	#12     ;cls_and_reset_6c0_to_6ff
		jsr	OSWRCH
		lda	#0
		ldy	#$3F

loc_A017:				
		sta	byte_6C0,y
		dey
		bpl	loc_A017
		rts
; End of function cls_and_reset_6c0_to_6ff


;-------------------------------------------------------------------------
;
; Calculate on screen area of line.
; 
; entry:
; detokenized line in byte_400
;
; exit:
; screen_chars_in_line.w = line height * code area width
                
calculate_screen_chars_in_line: .proc
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height

loc_A021:				
		stx	byte_2D
		lda	#0
		sta	screen_chars_in_line+0
		sta	screen_chars_in_line+1

                ; screen_chars_in_line = code_area_width * X
                
loc_A029:				
		lda	code_area_width
		clc
		adc	screen_chars_in_line+0
		sta	screen_chars_in_line+0
		bcc	+
		inc	screen_chars_in_line+1
+
		dex
		bne	loc_A029
		rts
                .pend

;-------------------------------------------------------------------------

; saves	line number from program.
;
; Entry:
; (byte_2b) points to current line
;
; Exit:
; current_line_no_msb, current_line_no_lsb = the line number

save_line_number:			
					
		ldy	#1
		lda	(byte_2B),y
		sta	current_line_no_msb
		iny
		lda	(byte_2B),y
		sta	current_line_no_lsb
		rts
; End of function save_line_number

;-------------------------------------------------------------------------

; gets pointer to line visible on screen.
;
; Entry:
; X = screen line number * 2 + 1
;
; Exit:
; (byte_2B) points to BASIC line
; X decremented

get_line_ptr: .proc
					
		lda	byte_6C0,x
		sta	byte_2C
		dex
		lda	byte_6C0,x
		sta	byte_2B
		rts
                .pend

;-------------------------------------------------------------------------

; determines whether current line is empty.
;
; Entry:
; detokenized line at $400...
;
; Exit:
; C set	if line	empty.

is_line_empty: .proc
					
		jsr	is_program_empty ; sets	C if no	program
		bcc	is_not_empty
		ldy	byte_400
		beq	is_empty

loc_A05B:				
		lda	unk_401-1,y
		cmp	#$20 ; ' '
		bne	is_not_empty
		dey
		bne	loc_A05B

is_empty:				
		sec
		rts

is_not_empty:				
					
		clc
		rts
                .pend


;-------------------------------------------------------------------------

sub_A069: .proc
					
		ldx	#0		; first	line on	screen

loc_A06B:				
		txa
		lsr			; A = true screen line index
		cmp	text_window_bottom_y	; check	against	height of screen

                ; end loop if A>text_window_bottom_y
		beq	+
		bcs	loc_A093
+
                
		jsr	get_line_ptr2	; gets pointer to line visible
                                        ; on screen.
					;
					; Entry:
					; X = screen line number * 2
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X=screen line number*2+1

                ; 
		ldy	byte_6C0,x
		beq	loc_A093 ;taken if entry is $00
		iny
		beq	loc_A09B ;taken if entry is $ff
                
		ldy	#1
		lda	(byte_2B),y         ;program line # MSB
		cmp	current_line_no_msb
		bcc	loc_A090            ;taken if program
                                            ;line<current line
		bne	loc_A095            ;taken if program
                                            ;line>current line
		iny
                
		lda	(byte_2B),y ;program line # LSB
		cmp	current_line_no_lsb
		bcs	loc_A095 ;taken if program line>=current line

loc_A090:				
		inx              ;X+=2 in total
		bne	loc_A06B ;JMP, in effect

loc_A093:				
		ldx	#1

loc_A095:				
		jsr	get_line_ptr_retainingX
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number

loc_A09B:				
		txa             
		lsr             ;A = true screen line index
		sta	byte_3B ;save screen line
		jsr	detokenize_one_line
		ldx	#0
		stx	byte_6B3
		jsr	calculate_screen_chars_in_line
		rts
                .pend

;-------------------------------------------------------------------------

; gets pointer to line visible on screen.
;
; Entry:
; X = screen line number * 2
;
; Exit:
; (byte_2B) points to BASIC line
; X=screen line number*2+1
;

get_line_ptr2:				
		inx			; bump X because get_line_ptr
                                        ; is wierd
                                        
                ; fall through

get_line_ptr_retainingX:		
		jsr	get_line_ptr	; gets pointer to line visible
                                        ; on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
                                        
		inx			; restore original X
		rts
; End of function get_line_ptr_retainingX


;-------------------------------------------------------------------------
;
; ?? Redraw screen after line is updated??
; 
                
sub_A0B1: .proc

current_offset=basic_ptr_0+0
update_offset=basic_ptr_1+1
                
		cpx	#0
		bne	loc_A0B6
		rts

loc_A0B6:
                ; update_offset = A-1 - offset in line
		sta	update_offset
		dec	update_offset

                ; basic_ptr_1?0 = Y
		sty	basic_ptr_1+0

                ; basic_ptr_0?1 = X-1
		dex
		stx	basic_ptr_0+1
                
		jsr	make_cursor_invisible
                
                ; byte_23.w = -1
		lda	#$FF
		sta	byte_24
		sta	byte_23
		lda	#0
		sec
		sbc	code_area_width
		sta	current_offset ;basic_ptr_0?0=-code_area_width

loc_A0D0:
                ; current_offset += code_area_width        
		clc
		lda	current_offset
		adc	code_area_width
		sta	current_offset

                ; byte_23.w += code_area_width
		clc
		lda	byte_23
		adc	code_area_width
		sta	byte_23
		bcc	+
		inc	byte_24
+

                ; byte_20.w = $401
		lda	#<unk_401
		sta	byte_20
		lda	#>unk_401
		sta	byte_21
                
                ; (byte_20) points at detokenized line

		lda	byte_24
		bne	loc_A0F8 ;taken if HI(byte_23.w)>=256
		lda	update_offset
		cmp	byte_23
		beq	loc_A0F8 ;taken if byte_23.w==entry A-1
		bcs	loc_A0D0 ;taken if byte_23.w>=entry A-1
                ; byte_23.w <= entry A-1
                
loc_A0F8:
                ; ?byte_22=max(update_offset,current_offset)
		lda	update_offset
		cmp	current_offset
		bcs	+
		lda	current_offset
+
		sta	byte_22

                ; byte_20.w+=max(update_offset,current_offset)
		clc
		adc	byte_20
		sta	byte_20
		bcc	+
		inc	byte_21
+

                ; 
		lda	basic_ptr_1+0
		bne	loc_A115
		lda	basic_ptr_0+1
		cmp	current_offset
		bcc	locret_A16C

loc_A115:				
		ldx	#0
		lda	basic_ptr_1+0
		cmp	byte_24
		beq	loc_A121
		bcs	loc_A129
		bcc	loc_A127

loc_A121:				
		lda	basic_ptr_0+1
		cmp	byte_23
		bcs	loc_A129

loc_A127:				
		ldx	#3

loc_A129:				
		sec
		lda	byte_23,x
		sbc	byte_22
		clc
		adc	#1
		pha
		ldx	byte_22
		ldy	#0
		jsr	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		clc
		txa			; get X	coordinate
		adc	#6		; offset by line numbers width
		tax			; back in X
		clc
		tya			; get Y	coordinate
		adc	byte_3B		; add base Y
		tay			; back in Y
		jsr	gotoxy		; position cursor
		lda	byte_3B		; get screen Y
		asl
		tax
		lda	byte_6C0,x
		pha
		lda	byte_6C1,x
		pha
		tya
		asl
		tax
		pla
		sta	byte_6C1,x
		pla
		sta	byte_6C0,x
		pla
		ldx	byte_20
		ldy	byte_21
		jsr	print_n_chars
		lda	byte_24
		bne	locret_A16C
		jmp	loc_A0D0

locret_A16C:				
		rts
                .endproc


redraw_line_number:			
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		beq	locret_A1D8
		jsr	make_cursor_invisible
		jsr	goto_start_of_line ; Entry:
					; byte_3B is Y coordinate.
		lda	#0
		sta	readline_ptr_msb
; Line command slot 0
		tax
		jsr	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
; Line command slot 3
		ldx	#3
		jsr	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
; Line command slot 6
		ldx	#6
		jsr	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
		lda	readline_ptr_msb
		bne	print_post_line_command_padding	; branch taken if any line command chars printed
		ldx	current_line_no_lsb
		ldy	current_line_no_msb
		jsr	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string
		sec
		lda	#5
		sbc	byte_0
; Right-justify number
		jsr	print_n_spaces	; prints N spaces.
					;
					; Entry:
					; A = number of	spaces to print	(max 6)
                jsr print_itoa_result
                
print_space_or_marker:			
		ldx	#12
		jsr	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		lda	#$20 ; ' '
		bcc	redraw_line_number_print_char
		lda	#$2E ; '.'

redraw_line_number_print_char:				
		jmp	OSWRCH
; End of function redraw_line_number



; Entry:
; byte_3B is Y coordinate.

goto_start_of_line:			
		ldx	#0
		ldy	byte_3B
		jmp	gotoxy
; End of function goto_start_of_line



; prints line command chars for	the current line, if any.
;
; Entry:
; current_line_no_msb,
; current_line_no_lsb =	current	line
; X = line command slot	ID
;
; Exit:
; readline_ptr_msb bumped by number of chars printed.

print_line_command_chars:		
					
		lda	byte_40,x		; fetch	control	byte
		cmp	#$20 ; ' '
		beq	locret_A1D8	; branch taken if no line command here
		jsr	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		bcc	locret_A1D8	; branch taken if no command here
; If char stored is lower-case, print it in upper case, but twice.
		cmp	#$60 ; '`'
		bcc	loc_A1D3
		sec
		sbc	#$20 ; ' '
		jsr	OSWRCH
		inc	readline_ptr_msb

loc_A1D3:				
		jsr	OSWRCH
		inc	readline_ptr_msb

locret_A1D8:				
					
		rts
; End of function print_line_command_chars


print_post_line_command_padding:	
		sec
		lda	#5
		sbc	readline_ptr_msb
		jsr	print_n_spaces	; prints N spaces.
					;
					; Entry:
					; A = number of	spaces to print	(max 6)
		jmp	print_space_or_marker



clear_line_commands:			
					
		lda	#$20 ; ' '
		sta	byte_40
		sta	byte_43
		sta	byte_46
		rts
; End of function clear_line_commands




set_primary_line_command:		
		ldx	#0
		jsr	is_line_command_slot_free ; check availability of line command slot.
					;
					; Entry:
					; X = slot ID
					;
					; Exit:
					; C set	if slot	is free.
		bcs	use_slot
		ldx	#3
		jsr	is_line_command_slot_free ; check availability of line command slot.
					;
					; Entry:
					; X = slot ID
					;
					; Exit:
					; C set	if slot	is free.

use_slot:				
		lda	current_command_id
		clc
		adc	#$40		; make letter from command ID -- 'C', 'D' or 'M'
		ldy	byte_40,x		; get old command
		cpy	#$20 ; ' '      ; no command?
		beq	set_line_command ; branch taken	if no command.
					; just set command if taken.
		cmp	byte_40,x		; is this the command that's there already?
		bne	set_line_command ; branch taken	if not same command.
					; overwrite old	command	with new one if	taken.
		clc
		adc	#$20 ; ' '      ; +$20 to indicate doubling of command

set_line_command:			
					
		sta	byte_40,x		; store	command
		lda	current_line_no_msb
		sta	byte_41,x ; store	line no	LSB
		lda	current_line_no_lsb
		sta	byte_42,x		; store	line no	MSB

loc_A216:				
		jsr	redraw_line_number ; update line number	with new commands
		jmp	position_edit_mode_cursor
; End of function set_primary_line_command



; checks if the	given line command is set on the current line.
;
; Entry:
; current_line_no_msb,
; current_line_no_lsb =	current	line
; X = line command slot	ID
;
; Exit:
; C set	if command is on current line.

is_current_line:			
					
		pha
		lda	current_line_no_msb
		cmp	byte_41,x
		bne	loc_A22C
		lda	current_line_no_lsb
		cmp	byte_42,x
		bne	loc_A22C
		sec
		bcs	loc_A22D

loc_A22C:				
					
		clc

loc_A22D:				
		pla

locret_A22E:				
					
		rts
; End of function is_current_line



; check	availability of	line command slot.
;
; Entry:
; X = slot ID
;
; Exit:
; C set	if slot	is free.

is_line_command_slot_free:		
					
		lda	byte_40,x		; get line command flag
		cmp	#$20 ; ' '      ; is it free?
		beq	locret_A22E	; branch taken if slot free.
					; return with C	set if taken.
		jsr	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		bcs	locret_A22E	; branch taken if this slot is on the current line.
					; return with C	set if taken. (can change commands on current line.)
; slot is not free.
		cpx	#0		; was it slot ID 0 being checked?
		clc			; clear	carry to indicate it isn't free
		beq	locret_A22E	; if it	was slot ID 0, just return with	carry clear
		jsr	beep		; otherwise, beep
		jmp	edit_mode_loop
; End of function is_line_command_slot_free


loc_A245:				
		clc
		lda	current_command_id
		adc	#$40 ; '@'
		sta	byte_46
		lda	current_line_no_msb
		sta	byte_47
		lda	current_line_no_lsb
		sta	byte_48
		jmp	loc_AC08

loc_A258:				
		ldx	#0
		stx	readline_ptr_msb
		jsr	sub_A280
		ldx	#3
		jsr	sub_A280
		ldx	#6
		jsr	sub_A280
		ldx	#$C
		jsr	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		bcc	loc_A276
		jsr	sub_B358
		jmp	loc_A216

loc_A276:				
		lda	readline_ptr_msb
		bne	loc_A216
		jsr	clear_line_commands
		jmp	loc_AC08



sub_A280:				
		lda	byte_40,x
		cmp	#$20 ; ' '
		beq	locret_A2A0
		jsr	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		bcc	locret_A2A0
		cpx	#0
		bne	loc_A29A
		ldx	#3

loc_A291:				
		lda     byte_43-1,x
		sta	byte_40-1,x
		dex
		bne	loc_A291
		ldx	#3

loc_A29A:				
		lda	#$20 ; ' '
		sta	byte_40,x
		inc	readline_ptr_msb

locret_A2A0:				
		rts
; End of function sub_A280




sub_A2A1:				
					
		lda	byte_46
		cmp	#$54 ; 'T'
		bne	loc_A2B1
		ldy	#1
		lda	(oshwm),y
		tax
		iny
		lda	(oshwm),y
		tay
		rts

loc_A2B1:				
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		lda	#-1
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		ldy	#1
		lda	(unk_2F),y
		tax
		iny
		lda	(unk_2F),y
		tay
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		rts
; End of function sub_A2A1

; flags bits:
;
; bit 0 set when valid as the prefix of a variable name (BGET, BPUT,
; CLEAR, CLG, CLOSE, CLS, COUNT, END, ENDPROC, EOF, ERL, ERR, EXT,
; FALSE, HIMEM, LOMEM, NEW, OLD, PAGE, PI, POS, PTR, REPORT, RETURN,
; RND, RUN, STOP, TIME, TRUE, VPOS)
;
; bit 1 set when this keyword should set the RHS flag when tokenizing
; (BPUT, CALL, CHAIN, CLOSE, COLOUR, DIM, DRAW, ENVELOPE, FOR, GCOL,
; GOSUB, GOTO, HIMEM, IF, INPUT, LOAD, LOCAL, LOMEM, MODE, MOVE, NEXT,
; ON, OSCLI, PAGE, PLOT, PRINT, PROC, PTR, READ, RESTORE, SAVE, SOUND,
; TIME, TRACE, UNTIL, VDU, WIDTH)
;
; bit 2 set when this keyword should clear the LHS flag [ELSE, ERROR,
; LET, THEN]
;
; bit 3 set when this keyword must be followed by a valid symbol [FN,
; PROC]
;
; bit 4 set when byte_24 should be set [AUTO, DELETE, ELSE, GOSUB,
; GOTO, LIST, RENUMBER, RESTORE, THEN, TRACE]
;
; bit 5 set if tokenizing should stop [DATA, REM]

basic_token: .macro text,token,flags
                .text \text
                .byte \token
                .byte \flags
                .endm

token_table:	.basic_token "AND",$80,0 
		.basic_token "ABS",$94,0 
		.basic_token "ACS",$95,0 
		.basic_token "ADVAL",$96,0 
		.basic_token "ASC",$97,0 
		.basic_token "ASN",$98,0 
		.basic_token "ATN",$99,0 
		.basic_token "AUTO",$C6,$10 
		.basic_token "BGET",$9A,1 
		.basic_token "BPUT",$D5,3 
                .basic_token "COLOUR",$FB,2 
		.basic_token "COLOR",$FB,2 
		.basic_token "CALL",$D6,2 
		.basic_token "CHAIN",$D7,2 
		.basic_token "CHR$",$BD,0 
		.basic_token "CLEAR",$D8,1 
		.basic_token "CLOSE",$D9,3 
		.basic_token "CLG",$DA,1 
		.basic_token "CLS",$DB,1 
		.basic_token "COS",$9B,0 
		.basic_token "COUNT",$9C,1 
		.basic_token "DATA",$DC,$20 
		.basic_token "DEG",$9D,0 
		.basic_token "DEF",$DD,0 
                .basic_token "DELETE",$C7,$10 
		.basic_token "DIV",$81,0 
		.basic_token "DIM",$DE,2 
		.basic_token "DRAW",$DF,2 
                .basic_token "ENDPROC",$E1,1 
		.basic_token "END",$E0,1 
                .basic_token "ENVELOPE",$E2,2 
		.basic_token "ELSE",$8B,$14 
		.basic_token "EVAL",$A0,0 
		.basic_token "ERL",$9E,1 
		.basic_token "ERROR",$85,4 
		.basic_token "EOF",$C5,1 
		.basic_token "EOR",$82,0 
		.basic_token "ERR",$9F,1 
		.basic_token "EXP",$A1,0 
		.basic_token "EXT",$A2,1 
		.basic_token "FOR",$E3,2 
		.basic_token "FALSE",$A3,1 
		.basic_token "FN",$A4,8 
                .basic_token "GOTO",$E5,$12 
		.basic_token "GET$",$BE,0 
		.basic_token "GET",$A5,0 
		.basic_token "GOSUB",$E4,$12 
		.basic_token "GCOL",$E6,2 
                .basic_token "HIMEM",$93,$43 
		.basic_token "INPUT",$E8,2 
		.basic_token "IF",$E7,2 
                .basic_token "INKEY$",$BF,0 
		.basic_token "INKEY",$A6,0 
		.basic_token "INT",$A8,0 
		.basic_token "INSTR(",$A7,0 
		.basic_token "LIST",$C9,$10 
		.basic_token "LINE",$86,0 
                .basic_token "LOAD",$C8,2 
                .basic_token "LOMEM",$92,$43 
		.basic_token "LOCAL",$EA,2 
		.basic_token "LEFT$(",$C0,0 
		.basic_token "LEN",$A9,0 
		.basic_token "LET",$E9,4 
		.basic_token "LOG",$AB,0 
		.basic_token "LN",$AA,0 
		.basic_token "MID$(",$C1,0 
                .basic_token "MODE",$EB,2 
		.basic_token "MOD",$83,0 
		.basic_token "MOVE",$EC,2 
		.basic_token "NEXT",$ED,2 
		.basic_token "NEW",$CA,1 
		.basic_token "NOT",$AC,0 
		.basic_token "OLD",$CB,1 
		.basic_token "ON",$EE,2 
		.basic_token "OFF",$87,0 
		.basic_token "OR",$84,0 
                .basic_token "OPENIN",$8E,0 
                .basic_token "OPENOUT",$AE,0 
                .basic_token "OPENUP",$AD,0 
		.basic_token "OSCLI",$FF,2 
		.basic_token "PRINT",$F1,2 
                .basic_token "PAGE",$90,$43 
		.basic_token "PTR",$8F,$43 
		.basic_token "PI",$AF,1 
		.basic_token "PLOT",$F0,2 
		.basic_token "POINT(",$B0,0 
		.basic_token "PROC",$F2,$A 
		.basic_token "POS",$B1,1 
                .basic_token "RETURN",$F8,1 
                .basic_token "REPEAT",$F5,0 
                .basic_token "REPORT",$F6,1 
		.basic_token "READ",$F3,2 
		.basic_token "REM",$F4,$20 
		.basic_token "RUN",$F9,1 
		.basic_token "RAD",$B2,0 
                .basic_token "RESTORE",$F7,$12 
		.basic_token "RIGHT$(",$C2,0 
		.basic_token "RND",$B3,1 
                .basic_token "RENUMBER",$CC,$10 
		.basic_token "STEP",$88,0 
                .basic_token "SAVE",$CD,2 
		.basic_token "SGN",$B4,0 
		.basic_token "SIN",$B5,0 
		.basic_token "SQR",$B6,0 
		.basic_token "SPC",$89,0 
		.basic_token "STR$",$C3,0 
                .basic_token "STRING$(",$C4,0 
		.basic_token "SOUND",$D4,2 
		.basic_token "STOP",$FA,1 
		.basic_token "TAN",$B7,0 
		.basic_token "THEN",$8C,$14 
		.basic_token "TO",$B8,0 
		.basic_token "TAB(",$8A,0 
		.basic_token "TRACE",$FC,$12 
                .basic_token "TIME",$91,$43 
		.basic_token "TRUE",$B9,1 
		.basic_token "UNTIL",$FD,2 
		.basic_token "USR",$BA,0 
		.basic_token "VDU",$EF,2 
		.basic_token "VAL",$BB,0 
		.basic_token "VPOS",$BC,1 
		.basic_token "WIDTH",$FE,2 
                
		.basic_token "PAGE",$D0,0 
		.basic_token "PTR",$CF,0 
		.basic_token "TIME",$D1,0 
		.basic_token "LOMEM",$D2,0 
		.basic_token "HIMEM",$D3,0 

toggle_insert_overtype_command:		
		ldx	#0
		lda	is_insert_mode	; 0=overtype 1=insert
		bne	loc_A5D9
		ldx	#1

loc_A5D9:				
		stx	is_insert_mode	; 0=overtype 1=insert
		rts
; End of function toggle_insert_overtype_command




scroll_command:				
		ldx	#1

loc_A5DE:				
		stx	is_scroll_on	; 1=scroll, 0=noscroll
		rts
; End of function scroll_command


noscroll_command:			
		ldx	#0
		beq	loc_A5DE

background_edit_mode_command:		
		ldy	#0
		beq	loc_A5EB

foreground_edit_mode_command:		
		ldy	#1

loc_A5EB:				
		lda	$A,y
		clc
		adc	#1
		cmp	#8
		bcc	loc_A5F7
		lda	#0

loc_A5F7:				
		sta	$A,y
		jsr	set_palette
		rts

run_or_exit_command: .proc
.if !ELECTRON
		lda	#0
.else
		lda #1
.endif
		sta	is_insert_mode	; 0=overtype 1=insert
		lda	#$60 ; '`'
		sta	cursor_size
                jsr	reset_cursor_shape
                jsr print_next_string
                .byte 254       ; allow control chars
                .byte 26        ; reset text and graphics windows
                .byte 12        ; CLS (run_or_exit_command)
                .byte 255
		jsr	reset_keys_settings
		lda	#228
		jsr	osbyte_with_x0_y0
		lda	is_bad_program
                bne	loc_A64D
run_or_exit_without_shutdown:
		jsr	is_program_empty ; sets	C if no	program
		bcs	loc_A64D
		ldx	#4		; ending position is by	default	after "OLD|M" part
		lda	current_command_id
		cmp	#CMD_RUN	; is the command RUN?
		bne	type_commands	; if not, just typing "OLD|M" is fine
		ldx	#0		; if RUN, type "OLD|MRUN|M"

type_commands:				
		lda	#8
                sta	byte_3A		; position in "OLD|MRUN|M" string
                
		stx	byte_39		; ending position in string

type_commands_loop:			
		ldx	byte_3A
		dex
		lda	nur_dlo_string,x ; get next character
		tay			; put char into	Y for OSBYTE
		ldx	#0		; 0 = keyboard buffer
		lda	#138		; insert into keyboard buffer
		jsr	OSBYTE
		dec	byte_3A		; next char in string
		lda	byte_3A
		cmp	byte_39		; reached the end?
		bne	type_commands_loop

loc_A64D:				
		ldx	#0
		ldy	#255
		lda	#187		; get ROM containing BASIC
		jsr	OSBYTE
		lda	#142		; enter	language ROM
                jsr	OSBYTE

.pend

exit_and_OLD: .proc
                ldx #4          ;"OLD|M"
                jmp run_or_exit_command.type_commands
.pend

exit_and_OLD_and_RUN: .proc
                ldx #0          ;"OLD|MRUN|M"
                jmp run_or_exit_command.type_commands
.pend

top_edit_mode_command:			
					
		lda	#0
		sta	byte_2B
		sta	byte_2C

loc_A661:				
		lda	#0
		sta	byte_3B
		sec
		jsr	sub_9DEA
		jsr	sub_8314
		jsr	sub_9FD8
		jmp	edit_mode_loop

top_command:				
		jsr	sub_8314
		jmp	loc_9DA8

end_command:				
		jsr	cls_and_reset_6c0_to_6ff
		lda	#0
		beq	loc_A681

end_edit_mode_command:			
					
		lda	#1

loc_A681:				
		pha
		lda	#$FF
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		pla
		tax
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		txa
		pha
		jsr	sub_AA47
		lda	#0
		sta	byte_3B
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		plp
		jsr	sub_9DEA
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jsr	sub_9FD8
		jmp	edit_mode_loop

new_command:				
		jsr	clear_program

loc_A6BE:				
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		cmp	#1
		beq	locret_A6C8
		jmp	loc_9DA8

locret_A6C8:				
		rts

old_command .proc				
		jsr	is_program_empty ; sets	C if no	program
		bcc good_program
		ldy	#1
		lda	#0
		sta	(oshwm),y
		jsr	find_program
		bcc good_program
		jmp	language_entry.command_loop;ok

good_program:				
					
                jsr	sub_8314
                jmp	loc_A6BE
.pend
; End of function old_command


extend_statement_edit_mode_command .proc	
		ldx	screen_chars_in_line+1
		dex
		bne	loc_A6F4
		jmp	beep

loc_A6F4:				
		jsr	loc_AB3C
		jmp	position_edit_mode_cursor
.pend
                
swap_case_edit_mode_command: .proc
		ldx	cursor_offset_msb
		dex
		beq	loc_A715
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		lda	unk_401-1,x
		jsr	toggle_case
		sta	unk_401-1,x
		lda	#1
		sta	byte_6B3
		txa
		ldy	#0
		jsr	sub_A0B1 ;A=offset X=offset Y=0

loc_A715:				
		jmp	cursor_right_edit_mode_command
.pend
                
renumber_edit_mode_command:		
					
		jsr	sub_8492
		jmp	loc_967A

undo_edit_mode_command:			
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_A726
		jmp	loc_9DA8

loc_A726:				
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		jsr	sub_AA17
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jsr	sub_9FD8
		jmp	position_edit_mode_cursor

copy_key_edit_mode_command:		
		ldx	#0
		lda	cursor_size
		bne	loc_A745
		ldx	#$40 ; '@'
		bne	loc_A74B

loc_A745:				
		cmp	#$60 ; '`'
		beq	loc_A74B
		ldx	#$60 ; '`'

loc_A74B:				
		stx	cursor_size
		rts

top_of_screen_edit_mode_command:	
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		jmp	loc_A661



cursor_left_edit_mode_command: .proc
		jsr	move_cursor_left
		bcc	loc_A768
		lda	screen_chars_in_line+1
		sta	cursor_offset_msb
		lda	screen_chars_in_line+0
		sta	cursor_offset	; offset of cursor in detokenized buffer
		bne	start_of_line.position_cursor

loc_A768:				
		sec
		lda	cursor_offset	; offset of cursor in detokenized buffer
		sbc	#1
		sta	cursor_offset	; offset of cursor in detokenized buffer
		bcs	start_of_line.position_cursor
		dec	cursor_offset_msb
                beq     start_of_line.position_cursor
                ; fall through?
                .pend

; returns C=0 if moved within line, or C=1 if potentially moved
; outside line.
move_cursor_left: .block
					
		clc
		ldx	cursor_offset ;get cursor offset
		dex                   ;
		bne	locret_A783   ;taken if index >0 - can move
                                      ;left within line
		lda	cursor_offset_msb ;
		bne	locret_A783   ;taken if index >=256 - can move
                                      ;left within line
		jsr	move_cursor_to_previous_line      ;
		sec

locret_A783:				
                rts
                .bend

;-------------------------------------------------------------------------

cursor_right_edit_mode_command: .proc
		lda	cursor_offset ; offset of cursor in detokenized buffer
		cmp	screen_chars_in_line+0
		bne	move_cursor_right_within_line

		lda	cursor_offset_msb   ;
		cmp	screen_chars_in_line+1
		bne	move_cursor_right_within_line
		jsr	sub_B7A1
                ; fall through
                .pend

;-------------------------------------------------------------------------

start_of_line: .block
                jsr move_cursor_to_start_of_line
position_cursor:
                jmp position_edit_mode_cursor
                .bend

;-------------------------------------------------------------------------

move_cursor_to_start_of_line: .block
                ldx #0
                stx cursor_offset_msb
                inx
                stx cursor_offset
                rts
                .bend

;-------------------------------------------------------------------------

move_cursor_right_within_line: .proc
					
		inc	cursor_offset
		bne	+
		inc	cursor_offset_msb
+					
		jmp	position_edit_mode_cursor
                .pend

;-------------------------------------------------------------------------

shift_cursor_left_edit_mode_command: .proc
                jmp start_of_line
                .pend

;-------------------------------------------------------------------------

extend_line_if_necessary: .proc
                ; If line is more than 256 chars on screen, no need to
                ; extend, because no line can be that long.
                lda screen_chars_in_line+1
                bne done

                lda cursor_offset
                cmp screen_chars_in_line+0
                bcc done
                beq done

                jsr loc_ab3c
                
done:
                rts
                
                .pend

;-------------------------------------------------------------------------

set_8bit_cursor_offset: .proc
                stx cursor_offset

                lda #0
                sta cursor_offset_msb

                jsr extend_line_if_necessary

                jmp position_edit_mode_cursor
                .pend
                
;-------------------------------------------------------------------------
                
shift_cursor_right_edit_mode_command: .proc
                ; Put the cursor one byte past the end of the line. No
                ; problem if this is past the limit.
                ldx byte_400
                inx
                jmp set_8bit_cursor_offset
                .pend

;-------------------------------------------------------------------------

move_to_prev_line_edit_mode_command: .proc
                jsr move_cursor_to_start_of_line
                jsr move_cursor_left
                jmp start_of_line
                .pend

;-------------------------------------------------------------------------

move_to_next_line_edit_mode_command: .proc	
					
		jsr	sub_B7A1
		jmp	start_of_line
                .pend

;-------------------------------------------------------------------------

move_cursor_down_on_screen: .proc
		clc
		lda	cursor_offset	; offset of cursor in detokenized buffer
		adc	code_area_width
		sta	cursor_offset	; offset of cursor in detokenized buffer
		bcc	locret_A7C9
		inc	cursor_offset_msb

locret_A7C9:				
		rts
                .pend


cursor_down_edit_mode_command:

                ; Save old offset.
		lda	cursor_offset
		pha
		lda	cursor_offset_msb
		pha
                
		jsr	move_cursor_down_on_screen

                ; cursor_offset -= screen_chars_in_line
		sec
		lda	cursor_offset
		sbc	screen_chars_in_line+0
		sta	cursor_offset
		lda	cursor_offset_msb
		sbc	screen_chars_in_line+1
		sta	cursor_offset_msb

                ; If cursor_offset>0, the movement took it off the end
                ; of the line, so sort that out.
		jsr	is_cursor_offset_negative_or_zero
		bcc	loc_A7EA ;taken if cursor_offset>0

                ; Cursor should remain on the same line, though it's
                ; now in the wrong place, so fix that up.
		pla
		pla
		jmp	offset_cursor_by_screen_chars_in_line

loc_A7EA:				
		pla             ;
		tax             ;cursor offset MSB
		pla             ;
		tay             ;cursor offset LSB
		lda	cursor_offset 
		pha
		lda	cursor_offset_msb
		pha
		stx	cursor_offset_msb
		sty	cursor_offset
                
		jsr	sub_B7A1
                
		pla
		sta	cursor_offset_msb
		pla
		sta	cursor_offset	; offset of cursor in detokenized buffer
		jmp	position_edit_mode_cursor



; returns C=1 if negative
is_cursor_offset_negative_or_zero: .proc
		sec
		lda	cursor_offset_msb
		bmi	locret_A812 ;taken if offset<0 - is negative
		beq	loc_A80D ;taken if (offset&0xff00)==0 - may be zero
		bne	loc_A811    ;taken if offset>0 - not negative

loc_A80D:				
		lda	cursor_offset	; offset of cursor in detokenized buffer
		beq	locret_A812     ;taken if zero - is zero

loc_A811:				
		clc

locret_A812:				
		rts
                .pend


move_cursor_up_on_screen: .proc
		sec
		lda	cursor_offset	; offset of cursor in detokenized buffer
		sbc	code_area_width
		sta	cursor_offset	; offset of cursor in detokenized buffer
		bcs	locret_A81F
		dec	cursor_offset_msb

locret_A81F:				
		rts
                .pend


cursor_up_edit_mode_command: .proc
		jsr	move_cursor_up_on_screen

loc_A823:
		jsr	is_cursor_offset_negative_or_zero
		bcs	loc_A82B ;taken if offset is negative or zero
		jmp	position_edit_mode_cursor

loc_A82B:				
		jsr	move_cursor_down_on_screen ;undo the movement
		jsr	move_cursor_to_previous_line ;

                ; move cursor up again, then offset it by the area of
                ; the line on screen, so it ends up at the right place
                ; on the last row of the line.
		jsr	move_cursor_up_on_screen
                .pend

offset_cursor_by_screen_chars_in_line: .block
		clc
		lda	cursor_offset	; offset of cursor in detokenized buffer
		adc	screen_chars_in_line+0
		sta	cursor_offset	; offset of cursor in detokenized buffer
		lda	cursor_offset_msb
		adc	screen_chars_in_line+1
		sta	cursor_offset_msb
		jmp	position_edit_mode_cursor
                .bend

;-------------------------------------------------------------------------
;
; Return some indication of how far the cursor is from the end of
; line.
;
; (len: $b)
; Line:   PRINT"FRED"
; Offset: 123456789abcdef
; Result: 000000000012333 (etc.)
;
; 0 = within line
; 1 = on last char
; 2 = one past last char
; 3 = outside line
;
; When A<3, cursor_offset_msb is 0.
;
; exit: A = distance as above
;       Z = set as per value of A
get_distance_from_eol: .proc
                lda cursor_offset_msb
                bne much_past_end

                lda cursor_offset
                sec
                sbc byte_400
                bcc within_line
                beq at_end
                cmp #1
                beq past_end
                
much_past_end:
                lda #3
                rts

past_end:
                lda #2
                rts
                
at_end:
                lda #1
                rts
                
within_line:
                lda #0
                rts


                .pend

;-------------------------------------------------------------------------

                .if ENABLE_DEBUG
print_debug_stuff_value: .proc
                pha             ;save value
                
                tya
                pha             ;save Y coordinate

                ldx #$0a        ;right hand column (AUG 275)
                jsr read_vdu_variable

                ; make space for max 3 digits
                dex
                dex
                dex

                pla
                tay             ;Y coordinate
                jsr gotoxy

                lda #32
                jsr oswrch_x3
                lda #8
                jsr oswrch_x3

                pla
                tax
                ldy #0
                jsr itoa
                jmp print_itoa_result
                
oswrch_x3:
                jsr oswrch
                jsr oswrch
                jmp oswrch
                .pend
                .endif
                
                .if ENABLE_DEBUG
print_debug_stuff_edit_mode_command: .proc

                ; print distance from EOL
                jsr get_distance_from_eol
                ldy #0
                jsr print_debug_stuff_value

                ; print cursor offset
                lda cursor_offset
                ldy #1
                jsr print_debug_stuff_value

                ; print line length
                lda byte_400
                ldy #2
                jsr print_debug_stuff_value

                jmp position_edit_mode_cursor

                .pend
                .endif
                
;-------------------------------------------------------------------------

move_to_prev_stmt_edit_mode_command: .proc
                jsr get_distance_from_eol

                ; If past end of line, go to end of line.
                cmp #3
                beq move_to_next_stmt_edit_mode_command.go_to_eol

                ; If at start of line, go to end of previous line.
                ldx cursor_offset
                cpx #2
                bcc go_to_previous_eol

                ; Otherwise, look for previous ':' and pop the cursor
                ; after it.
                dex
loop:
                dex
                beq go_to_bol
                lda byte_400,x
                cmp #":"
                beq move_to_next_stmt_edit_mode_command.found_stmt
                bne loop        ;(jmp)
go_to_bol:
                jmp shift_cursor_left_edit_mode_command

go_to_previous_eol:
                jsr move_cursor_to_start_of_line
                jsr move_cursor_left
                jmp shift_cursor_right_edit_mode_command
                .pend

;-------------------------------------------------------------------------

move_to_next_stmt_edit_mode_command: .proc
                jsr get_distance_from_eol

                ; If at or past end of line, go to next line.
                cmp #2
                bcs go_to_next_line

                ; If right at end of line, go to end of line.
                cmp #1
                beq go_to_eol
                
                ldx cursor_offset
loop:
                lda byte_400,x
                cmp #":"
                beq found_stmt
                inx
                cpx byte_400
                bne loop
go_to_eol:
                jmp shift_cursor_right_edit_mode_command

go_to_next_line:
                jmp move_to_next_line_edit_mode_command

found_stmt:
                inx             ;skip the ':' itself
                jmp set_8bit_cursor_offset
                .pend
                
;-------------------------------------------------------------------------

move_to_top_of_screen_edit_mode_command: .proc
		jsr	sub_AA06
		lda	byte_6C0
		sta	byte_2B
		lda	byte_6C1
		sta	byte_2C
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	sub_A069
		jmp	start_of_line
                .pend

;-------------------------------------------------------------------------

move_to_bottom_of_screen_edit_mode_command: .proc
		jsr	sub_AA06
		lda	#0
		sta	byte_2B
		sta	byte_2C
		jsr	sub_BA69
		lda	$6BF,x
		sta	byte_2C
		lda	$6BE,x
		sta	byte_2B
		jsr	sub_BA69
		inx
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jmp	sub_9FD8
                .pend

;-------------------------------------------------------------------------

shift_cursor_up_edit_mode_command: .proc
		ldx	byte_6C0
		ldy	byte_6C1
		cpx	#0
		bne	loc_A88E
		cpy	oshwm+1
		bne	loc_A88E
		jmp	top_edit_mode_command

loc_A88E:				
		stx	byte_2B
		sty	byte_2C
		jmp	loc_AA41
                .pend

;-------------------------------------------------------------------------

shift_cursor_down_edit_mode_command:	
		lda	#0
		sta	byte_2B
		sta	byte_2C
		jsr	sub_BA69
		dex
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jmp	loc_9DA8

;-------------------------------------------------------------------------

position_edit_mode_cursor: .proc
					
		ldy	cursor_offset_msb
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		bne	loc_A8AF
		dey

loc_A8AF:				
		dex
		jsr	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		txa
		clc
		adc	#6
		tax
		tya
		clc
		adc	byte_3B
		tay
		jmp	gotoxy
                .pend

;-------------------------------------------------------------------------

sub_A8C0: .proc ;happens when tokenizing an altered line?
					
		lda	byte_6B3
		bne	loc_A8C6
		rts

loc_A8C6:				
		lda	#0
		sta	line_was_truncated ;line isn't too long
		pha              ;

loc_A8CC:				
		jsr	rstrip_and_tokenize_line
		clc
		txa             ;$401,X = CR
		adc	#4      ;+4 to accommodate line header size
		sta	unk_503 ;line header, byte 3
		lda	#$D
		sta	unk_500 ;line header, byte 0
		lda	current_line_no_msb
		sta	unk_501 ;line header, byte 1
		lda	current_line_no_lsb
		sta	unk_502 ;line header, bye 2

                ; prepare image of final line at unk_500...
                ldx #0
copy_loop:
                lda unk_401,x
                sta unk_503+1,x
                inx
                cpx #LINE_LENGTH_LIMIT
                bne copy_loop
                                        
		jmp	loc_A905
                
loc_A8FF:
		lda	#0
		sta	line_was_truncated ;line isn't too long
		pha

loc_A905:				
		lda	#<unk_500
		sta	byte_2B
		lda	#>unk_500
		sta	byte_2C
		jsr	detokenize_line	; detokenize line and store result.
					;
					; Entry:
					; (byte_2B) points to line
					;
					; Exit:
					; $400 = line length
					; $401... = line text
					; unk_6A8 incremented if line too long
		lda	line_was_truncated        ;was there an overflow?
		beq	loc_A928        ;taken if not
		lda	byte_6A7        ;erm...
		bne	loc_A91F        ;erm...
		lda	#$25    ; "Updates would make line too long"
		jmp	raise_error

loc_A91F:				
		pla
		bne	loc_A929
		lda	#1
		pha
		jmp	loc_A8CC

loc_A928:				
		pla

loc_A929:				
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

                                        
		ldy	#1
		lda	(byte_2B),y             ;get line # LSB
		cmp	current_line_no_msb ;is it the current line?
		bne	loc_A943            ;no - going to have to
                                            ;insert
		iny                         ;
		lda	(byte_2B),y             ;get line # MSB
		cmp	current_line_no_lsb ;is it the current line?
		beq	loc_A947            ;yes, update in place

loc_A943:				
		ldx	#-1
		stx	byte_2C

loc_A947:				
		ldx	byte_2C
		inx
		stx	basic_ptr_0+0
		lda	unk_503
		cpx	#0
		beq	loc_A958
		sec
		ldy	#3
		sbc	(byte_2B),y

loc_A958:				
		sta	basic_ptr_1+0
		lda	#0
		sbc	#0
		sta	basic_ptr_1+1
		jsr	find_program
		jsr	check_for_room
		ldx	current_line_no_lsb
		ldy	current_line_no_msb
		inx
		bne	loc_A96E
		iny

loc_A96E:				
		stx	byte_2C
		sty	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

                ; source = line
		lda	byte_2C
		sta	ptr0+1
		lda	byte_2B
		sta	ptr0+0

                ; dest = 
		clc
		adc	basic_ptr_1+0
		sta	ptr1+0
		lda	byte_2C
		adc	basic_ptr_1+1
		sta	ptr1+1
		sec
		lda	TOP
		sbc	ptr0+0
		tay
		lda	TOP+1
		sbc	ptr0+1
		tax
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		lda	#0
		sta	ptr0+0
		lda	#5
		sta	ptr0+1
		ldy	#4
		ldx	basic_ptr_0+0
		bne	loc_A9A6
		ldy	#0

loc_A9A6:				
		lda	byte_2B,y
		sta	ptr1+0
		lda	byte_2C,y
		sta	ptr1+1
		lda	editor_mode_id	; 1=command mode, 2=edit mode
		cmp	#1
		beq	loc_A9F3
		ldx	byte_2D
		lda	byte_3B
		asl
		tay

loc_A9BD:				
		lda	ptr1+0
		sta	byte_2B
		sta	byte_6C0,y
		iny
		lda	ptr1+1
		sta	byte_2C
		sta	byte_6C0,y
		iny
		dex
		bne	loc_A9BD

loc_A9D0:				
		tya
		lsr
		cmp	text_window_bottom_y
		beq	loc_A9D9
		bcs	loc_A9F3

loc_A9D9:				
		lda	byte_6C1,y
		beq	loc_A9F3
		clc
		lda	byte_6C0,y
		adc	basic_ptr_1+0
		sta	byte_6C0,y
		iny
		lda	byte_6C0,y
		adc	basic_ptr_1+1
		sta	byte_6C0,y
		iny
		bne	loc_A9D0

loc_A9F3:				
					
		ldx	#0
		ldy	unk_503
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		lda	line_was_truncated
		beq	locret_AA05
		lda	#36     ;Line has been truncated
		jmp	raise_error

locret_AA05:				
		rts
                .pend

;-------------------------------------------------------------------------

sub_AA06:				
		lda	byte_6B3
		pha
		jsr	sub_A8C0
		pla
		bne	sub_AA17
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		cpx	byte_2D
		beq	locret_AA40
; End of function sub_AA06




sub_AA17:				
		lda	screen_chars_in_line+0
		pha
		lda	screen_chars_in_line+1
		pha
		jsr	sub_A069
		pla
		tax
		pla
		cpx	screen_chars_in_line+1
		bne	loc_AA2E
		cmp	screen_chars_in_line+0
		bne	loc_AA2E
		jmp	sub_9F00

loc_AA2E:				
		lda	byte_3B
		pha
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		sec
		jsr	sub_9DEA
		pla
		sta	byte_3B

locret_AA40:				
		rts
; End of function sub_AA17


loc_AA41:				
		jsr	sub_AA47
		jmp	loc_9DA8



sub_AA47:				
		lda	#$FF
		sta	unk_2E

loc_AA4B:				
		jsr	detokenize_one_line
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		txa			; A = line height
		clc
		adc	unk_2E		; Add to current coordinate
		cmp	text_window_bottom_y	; Reached height of screen?
		beq	loc_AA5C	; taken	if reached screen height exactly
		bcs	loc_AA71	; taken	if gone	past screen height

loc_AA5C:				
		sta	unk_2E		; store	coordinate
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		bne	loc_AA4B

loc_AA71:				
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		jmp	save_line_number ; saves line number from program.
; End of function sub_AA47		;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number


; swap byte_2B with unk_2F, swap byte_2C with unk_30

sub_AA77:				
					
		ldx	byte_2B
		ldy	unk_2F
		stx	unk_2F
		sty	byte_2B
		ldx	byte_2C
		ldy	unk_30
		stx	unk_30
		sty	byte_2C
		rts
; End of function sub_AA77


delete_key_command:			
		lda	cursor_offset_msb
		bne	loc_AA97
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		dex
		beq	locret_AACC
		dex
		cpx	byte_400
		bcc	loc_AA9A

loc_AA97:				
		jmp	cursor_left_edit_mode_command

loc_AA9A:				
		ldx	#-1
		stx	ptr0+0
		dex
		stx	ptr1+0
		lda	#1
		jsr	make_space_in_line

loc_AAA6:				
		lda	byte_400
		pha
		dec	byte_400
		ldy	byte_400
		lda	#$20 ; ' '
		sta	$401,y
		dec	cursor_offset	; offset of cursor in detokenized buffer

loc_AAB7:				
		lda	#1
		sta	byte_6B3
		pla
		tax
		ldy	#0
		lda	cursor_offset	; offset of cursor in detokenized buffer
		jsr	sub_A0B1
		jmp	position_edit_mode_cursor

loc_AAC8:				
					
		lda	cursor_offset_msb
		beq	loc_AACD

locret_AACC:				
		rts

loc_AACD:				
		lda	cursor_offset	; offset of cursor in detokenized buffer
		cmp	byte_400
		beq	loc_AAD8
		bcs	locret_AACC
		bcc	loc_AADC

loc_AAD8:				
		inc	cursor_offset	; offset of cursor in detokenized buffer
		bne	loc_AAA6

loc_AADC:				
		ldx	#0
		stx	ptr0+0
		txa
		dex
		stx	ptr1+0
		jsr	make_space_in_line
		inc	cursor_offset	; offset of cursor in detokenized buffer
		bne	loc_AAA6

delete_to_end_of_line_edit_mode_command: .proc
		lda	cursor_offset_msb
		bne	locret_AACC
                
		lda	cursor_offset	; offset of cursor in detokenized buffer
		cmp	byte_400
		beq	loc_AAC8
		bcs	locret_AACC

                .if KEEP_DELETE_LINE_MEMSET
                
		clc
		lda	#1
		adc	cursor_offset	; offset of cursor in detokenized buffer
		sta	ptr0+0
		dec	ptr0+0
		lda	#4
		sta	ptr0+1
		sec
		lda	byte_400
		pha
		sbc	cursor_offset	; offset of cursor in detokenized buffer
		tay
		iny
		ldx	#0

                lda ptr0+0
                sta del_C
                lda ptr0+1
                sta del_D
                lda byte_400
                sta del_400
                stx del_X
                sty del_Y
                
		lda	#$20 ; ' '
		jsr	memset		; Set memory to	value.
					;
					; (ptr0) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.

                .else

                lda byte_400
                pha

                ldx cursor_offset
                lda #' '
delete_loop:
                sta unk_401-1,x
                inx
                cpx byte_400
                bcc delete_loop
                beq delete_loop

                .endif
                                        
		ldx	cursor_offset	; offset of cursor in detokenized buffer
		dex
		stx	byte_400
		jmp	loc_AAB7

                .pend

;-------------------------------------------------------------------------

sub_AB1E:
		lda	screen_chars_in_line+1
		bne	locret_AB2D ;bail if length>=256
		lda	screen_chars_in_line+0
		cmp	cursor_offset	; offset of cursor in detokenized buffer
		beq	loc_AB3C ; taken if update will increase line bounding
                                 ; box
		cmp	byte_400
		beq	loc_AB2E ;taken if eol

locret_AB2D:				
		rts

loc_AB2E:				
		lda	is_insert_mode	; 0=overtype 1=insert
		beq	locret_AB2D     ;bail if overtype
		ldx	byte_400
		lda	unk_401-1,x
		cmp	#' '
		beq	locret_AB2D ;bail if cursor is on a ' '

loc_AB3C:
                ; copy page 4 to page 7
		lda	#>unk_401
		sta	ptr0+1
		lda	#>unk_700
		sta	ptr1+1
		jsr	copy_256_bytes

                
		lda	screen_chars_in_line+0
		pha             ;scil
		lda	current_line_no_msb
		pha             ;clnH scil
		lda	current_line_no_lsb
		pha             ;clnL clnH scil
                
		lda	text_window_bottom_y
		asl
		tax

                ; Is this the bottom line?
		lda	byte_6C0,x
		cmp	byte_2B
		bne	loc_AB6A ;taken if not bottom line
		lda	byte_6C1,x
		cmp	byte_2C
		bne	loc_AB6A ;taken if not bottom line

		lda	#1
		sta	unk_37
		jsr	sub_B8BD

loc_AB6A:				
		clc
		lda	byte_3B
		pha
		adc	byte_2D
		pha
		tay
		ldx	#0
		jsr	gotoxy
                lda	#6
                jsr print_n_spaces
		clc
		lda	screen_chars_in_line+0
		adc	code_area_width
		tax
		lda	#0
		adc	#0
		tay
		clc
		lda	screen_chars_in_line+0
		adc	#1
		jsr	sub_A0B1
		pla
		cmp	text_window_bottom_y
		beq	loc_ABB0
		sta	byte_3B
		inc	byte_3B
		ldy	current_line_no_msb
		ldx	current_line_no_lsb
		inx
		bne	loc_ABA8
		iny
		bmi	loc_ABB0

loc_ABA8:				
		stx	byte_2C
		sty	byte_2B
		sec
		jsr	sub_9DEA

loc_ABB0:				
		pla
		sta	byte_3B
		asl
		tax
		inx
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		clc
		pla
		adc	code_area_width
		sta	screen_chars_in_line+0
		tax
		lda	#0
		adc	#0
		sta	screen_chars_in_line+1
		tay
		jsr	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		sty	byte_2D
		lda	#7
		sta	ptr0+1
		lda	#4
		sta	ptr1+1

copy_256_bytes:
		ldy	#0
		sty	ptr0+0
		sty	ptr1+0
		ldx	#1
		jmp	memmove		; move (maybe overlapping) memory regions.
		                        ;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size

;-------------------------------------------------------------------------
;
; 
rstrip_and_tokenize_line:  .proc
		ldx	byte_400	; check	line length
		beq	at_end		; taken	if line	empty

find_last_non_space_loop:		
		lda	unk_401-1,x
		cmp	#$20 ; ' '
		bne	at_end
		dex
		bne	find_last_non_space_loop

at_end:					
					
		lda	#$D		; CR
		sta	unk_401,x		; store	at end of text
		jsr	tokenize_line
		ldx	#$FF

find_cr:				
		inx
		lda	unk_401,x
		cmp	#$D
		bne	find_cr
		rts
                .pend

;-------------------------------------------------------------------------

loc_AC08:				
		jsr	make_cursor_invisible
		lda	byte_3B
		pha
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		ldx	#-1
		stx	byte_3B
		inx
		stx	byte_2B
		stx	byte_2C

loc_AC1D:				
		inc	byte_3B
		lda	byte_3B
		cmp	text_window_bottom_y
		beq	loc_AC28
		bcs	loc_AC5D

loc_AC28:				
		asl
		tax
		lda	byte_6C0,x
		cmp	byte_2B
		bne	loc_AC38
		lda	byte_6C1,x
		cmp	byte_2C
		beq	loc_AC1D

loc_AC38:				
		lda	byte_6C0,x
		sta	byte_2B
		ldy	byte_6C1,x
		sty	byte_2C
		beq	loc_AC5D
		iny
		bne	loc_AC54
		pla
		tax
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		pha
		txa
		pha
		jmp	loc_AC57

loc_AC54:				
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number

loc_AC57:				
		jsr	redraw_line_number
		jmp	loc_AC1D

loc_AC5D:				
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		pla
		sta	byte_3B
		asl
		tax
		inx
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jmp	position_edit_mode_cursor



execute_edit_mode_command:		
		lda	#$20 ; ' '
		cmp	byte_40		; slot ID 0 empty?
		bne	loc_AC7E	; taken	if slot	not empty
		cmp	byte_46		; slot id 6 empty?
		beq	locret_AC7D	; taken	if slot	empty
		lda	#6		; "Missing line	command"
		bne	execute_edit_mode_command_error

locret_AC7D:				
		rts

loc_AC7E:				
		sta	byte_6B3	; ?byte_6B3=$20
		jsr	sub_A8C0
		lda	byte_40
		cmp	#$60 ; '`'
		bcs	loc_ACA7
		lda	byte_43
		cmp	#$20 ; ' '
		beq	loc_AC94
		lda	#$1A
		bne	execute_edit_mode_command_error

loc_AC94:				
		lda	byte_41
		sta	byte_44
		lda	byte_42
		sta	byte_45
		lda	#$20 ; ' '

loc_AC9E:				
		clc
		adc	byte_40
		sta	current_command_id
		jmp	execute_command	; unk_6BD = command to run

loc_ACA7:				
		cmp	byte_43
		beq	loc_ACD7
		ldy	byte_43
		cpy	#$20 ; ' '
		bne	loc_ACC7
		cmp	#$64 ; 'd'
		beq	loc_ACB9
		lda	#$1F		; "Incomplete line command"
		bne	execute_edit_mode_command_error

loc_ACB9:				
		lda	byte_46
		cmp	#$54 ; 'T'
		beq	loc_ACCC
		cmp	#$45 ; 'E'
		beq	loc_ACCC
		lda	#$1C		; "Invalid delete command"
		bne	execute_edit_mode_command_error

loc_ACC7:				
		lda	#$1B		; "Incompatible	line commands"

execute_edit_mode_command_error:					
					
		jmp	raise_error

loc_ACCC:				
					
		jsr	sub_A2A1
		stx	byte_44
		sty	byte_45
		lda	#$20 ; ' '
		sta	byte_46

loc_ACD7:				
		jsr	sub_AD1A
		lda	byte_46
		cmp	#$20 ; ' '
		beq	loc_AD09
		cmp	#$54 ; 'T'
		beq	loc_AD09
		cmp	#$45 ; 'E'
		beq	loc_AD09
		ldy	byte_48
		ldx	byte_47
		cmp	#$42 ; 'B'
		beq	loc_ACF4
		iny
		bne	loc_ACF4
		inx

loc_ACF4:				
					
		txa
		pha
		ldx	#0
		jsr	sub_AD0E
		pla
		bcc	loc_AD09
		ldx	#3
		jsr	sub_AD0E
		bcs	loc_AD09
		lda	#$1D
		bne	execute_edit_mode_command_error

loc_AD09:				
					
		lda	#0
		jmp	loc_AC9E
; End of function execute_edit_mode_command




sub_AD0E:				
					
		cmp	byte_41,x
		beq	loc_AD13
		rts

loc_AD13:				
		tya
		cmp	byte_42,x
		bne	locret_AD19
		clc

locret_AD19:				
		rts
; End of function sub_AD0E




sub_AD1A:				
					
		ldx	byte_41
		cpx	byte_44
		bcc	locret_AD38
		beq	loc_AD24
		bcs	loc_AD2A

loc_AD24:				
		ldy	byte_42
		cpy	byte_45
		bcc	locret_AD38

loc_AD2A:				
		ldy	byte_44
		stx	byte_44
		sty	byte_41
		ldx	byte_42
		ldy	byte_45
		stx	byte_45
		sty	byte_42

locret_AD38:				
		rts
; End of function sub_AD1A


loc_AD39:				
		lda	byte_46
		cmp	#$20 ; ' '
		bne	loc_AD44
		lda	#$1E
		jmp	raise_error

loc_AD44:				
		lda	byte_46
		pha
		lda	byte_47
		pha
		lda	byte_48
		pha
		jsr	sub_AE78
		lda	byte_6C0
		sta	byte_39
		lda	byte_6C1
		sta	byte_3A
		lda	current_command_id
		cmp	#$6D ; 'm'
		bne	loc_AD74
		ldy	#1
		lda	(byte_39),y
		cmp	byte_41
		beq	loc_AD6D
		bcs	loc_AD87
		bcc	loc_AD74

loc_AD6D:				
		iny
		lda	(byte_39),y
		cmp	byte_42
		bcs	loc_AD87

loc_AD74:				
		ldy	#1
		lda	(byte_39),y
		cmp	byte_47
		bne	loc_AD87
		iny
		lda	(byte_39),y
		cmp	byte_48
		bne	loc_AD87
		lda	byte_46
		cmp	#$42 ; 'B'

loc_AD87:				
		php
		jsr	find_program
		ldx	#3
		jsr	sub_AE93
		ldy	#3
		lda	(byte_2B),y
		ldx	#2
		jsr	sub_AE9E
		ldx	#0
		jsr	sub_AE93
		lda	#0
		tax
		jsr	sub_AE9E
		sec
		lda	unk_37
		sbc	byte_35
		sta	basic_ptr_1+0
		lda	byte_38
		sbc	byte_36
		sta	basic_ptr_1+1
		pla
		tay
		pla
		sta	byte_48
		pla
		sta	byte_47
		pla
		sta	byte_46
		tya
		pha
		jsr	check_for_room
		sta	unk_34
		stx	unk_33
		jsr	sub_AE78
		ldx	#6
		jsr	sub_AE93
		lda	byte_46
		cmp	#$42 ; 'B'
		bne	loc_ADDA
		jsr	sub_AEAA
		lda	#0
		beq	loc_ADE3

loc_ADDA:				
		sta	unk_32
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		ldy	#3
		lda	(byte_2B),y

loc_ADE3:				
		ldx	#4
		jsr	sub_AE9E
		lda	byte_3A
		cmp	byte_36
		beq	loc_ADF2
		bcs	loc_AE0D
		bcc	loc_ADFA

loc_ADF2:				
		lda	byte_39
		cmp	byte_35
		beq	loc_ADFA
		bcs	loc_AE0D

loc_ADFA:				
		ldx	#2

loc_ADFC:				
		clc
		lda	basic_ptr_1+0
		adc	byte_35,x
		sta	byte_35,x
		lda	basic_ptr_1+1
		adc	byte_36,x
		sta	byte_36,x
		dex
		dex
		bpl	loc_ADFC

loc_AE0D:				
		clc
		lda	byte_39
		sta	ptr0+0
		adc	basic_ptr_1+0
		sta	ptr1+0
		lda	byte_3A
		sta	ptr0+1
		adc	basic_ptr_1+1
		sta	ptr1+1
		sec
		lda	TOP
		sbc	byte_39
		tay
		lda	TOP+1
		sbc	byte_3A
		tax
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		lda	byte_35
		sta	ptr0+0
		lda	byte_36
		sta	ptr0+1
		lda	byte_39
		sta	ptr1+0
		lda	byte_3A
		sta	ptr1+1
		ldx	basic_ptr_1+1
		ldy	basic_ptr_1+0
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		lda	current_command_id
		cmp	#$6D ; 'm'
		bne	loc_AE68
		lda	unk_37
		sta	ptr0+0
		lda	byte_38
		sta	ptr0+1
		lda	byte_35
		sta	ptr1+0
		lda	byte_36
		sta	ptr1+1
		sec
		lda	unk_33
		sbc	unk_37
		tay
		lda	unk_34
		sbc	byte_38
		tax
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_AE68:				
		jsr	clear_line_commands
		jsr	sub_8492
		lda	unk_32
		bne	loc_AE75
		jsr	sub_8314

loc_AE75:				
		jmp	loc_AF48



sub_AE78:				
		ldx	#$42 ; 'B'
		lda	byte_46
		cmp	#$54 ; 'T'
		beq	loc_AE86
		cmp	#$45 ; 'E'
		bne	locret_AE92
		ldx	#$41 ; 'A'

loc_AE86:				
		txa
		pha
		jsr	sub_A2A1
		stx	byte_47
		sty	byte_48
		pla
		sta	byte_46

locret_AE92:				
		rts
; End of function sub_AE78




sub_AE93:				
		ldy	byte_41,x
		sty	byte_2B
		ldy	byte_42,x
		sty	byte_2C
		jmp	find_line_by_number ; finds a line, given a line number
; End of function sub_AE93		;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line



sub_AE9E:				
		clc
		adc	byte_2B
		sta	byte_35,x
		lda	#0
		adc	byte_2C
		sta	byte_36,x

locret_AEA9:				
		rts
; End of function sub_AE9E




sub_AEAA:				
		lda	unk_30
		sta	unk_32
		beq	locret_AEA9
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jmp	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
; End of function sub_AEAA


loc_AEB9:				
		lda	byte_46
		cmp	#$20 ; ' '
		beq	loc_AEC4
		lda	#$1C
		jmp	raise_error

loc_AEC4:				
		lda	marked_line_no_msb
		cmp	byte_41
		bcc	loc_AEE3
		lda	marked_line_no_lsb
		cmp	byte_42
		bcc	loc_AEE3
		lda	marked_line_no_msb
		cmp	byte_44
		bcc	loc_AEE0
		bne	loc_AEE3
		lda	marked_line_no_lsb
		cmp	byte_45
		beq	loc_AEE0
		bcs	loc_AEE3

loc_AEE0:				
		jsr	sub_B358

loc_AEE3:				
		lda	byte_6C0
		sta	byte_39
		lda	byte_6C1
		sta	byte_3A
		ldy	#1
		lda	(byte_39),y
		cmp	byte_41
		beq	loc_AEF8
		jmp	loc_AEFD

loc_AEF8:				
		iny
		lda	(byte_39),y
		cmp	byte_42

loc_AEFD:				
		php
		jsr	find_program
		ldx	#3
		jsr	sub_AE93
		ldy	#3
		lda	(byte_2B),y
		ldx	#2
		jsr	sub_AE9E
		ldx	#0
		jsr	sub_AE93
		jsr	sub_AEAA
		lda	unk_37
		sta	ptr0+0
		lda	byte_38
		sta	ptr0+1
		lda	byte_2B
		sta	ptr1+0
		lda	byte_2C
		sta	ptr1+1
		sec
		lda	TOP
		sbc	unk_37
		tay
		lda	TOP+1
		sbc	byte_38
		tax
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_AF3D
		jmp	loc_9DA8

loc_AF3D:				
		jsr	clear_line_commands
		lda	unk_32
		bne	loc_AF48
		pla
		jmp	top_edit_mode_command

loc_AF48:				
		plp
		bcc	loc_AF4E
		jmp	loc_9DA8

loc_AF4E:				
		jmp	loc_967A

return_key_command:			
		lda	#0
		pha

loc_AF54:				
		lda	byte_3B
		asl
		tax
		inx
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented

loc_AF5C:				
		jsr	advance_2b_to_next_line
		ldy	#2
		lda	(byte_2B),y
		sta	byte_38
		dey
		lda	(byte_2B),y
		sta	unk_37
		bpl	loc_AF70
		lda	#$A
		bne	loc_AF72

loc_AF70:				
		lda	#1

loc_AF72:				
		tay
		clc
		adc	current_line_no_lsb
		sta	byte_3A
		lda	#0
		adc	current_line_no_msb
		sta	byte_39
		bpl	loc_AF8C
		dey
		bne	loc_AF70

loc_AF83:				
		jsr	sub_8492
		pla
		lda	#1
		pha
		bne	loc_AF54

loc_AF8C:				
		ldx	byte_39
		ldy	byte_3A
		cpx	unk_37
		bne	loc_AF9A
		cpy	byte_38
		bne	loc_AF9A
		beq	loc_AF83

loc_AF9A:				
		pla
		sta	byte_36
		txa
		pha
		tya
		pha
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	byte_36
		pha
		stx	current_line_no_msb
		sty	current_line_no_lsb
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		lda	#1
		sta	byte_400
		lda	#$20 ; ' '
		sta	unk_401

loc_AFBB:				
		stx	byte_36
		lda	byte_6B3
		pha
		lda	#1
		sta	byte_6B3
		lda	#-1
		sta	byte_2C
		lda	#1
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		jsr	sub_A8C0
		lda	#2
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		pla
		sta	byte_6B3
		pla
		beq	loc_AFE9
		cmp	#1
		beq	loc_B03B
		cmp	#3
		bne	loc_B01B
		jmp	end_edit_mode_command

loc_AFE9:				
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		txa
		clc
		adc	byte_3B
		adc	byte_36
		sec
		sbc	#1
		cmp	text_window_bottom_y
		beq	loc_B025
		bcc	loc_B025
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		pla
		pla
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line

loc_B00D:				
		lda	is_scroll_on	; 1=scroll, 0=noscroll
		pha
		lda	#1
		sta	is_scroll_on	; 1=scroll, 0=noscroll
		jsr	move_to_next_line_edit_mode_command
		pla
		sta	is_scroll_on	; 1=scroll, 0=noscroll
		rts

loc_B01B:				
		jsr	cls_and_reset_6c0_to_6ff
		lda	#0
		sta	byte_3B
		clc
		bcc	loc_B026

loc_B025:				
		sec

loc_B026:				
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	sub_9DEA
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jsr	sub_9FD8
		jmp	edit_mode_loop

loc_B03B:				
		pla
		pla
		pla
		tax
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		pha
		txa
		pha
		jsr	sub_9698
		bcs	loc_B05C

loc_B04C:				
		jsr	sub_9706
		sec
		jsr	sub_9DEA
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		jmp	sub_9FD8

loc_B05C:				
		jsr	sub_AA47
		lda	byte_2B
		sta	byte_6C0
		lda	byte_2C
		sta	byte_6C1
		jmp	loc_B04C

it_cmd:					
		jsr	sub_B0A3
		ldy	#1
		lda	(oshwm),y
		bne	loc_B07F
		iny
		lda	(oshwm),y
		cmp	#2
		bcs	loc_B07F
		jsr	sub_8492

loc_B07F:				
		lda	#2
		pha
		ldx	#0
		ldy	#1
		stx	current_line_no_msb
		sty	current_line_no_lsb
		jmp	loc_AF9A

ie_cmd:					
		jsr	sub_B0A3
		lda	#3
		pha
		lda	#-1
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jmp	loc_AF5C



sub_B0A3:				
		jsr	is_program_empty ; sets	C if no	program
		bcs	loc_B0A9
		rts

loc_B0A9:				
		jmp	loc_9DA8
; End of function sub_B0A3




tokenize_line: .proc
		tsx
		stx	old_stack_ptr
		lda	#<unk_401
		sta	basic_ptr_1+0
		lda	#>unk_401
		sta	basic_ptr_1+1
		jmp	sub_B196
                .pend



; Remove bytes from current line and replace them with a new value.
;
; A = replacement byte.
; Y = number of bytes to remove - 1
; (basic_ptr_1) points to where to remove them from.
                
sub_B0BB: .proc
					
		pha             ;save original A

                ; (basic_ptr_0) is source pointer: (basic_ptr_1)+Y
		clc            
		tya             
		adc	basic_ptr_1+0 
		sta	basic_ptr_0+0 
		ldy	#0      
		tya             
		adc	basic_ptr_1+1
		sta	basic_ptr_0+1
		pla
                
                ; store original A in program
		sta	(basic_ptr_1),y

                ; keep moving bytes from source to dest until eol.
loc_B0CC:				
		iny
		lda	(basic_ptr_0),y
		sta	(basic_ptr_1),y
		cmp	#$D
		bne	loc_B0CC
                
		rts
                .pend




sub_B0D6: .proc
		and	#$F     ;turn ASCII digit into its value
		sta	byte_21 ;save in LSB
		sty	byte_22 ;Y=0 on entry here... it's only called
                                ;from one place

loc_B0DC:				
		iny                 ;next byte
		lda	(basic_ptr_1),Y ;get next byte from input
		cmp	#'9'+1      ;is it a digit?
		bcs	loc_B119    ;taken if not a digit
		cmp	#'0'        ;is it a digit?
		bcc	loc_B119    ;taken if not a digit
		and	#$F         ;turn it ints its digit value
		pha                 ;save
		ldx	byte_22     ;
                
                ; shift value left 2, bailing out if negative.
		lda	byte_21     
		asl                 
		rol	byte_22     
		bmi	loc_B114    
		asl                 
		rol	byte_22     
		bmi	loc_B114
                
                ; add original value, giving value*5. 
		adc	byte_21 ;carry clear at this point...
		sta	byte_21     
		txa
		adc	byte_22

                ; shift value left 1, giving value*10, bailing out if
                ; negative or carry.
		asl	byte_21
		rol
		bmi	loc_B114
		bcs	loc_B114
		sta	byte_22

                ; add new digit in.
		pla            
		adc	byte_21 ;carry clear at this point...
		sta	byte_21
		bcc	loc_B0DC
		inc	byte_22
		bpl	loc_B0DC
		pha

loc_B114:				
		pla
		ldy	#0      ;restore Y value
		sec             ;
		rts
                .pend

loc_B119:				
		jsr	ensure_4_bytes_spare
		dey
		lda	#LINE_NUMBER_TOKEN
		jsr	sub_B0BB
		lda	basic_ptr_1+0
		adc	#2
		sta	basic_ptr_0+0
		lda	basic_ptr_1+1
		adc	#0
		sta	basic_ptr_0+1

loc_B12E:				
		lda	(basic_ptr_1),y
		sta	(basic_ptr_0),y
		dey
		bne	loc_B12E
		ldy	#3
		lda	byte_22
		ora	#$40 ; '@'
		sta	(basic_ptr_1),y
		dey
		lda	byte_21
		and	#$3F ; '?'
		ora	#$40 ; '@'
		sta	(basic_ptr_1),y
		dey
		lda	byte_21
		and	#-$40 ;	'�'
		sta	byte_21
		lda	byte_22
		and	#-$40 ;	'�'
		lsr
		lsr
		ora	byte_21
		lsr
		lsr
		eor	#$54 ; 'T'
		sta	(basic_ptr_1),y
		jsr	increment_27
		jsr	increment_27
		jsr	increment_27
		ldy	#0

clc_then_rts:				
		clc
		rts
; End of function sub_B0D6



; sets C if:
;
; A>='a'&&A<='z'
; A=='_'
; A==GBP
; A>='A'&&A<='Z'
; A>='0'&&A<='9'

issymchar: .proc
		cmp	#'z'+1
		bcs	clc_then_rts
                cmp	#'_' ;cover '_' (0x5f), GBP (0x60) and lower-case
                             ;letters (0x61...)
		bcs	isdigit.done
		cmp	#'Z'+1
		bcs	clc_then_rts
		cmp	#'A'
		bcs	isdigit.done
                ; fall through
                .pend



; sets C if A is a digit char

isdigit:.proc			
		cmp	#'9'+1
		bcs	clc_then_rts
		cmp	#'0'

done:
		rts
                .pend
; End of function isdigit



; sets C if A is a number char (0-9 or '.')

isnumchar:				
		cmp	#'.'
		bne	isdigit		; sets C if A is a digit char
		rts
; End of function isnumchar

		.byte  $B1 ; �
		.byte  $27 ; '



increment_27:				
		jsr	ensure_1_byte_spare
		inc	basic_ptr_1+0
		bne	isdigit.done
		inc	basic_ptr_1+1
		rts
; End of function increment_27




fetch_next_byte:			
		jsr	increment_27
		lda	(basic_ptr_1),y
		rts
; End of function fetch_next_byte




; (basic_ptr_1) always points to unk_401 - the input buffer.
sub_B196: .proc
		ldy	#0
		sty	byte_23
		sty	byte_24

sub_B196_scan_line:				
		lda	(basic_ptr_1),y   ;get byte from input
		cmp	#$D           ;end of line?
		beq	isdigit.done   ;taken if end of line
		cmp	#' '          ;
		bne	check_for_hex ;taken if not space

next_input_byte:				
		jsr	increment_27       ;next byte in input
		bne	sub_B196_scan_line ;JMP, in effect

check_for_hex:				
		cmp	#'&'             ;hex value?
		bne	check_for_string ;taken if not a hex value
                ; handle hex value
check_hex_value:			
		jsr	fetch_next_byte ;get byte from input
		jsr	isdigit		;sets C if A is a digit char
		bcs	check_hex_value ;taken if digit - i.e., good
                                        ;hex char
		cmp	#'A'            ;
		bcc	sub_B196_scan_line ;taken if A<'A' - i.e., bad
                                           ;hex char
		cmp	#'F'+1             ;
		bcc	check_hex_value ;taken if A>='A' && A<='F' -
                                        ;i.e., good hex char
		bcs	sub_B196_scan_line ;taken if bad hex char

check_for_string:			
		cmp	#'"'
		bne	check_for_colon ;taken if not string
                ; handle string
loc_B1C5:				
		jsr	fetch_next_byte ;get byte from input
		cmp	#'"'            ;
		beq	next_input_byte       ;taken if end of string
		cmp	#$D             ;end of line?
		bne	loc_B1C5        ;taken if not end of line
		rts                     ;...

check_for_colon:			
		cmp	#':'
		bne	check_for_comma ;taken if not colon
                ; handle colon
		sty	byte_23         ;reset
		sty	byte_24         ;reset
		beq	next_input_byte       ;JMP, in effect

check_for_comma:			
		cmp	#','      ;
		beq	next_input_byte ;taken if comma
		cmp	#'*'      ;
		bne	check_for_dot ;taken if not *
                ; handle * operator or * command
		lda	byte_23
		bne	loc_B228 ;taken if the * was on the RHS - so
                                 ;it's the * operator, not a * command

                ; stop tokenizing on * command.
		rts

check_for_dot:				
		cmp	#'.'
		beq	got_dot  ;taken if dot
		jsr	isdigit  ;sets C if A is a digit char
		bcc	check_for_token ;taken if not digit char
                ; handle digit char
		ldx	byte_24  ;
		beq	got_dot  ;taken if at start of statement
		jsr	sub_B0D6 ;
		bcc	loc_B22E ;but sub_B0D6 always leaves with
                                 ;carry set...?

got_dot:				
		lda	(basic_ptr_1),y
		jsr	isnumchar	;sets C if A is a number char (0-9 or '.')
		bcc	loc_B207        ;taken if not number char
		jsr	increment_27    ;next input byte
		jmp	got_dot         ;loop

loc_B207:				
		ldx	#255
		stx	byte_23 ;now on RHS
		sty	byte_24 ;not start of statement
		jmp	sub_B196_scan_line

loc_B210:				
		jsr	issymchar	; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	�)
		bcc	loc_B228        ;taken if not valid symbol char

loc_B215:				
		ldy	#0

loc_B217:
                ; find next non-symbol char
		lda	(basic_ptr_1),y
		jsr	issymchar	;sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	�)
		bcc	loc_B207        ;taken if not valid symbol char
		jsr	increment_27    ;next input char
		jmp	loc_B217        ;

check_for_token:				
		cmp	#'A'
		bcs	check_for_token_2

loc_B228:				
		ldx	#255
		stx	byte_23
		sty	byte_24

loc_B22E:				
		jmp	next_input_byte

check_for_token_2:
		cmp	#'X'
		bcs	loc_B210 ; bail if >=X, since no tokens start
                                 ; with X, Y or Z
		ldx	#<token_table
		stx	basic_ptr_0+0
		ldx	#>token_table
		stx	basic_ptr_0+1

loc_B23D:				
		cmp	(basic_ptr_0),y	; compare first char to char
                                        ; in table
		bcc	loc_B217	; taken if A<char in table -
                                        ; the tokens are sorted at
                                        ; least by first char, so if
                                        ; it wasn't found by now, it
                                        ; won't be
		bne	find_token_byte	; taken if first char is
                                        ; otherwise different

compare_chars_loop:
		iny			; next char
		lda	(basic_ptr_0),y	; get next char	from table
		bmi	found_token	; taken	if token value found
		cmp	(basic_ptr_1),y	; compare to byte in input
		beq	compare_chars_loop

                ; input differs - is it abbreviated?
		lda	(basic_ptr_1),y	; get byte from	input
		cmp	#'.'            ; is it an abbreviation?
		beq	skip_dot	; taken	if abbreviated

find_token_byte:			
		iny
		lda	(basic_ptr_0),y
		bpl	find_token_byte

                ; after token $FE come the LHS tokens for PAGE, PTR,
                ; TIME, LOMEM and HIMEM.
		cmp	#$FE		; reached WIDTH	in the table?
		bne	next_token_in_table ; taken if not WIDTH
		bcs	loc_B215	; taken if WIDTH... though why
                                        ; not BEQ?

skip_dot:				
		iny

find_token_end:				
		lda	(basic_ptr_0),y
		bmi	found_token ;found the token number
                ; add 1 to address
		inc	basic_ptr_0+0
		bne	find_token_end
		inc	basic_ptr_0+1
		bne	find_token_end

next_token_in_table:
                ; add Y+2 to (basic_ptr_0) - skip token byte and flags
                ; byte.
		sec             
		iny             
		tya
		adc	basic_ptr_0+0
		sta	basic_ptr_0+0
		bcc	loc_B275
		inc	basic_ptr_0+1

loc_B275:		
		ldy	#0          ;reset Y
		lda	(basic_ptr_1),y ;restore input byte
		jmp	loc_B23D    ;back to the tokenization
                                    ;process...

found_token:				
		tax                 ;store token number
		iny                 ;next table byte
		lda	(basic_ptr_0),y ;get flags
		sta	byte_21     ;
		dey                 ;restore Y
		lsr                 ;get bit 0
		bcc	is_token    ;taken if flags bit 0 clear - this
                                    ;is definitely a token

                ; check if this is actually a variable name
		lda	(basic_ptr_1),y ;get input byte
		jsr	issymchar ; sets C if A is a valid symbol char
                                  ; (A-Z, a-z, 0-9, _, �)
		bcs	loc_B215  ;taken if valid symbol char - this
                                  ;is the prefix of a variable name,
                                  ;not a token

is_token:				
		txa              ;get token value
		bit	byte_21  ;test flags byte
		bvc	loc_B299 ;taken if flags byte bit 6 clear

                ; swap from RHS to LHS token for PAGE, PTR, TIME,
                ; LOMEM or HIMEM.
		ldx	byte_23  ;test expression side
		bne	loc_B299 ;taken if on RHS
		clc              ;
		adc	#$40     ;swap token

loc_B299:				
		dey              ;count of chars to replace
		jsr	sub_B0BB ;replace chars with the token
		ldy	#0       ;
		ldx	#255     ;
		lda	byte_21  ;get flags byte
		lsr              ;C = flags bit 0
		lsr              ;C = flags bit 1
		bcc	loc_B2AB ;taken if bit 1 clear
                ; set tokenizing flags
		stx	byte_23  ;set the RHS flag
		sty	byte_24

loc_B2AB:				
		lsr              ;C = flags bit 2
		bcc	loc_B2B2 ;taken if bit 2 clear
                ; reset tokenizing flags
		sty	byte_23
		sty	byte_24

loc_B2B2:				
		lsr              ;C=flags bit 3
		bcc	loc_B2C6 ;taken if bit 3 clear
                ; scan PROC/FN name
		pha              ;save remaining bits
		iny              ;Y=1

PROC_or_FN_name:				
		lda	(basic_ptr_1),y ;get next input byte
		jsr	issymchar ; sets C if A is a valid symbol char
                                  ; (A-Z, a-z, 0-9, _, �)
		bcc	PROC_or_FN_name_done  ;taken if not a valid symbol char
		jsr	increment_27 ;next input byte
		jmp	PROC_or_FN_name     ;keep going

PROC_or_FN_name_done:				
		dey             ;ignore the terminating char
		pla             ;get flags back again...

loc_B2C6:				
		lsr              ;C=flags bit 4
		bcc	loc_B2CB ;taken if bit 4 clear
		stx	byte_24

loc_B2CB:				
		lsr                 ;C=flags bit 5
		bcs	stop_tokenizing ;taken if bit 5 set
		jmp	next_input_byte

stop_tokenizing:				
		rts
                .pend




ensure_1_byte_spare:			
		php
		pha
		lda	#1
		bne	loc_B2DC	; JMP, in effect
; End of function ensure_1_byte_spare




ensure_4_bytes_spare:			
		php
		pha
		lda	#4

loc_B2DC:				
		clc
		adc	basic_ptr_1+0
		bcs	longjmp ;taken if carry - which means
                                ;definitely no space
		cmp	#256-4
		beq	loc_B2E7 ;taken if it just fits
		bcs	longjmp  ;taken if it doesn't fit

loc_B2E7:				
		pla
		plp
		rts

longjmp:				
					
		ldy	#0
		lda	#$D
		sta	(basic_ptr_1),y
		sta	line_was_truncated
		ldx	old_stack_ptr
		txs
		rts
; End of function ensure_4_bytes_spare




mode_command:				
                ldy input_ptr+0
                cpy #$ff
                beq loc_B2FF
                ldy input_ptr+1
		beq	loc_B304

loc_B2FF:				
                ; TODO: can get rid of this bit???
					
		lda	#$D		; "Only	modes 0,1,3,4,6,7 are valid"
		jmp	raise_error

loc_B304:				
		ldx	input_ptr+0
		jsr	get_HIMEM_for_mode_X
		jsr	find_program
		ldx	last_error_number
		beq	locret_B329
		jsr	clear_error_message_buffer
		lda	#$E		; "No room for this mode"
		jmp	raise_error

locret_B329:
                ldy input_ptr+0
                ; fall through to set_mode
; Y = mode
set_mode:
                lda #22
                jsr oswrch
                tya
                jsr oswrch
                jmp set_palette

; mode_edit_mode_command:			
;                 LDY	screen_mode
                

; loc_B32C:				
; 		DEY
; 		CPY	#2
; 		BEQ	loc_B32C
; 		CPY	#5
; 		BEQ	loc_B32C
; 		CPY	#-1
; 		BNE	loc_B33B
; 		LDY	#7

; loc_B33B:				
; 		STY	screen_mode
; 		JSR	validate_mode
; 		JSR	find_program
; 		LDA	last_error_number
; 		BEQ	loc_B34A
; 		JMP	language_entry.loc_814D

; loc_B34A:				
; 		JSR	loc_9D2D
; 		JSR	is_program_empty ; sets	C if no	program
; 		BCS	loc_B355
; 		JMP	loc_967A

; loc_B355:				
; 		JMP	loc_9DA8



sub_B358:				
					
		lda	#$FF
		sta	marked_line_no_msb
		rts
; End of function sub_B358




mark_edit_mode_command:			
					
		lda	current_line_no_msb
		sta	marked_line_no_msb
		lda	current_line_no_lsb
		sta	marked_line_no_lsb
		jmp	loc_AC08
; End of function mark_edit_mode_command




goto_edit_mode_command:			
					
		jsr	sub_B37B
		beq	loc_B370
		jmp	beep

loc_B370:				
					
		lda	marked_line_no_msb
		sta	current_line_no_msb
		lda	marked_line_no_lsb
		sta	current_line_no_lsb
		jmp	loc_9DA8
; End of function goto_edit_mode_command




sub_B37B:				
					
		lda	marked_line_no_msb
		cmp	#-1
		bne	loc_B384
		lda	#1
		rts

loc_B384:				
		sta	byte_2B
		lda	marked_line_no_lsb
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		ldy	#1
		lda	(byte_2B),y
		cmp	marked_line_no_msb
		bne	locret_B39A
		iny
		lda	(byte_2B),y
		cmp	marked_line_no_lsb

locret_B39A:				
		rts
; End of function sub_B37B


goto_command:				
		jsr	sub_B37B
		bne	raise_no_marked_line_error
		jsr	init_edit_mode
		jmp	loc_B370

raise_no_marked_line_error:
		lda	#34     ;No marked line
		jmp	raise_error

number_command:				
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	#0
		sta	unk_1E
		sta	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_B3BB:				
		ldy	#1
		lda	(byte_2B),y
		bpl	loc_B3DB
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		lda	unk_1E
		and	#1
		beq	loc_B3D2
		lda	#$10

loc_B3CF:				
		jmp	raise_error

loc_B3D2:				
		lda	unk_1E
		bne	locret_B3DA
		lda	#$F     ;"No references to labels were found"?
		bne	loc_B3CF

locret_B3DA:				
		rts

loc_B3DB:				
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	byte_2B
		sta	ptr0+0
		lda	byte_2C
		sta	ptr0+1
		lda	#0
		sta	ptr1+0
		lda	#5
		sta	ptr1+1
		ldx	#0
		ldy	#3
		lda	(byte_2B),y
		tay
		iny
		bne	loc_B3F9
		inx

loc_B3F9:				
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		ldx	#0
		stx	cursor_offset_msb
		stx	unk_37
		stx	byte_36
		stx	byte_6B3
		inx
		stx	cursor_offset	; offset of cursor in detokenized buffer
		lda	#4
		sta	unk_1F
		lda	#5
		sta	byte_20

loc_B412:				
		sec
		lda	unk_503
		sbc	#4
		cmp	cursor_offset	; offset of cursor in detokenized buffer
		bcc	loc_B476
		ldy	#0
		lda	(unk_1F),y
		cmp	#$20 ; ' '
		beq	loc_B461
		cmp	#$22 ; '"'
		bne	loc_B430
		sta	byte_36
		lda	unk_37
		eor	#1
		sta	unk_37

loc_B430:				
		lda	unk_37
		bne	loc_B461
		lda	(unk_1F),y
		cmp	#$f4 ;-$C ; '�' REM
		beq	loc_B476
		cmp	#$DC ; -$24 ;	'�' DATA
		beq	loc_B476
		cmp	#$2A ; '*'
		bne	loc_B446
		ldx	byte_36
		beq	loc_B476

loc_B446:				
		cmp	#$3A ; ':'
		bne	loc_B44E
		sty	byte_36
		beq	loc_B461

loc_B44E:				
		ldx	#1
		stx	byte_36
		cmp	#$8D ; -$73 ;	'�' line number
		bne	loc_B45A
		ldx	#4
		bne	loc_B463

loc_B45A:				
		cmp	#$40 ; '@'
		bne	loc_B461
		jmp	loc_B4B7

loc_B461:				
		ldx	#1

loc_B463:				
		clc
		txa
		adc	unk_1F
		sta	unk_1F
		bcc	loc_B46D
		inc	byte_20

loc_B46D:				
		clc
		txa
		adc	cursor_offset	; offset of cursor in detokenized buffer
		sta	cursor_offset	; offset of cursor in detokenized buffer
		jmp	loc_B412

loc_B476:				
		lda	byte_6B3
		beq	loc_B47E
		jsr	sub_B4A7

loc_B47E:				
		jsr	advance_2b_to_next_line
		jmp	loc_B3BB



sub_B484:				
		cmp	#'0'
		bcc	loc_B49C
		cmp	#':'
		bcc	loc_B49E
		cmp	#'A'
		bcc	loc_B49C
		cmp	#'['
		bcc	loc_B49E
		cmp	#'_'
		bcc	loc_B49C
		cmp	#'{'
		bcc	loc_B49E

loc_B49C:				
		clc
		rts

loc_B49E:				
		sec
		rts
; End of function sub_B484




sub_B4A0:				
		ldy	#1
		lda	(ptr0),y
		jmp	sub_B484
; End of function sub_B4A0


;-------------------------------------------------------------------------

sub_B4A7: .block
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		jsr	sub_a8c0.loc_A8FF
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		rts
                .bend

;-------------------------------------------------------------------------

loc_B4B7: .proc
		lda	unk_1F
		sta	ptr0+0
		lda	byte_20
		sta	ptr0+1
		jsr	sub_B4A0
		bcs	loc_B4C7

loc_B4C4:				
		jmp	loc_B461

loc_B4C7:				
		lda	#0
		sta	unk_33
		lda	oshwm+1
		sta	unk_34

loc_B4CF:				
		ldy	#1
		lda	(unk_33),y
		bpl	loc_B4DD
		lda	unk_1E
		ora	#1
		sta	unk_1E
		bne	loc_B4C4

loc_B4DD:				
		lda	unk_33
		pha
		lda	unk_34
		pha
		ldy	#4

loc_B4E5:				
		lda	(unk_33),y
		cmp	#$20 ; ' '
		bne	loc_B4EF
		iny
		jmp	loc_B4E5

loc_B4EF:				
		cmp	#$F4 ; -$C ; '�'
		bne	loc_B52F
		iny

loc_B4F4:				
		lda	(unk_33),y
		cmp	#$20 ; ' '
		bne	loc_B4FE
		iny
		jmp	loc_B4F4

loc_B4FE:				
		clc
		tya
		adc	unk_33
		sta	unk_33
		bcc	loc_B508
		inc	unk_34

loc_B508:				
		ldy	#0
		lda	(unk_33),y
		cmp	#$40 ; '@'
		beq	loc_B512
		bne	loc_B52F

loc_B512:				
		iny

loc_B513:				
		lda	(unk_33),y
		cmp	(unk_1F),y
		bne	loc_B521
		jsr	sub_B484
		bcc	loc_B532
		iny
		bne	loc_B513

loc_B521:				
		jsr	sub_B484
		bcs	loc_B52F
		lda	(unk_1F),y
		jsr	sub_B484
		bcs	loc_B52F
		bcc	loc_B532

loc_B52F:				
		clc
		bcc	loc_B533

loc_B532:				
		sec

loc_B533:				
		pla
		sta	unk_34
		pla
		sta	unk_33
		bcs	loc_B53E
		jmp	loc_B5A3

loc_B53E:				
		sty	byte_35
		lda	unk_503
		sec
		sbc	byte_35
		clc
		adc	#4
		bcs	loc_B59E
		sta	unk_503
		clc
		lda	unk_1F
		adc	byte_35
		sta	ptr0+0
		lda	byte_20
		sta	ptr0+1
		sta	ptr1+1
		clc
		lda	unk_1F
		adc	#4
		sta	ptr1+0
		sec
		lda	unk_503
		sbc	cursor_offset	
		sec
		sbc	#6
		tay
		ldx	#0
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		ldy	#1
		lda	(unk_33),y
		tax
		iny
		lda	(unk_33),y
		tay
		jsr	sub_85D8
		pha
		tya
		ldy	#3
		sta	(unk_1F),y
		dey
		txa
		sta	(unk_1F),y
		dey
		pla
		sta	(unk_1F),y
		dey
		lda	#$8d ; -$73 ;	'�'
		sta	(unk_1F),y
		sta	byte_6B3
		lda	unk_1E
		ora	#2
		sta	unk_1E
		ldx	#4
		jmp	loc_B463

loc_B59E:				
		lda	#$11
		jmp	raise_error

loc_B5A3:				
		ldy	#3
		clc
		lda	(unk_33),y
		adc	unk_33
		sta	unk_33
		bcc	loc_B5B0
		inc	unk_34

loc_B5B0:				
		jmp	loc_B4CF

                .pend

;-------------------------------------------------------------------------

label_command:				
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	#0
		sta	unk_1E
		sta	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_B5C3:				
		ldy	#1
		lda	(byte_2B),y
		bmi	loc_B5EC
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	#0
		sta	byte_6B3
		jmp	loc_B65A

loc_B5D4:				
		lda	byte_6B3
		beq	loc_B5DC
		jsr	sub_B4A7

loc_B5DC:				
		ldy	#3
		clc
		lda	(byte_2B),y
		adc	byte_2B
		sta	byte_2B
		bcc	loc_B5E9
		inc	byte_2C

loc_B5E9:				
		jmp	loc_B5C3

loc_B5EC:				
		pla
		sta	current_line_no_lsb
		pla
		sta	current_line_no_msb
		lda	unk_1E
		bne	locret_B5FB
		lda	#$13
		jmp	raise_error

locret_B5FB:				
		rts

;-------------------------------------------------------------------------

label_edit_mode_command: .proc
		lda	#$13
		pha
		lda	#<label_command
		sta	unk_6B1
		lda	#>label_command
		sta	unk_6B2
		bne	loc_B618 ;JMP, in effect
                .pend

;-------------------------------------------------------------------------

number_edit_mode_command: .proc
		lda	#$f     ;"No references to labels were found"
		pha
		lda	#<number_command
		sta	unk_6B1
		lda	#>number_command
		sta	unk_6B2
                ; fall through
                .pend

;-------------------------------------------------------------------------
                
loc_B618: .block 
		jsr	is_program_empty ; sets	C if no	program
		pla
		bcc	loc_B621
		jmp	raise_error

loc_B621:				
		lda	byte_6C0
		sta	byte_39
		lda	byte_6C1
		sta	byte_3A
		ldy	#1
		lda	(byte_39),y
		pha
		iny
		lda	(byte_39),y
		pha
		lda	#1
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		jsr	make_cursor_invisible
		jsr	unk_6B0
		lda	#2
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		lda	byte_2B
		sta	byte_6C0
		lda	byte_2C
		sta	byte_6C1
		jmp	loc_967A

                .bend

;-------------------------------------------------------------------------

loc_B65A: .proc
		lda	byte_2B
		sta	ptr0+0
		lda	byte_2C
		sta	ptr0+1
		lda	#0
		sta	ptr1+0
		lda	#5
		sta	ptr1+1
		ldx	#0
		ldy	#3
		lda	(byte_2B),y
		tay
		iny
		bne	loc_B675
		inx

loc_B675:				
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		ldy	#0
		sty	unk_37
		sty	cursor_offset_msb
		iny
		sty	cursor_offset	; offset of cursor in detokenized buffer
		lda	#4
		sta	unk_1F
		lda	#5
		sta	byte_20

loc_B689:				
		sec
		lda	unk_503
		sbc	#7
		bcc	loc_B695
		cmp	cursor_offset	; offset of cursor in detokenized buffer
		bcs	loc_B698

loc_B695:				
		jmp	loc_B5D4

loc_B698:				
		ldy	#0
		lda	(unk_1F),y
		cmp	#$22 ; '"'
		bne	loc_B6A6
		lda	unk_37
		eor	#1
		sta	unk_37

loc_B6A6:				
		ldx	unk_37
		beq	loc_B6AD

loc_B6AA:				
		jmp	loc_B78C

loc_B6AD:				
		lda	(unk_1F),y
		cmp	#$8d ; -$73 ;	'�'
		bne	loc_B6AA
		lda	unk_1F
		sta	basic_ptr_1+0
		lda	byte_20
		sta	basic_ptr_1+1
		ldy	#0
		jsr	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		lda	byte_21
		sta	byte_2B
		lda	byte_22
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jmp	loc_B6DF

loc_B6D4:				
		pla
		sta	byte_2C
		pla
		sta	byte_2B

loc_B6DA:				
		ldx	#4
		jmp	loc_B78E

loc_B6DF:				
		ldy	#1
		lda	(byte_2B),y
		cmp	byte_21
		bne	loc_B6D4
		iny
		lda	(byte_2B),y
		cmp	byte_22
		bne	loc_B6D4
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		ldy	#4

loc_B6F9:				
		lda	(unk_2F),y
		cmp	#$20 ; ' '
		bne	loc_B703
		iny
		jmp	loc_B6F9

loc_B703:				
		cmp	#$f4 ; REM???
		bne	loc_B6DA
		iny

loc_B708:				
		lda	(unk_2F),y
		cmp	#$20 ; ' '
		bne	loc_B712
		iny
		jmp	loc_B708

loc_B712:				
		cmp	#$40 ; '@'
		bne	loc_B6DA
		ldx	#1
		clc
		tya
		ldy	#0
		adc	unk_2F
		sta	unk_2F
		bcc	loc_B724
		inc	unk_30

loc_B724:				
		iny
		lda	(unk_2F),y
		jsr	sub_B484
		bcc	loc_B72F
		inx
		bne	loc_B724

loc_B72F:				
		cpx	#1
		beq	loc_B6DA
		stx	byte_36
		sec
		lda	unk_503
		sbc	#4
		clc
		adc	byte_36
		bcc	loc_B745
		lda	#$12
		jmp	raise_error

loc_B745:				
		sta	unk_503
		clc
		lda	unk_1F
		adc	#4
		sta	ptr0+0
		lda	byte_20
		sta	ptr0+1
		sta	ptr1+1
		clc
		lda	unk_1F
		adc	byte_36
		sta	ptr1+0
		sec
		lda	unk_503
		sbc	byte_36
		sbc	cursor_offset	; offset of cursor in detokenized buffer
		sbc	#2
		tay
		ldx	#0
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		lda	unk_2F
		sta	ptr0+0
		lda	unk_30
		sta	ptr0+1
		lda	unk_1F
		sta	ptr1+0
		lda	byte_20
		sta	ptr1+1
		ldy	byte_36
		ldx	#0
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		ldx	byte_36
		stx	byte_6B3
		stx	unk_1E
		bne	loc_B78E

loc_B78C:				
		ldx	#1

loc_B78E:				
		txa
		clc
		adc	cursor_offset	; offset of cursor in detokenized buffer
		sta	cursor_offset	; offset of cursor in detokenized buffer
		txa
		clc
		adc	unk_1F
		sta	unk_1F
		bcc	loc_B79E
		inc	byte_20

loc_B79E:				
		jmp	loc_B689
                .pend

;-------------------------------------------------------------------------

sub_B7A1: .proc;move_cursor_to_next_line???
					
		jsr	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		bcc	loc_B7AB
		lda	is_scroll_on	; 1=scroll, 0=noscroll
		bne	loc_B7B7
		rts

loc_B7AB:				
		lda	is_scroll_on	; 1=scroll, 0=noscroll
		bne	loc_B7B2
		jmp	loc_B89A

loc_B7B2:				
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_B7BA

loc_B7B7:				
		jmp	edit_mode_loop

loc_B7BA:				
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		lda	#0
		sta	byte_2B
		sta	byte_2C
		sta	byte_36
		jsr	sub_BA69
		txa
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		tax
		lda	$6BF,x
		cmp	byte_2C
		bne	loc_B7DD
		lda	$6BE,x
		cmp	byte_2B
		bne	loc_B7DD
		inc	byte_36

loc_B7DD:				
		ldy	#3
		clc
		lda	byte_2B
		adc	(byte_2B),y
		sta	ptr0+0
		lda	byte_2C
		adc	#0
		sta	ptr0+1
		ldy	#1
		lda	(ptr0),y
		bmi	loc_B7B7
		lda	byte_2D
		sta	unk_34
		jsr	sub_A8C0
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		stx	unk_37
		stx	byte_35
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		jsr	advance_2b_to_next_line
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line
		jsr	calculate_screen_chars_in_line
		clc
		lda	byte_2D
		adc	unk_37
		adc	byte_3B
		sec
		sbc	#1
		sec
		sbc	text_window_bottom_y
		sta	unk_37
		beq	loc_B826
		bpl	loc_B829

loc_B826:				
		jmp	loc_B82C

loc_B829:				
		jsr	sub_B8BD

loc_B82C:				
		lda	unk_37
		beq	loc_B832
		bpl	loc_B85D

loc_B832:				
		lda	byte_36
		bne	loc_B85D
		lda	byte_6B3
		beq	loc_B852
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line
		ldx	unk_34
		jsr	calculate_screen_chars_in_line.loc_A021 ;just
                                                                ;scale
                                                                ;by X
		jsr	sub_AA17
		jmp	loc_B89D

loc_B852:				
		lda	byte_35
		cmp	unk_34
		bne	loc_B880

loc_B858:				
		pla
		pla
		jmp	loc_B89D

loc_B85D:				
		lda	byte_6B3
		beq	loc_B880
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		lda	byte_3B
		pha
		sec
		jsr	sub_9DEA
		pla
		sta	byte_3B
		jmp	loc_B89D

loc_B880:				
		clc
		lda	byte_3B
		pha
		adc	byte_35
		sta	byte_3B
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		sec
		jsr	sub_9DEA
		pla
		sta	byte_3B
		jmp	loc_B858

loc_B89A:				
		jsr	sub_AA06

loc_B89D:				
		lda	byte_3B
		asl
		tax
		inx
		ldy	byte_6C0,x
		bne	loc_B8AE
		dey
		sty	current_line_no_msb
		sty	current_line_no_lsb
		bne	loc_B8BA

loc_B8AE:				
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		inc	current_line_no_lsb
		bne	loc_B8BA
		inc	current_line_no_msb

loc_B8BA:				
					
		jmp	sub_A069
                .pend


;-------------------------------------------------------------------------
;
; Scroll screen down
;
; Entry:
;
; ?
sub_B8BD: .proc
		sec
		lda	unk_37
		sbc	#1
		asl
		tax
		tay

                ; find index of next screen row with a different line
                ; on it
find_next_line_loop:
		iny
		iny
		lda	byte_6C0,x
		cmp	byte_6C0,y
		bne	found_next_line
		lda	byte_6C1,x
		cmp	byte_6C1,y
		bne	found_next_line
		inc	unk_37  ;inc Y coordinate
		bne	find_next_line_loop

found_next_line:

                ; copy from $6c0+Y to $6c0 - ok to copy up
		clc
		tya
		adc	#<byte_6c0
		sta	ptr0+0  ;src LSB
		lda	#>byte_6c0
		sta	ptr1+1  ;dest MSB
		adc	#0      ;??do we want this??
		sta	ptr0+1  ;src MSB
		lda	#<byte_6c0
		sta	ptr1+0  ;dest LSB

                ; copy (text_window_bottom_y+1-?unk_37)*2
		clc
		lda	text_window_bottom_y
		adc	#1
		sec
		sbc	unk_37
		asl
                
                tax
                beq copy_rows_table_done
                ldy #0
copy_rows_table_loop:
                lda (ptr0),y
                sta (ptr1),y
                iny
                dex
                bne copy_rows_table_loop
copy_rows_table_done:
                                        
		jsr	make_cursor_invisible
		ldx	#0
		ldy	text_window_bottom_y
		sty	byte_6AB
		jsr	gotoxy
		; LDA	#19
		; JSR	OSBYTE
                
		ldy	unk_37  ;number of rows to scroll
		lda	#$A

loc_B914:				
		jsr	OSWRCH
		dey
		bne	loc_B914
		sec
		lda	byte_3B
		sbc	unk_37
		sta	byte_3B
		rts
                .pend


join_statements_edit_mode_command:	
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_B92A

loc_B927:				
		jmp	beep

loc_B92A:				
		ldy	#3
; set (ptr0) to point at next line
		clc
		lda	(byte_2B),y
		adc	byte_2B
		sta	ptr0+0
		lda	byte_2C
		adc	#0
		sta	ptr0+1
		ldy	#1
		lda	(ptr0),y
		bmi	loc_B927	; branch taken if next line is end of program
		jsr	sub_A8C0
		lda	byte_2B
		pha
		lda	byte_2C
		pha
		jsr	advance_2b_to_next_line
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line
		jsr	rstrip_detokenized_line
		lda	byte_400
		sta	unk_700
		beq	loc_B987
		lda	#<unk_401
		sta	ptr0+0
		lda	#>unk_401
		sta	ptr0+1
		ldy	#0

loc_B966:				
		lda	(ptr0),y
		cmp	#' '
		bne	loc_B977
		dec	unk_700
		inc	ptr0+0
		bne	loc_B975
		inc	ptr0+1

loc_B975:				
		bne	loc_B966

loc_B977:				
		lda	#<unk_701
		sta	ptr1+0
		lda	#>unk_701
		sta	ptr1+1
		ldx	#0
		ldy	unk_700
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_B987:				
		pla
		sta	byte_2C
		pla
		sta	byte_2B
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line
		jsr	rstrip_detokenized_line
		lda	unk_700
		beq	loc_B9E5
		clc
		adc	byte_400
		bcs	loc_B9AD
		sta	unk_37
		ldx	byte_400
		beq	loc_B9C4
		clc
		adc	#1
		bcc	loc_B9B2

loc_B9AD:				
		lda	#$14
		jmp	raise_error

loc_B9B2:				
		cmp	#LINE_LENGTH_LIMIT
		bcs	loc_B9AD
		sta	unk_37
		lda	#$3A ; ':'
		ldy	byte_400
		sta	unk_401,y
		iny
		sty	byte_400

loc_B9C4:				
		clc
		lda	byte_400
		adc	#<unk_401
		sta	ptr1+0
		lda	#>unk_401
		sta	ptr1+1
		lda	#<unk_701
		sta	ptr0+0
		lda	#>unk_701
		sta	ptr0+1
		ldx	#0
		ldy	unk_700
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		lda	unk_37
		sta	byte_400

loc_B9E5:				
		lda	#0
		sta	byte_6A7
		lda	#1
		sta	byte_6B3
		jsr	sub_A8C0
		lda	#1
		sta	byte_6A7
		jsr	find_program
		jsr	advance_2b_to_next_line
		lda	byte_2B
		sta	ptr1+0
		lda	byte_2C
		sta	ptr1+1
		jsr	advance_2b_to_next_line
		lda	byte_2B
		sta	ptr0+0
		lda	byte_2C
		sta	ptr0+1
		sec
		lda	TOP
		sbc	ptr0+0
		tay
		lda	TOP+1
		sbc	ptr0+1
		tax
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		jsr	calculate_screen_chars_in_line
		clc
		lda	byte_3B
		adc	byte_2D
		sec
		sbc	#1
		cmp	text_window_bottom_y
		beq	loc_BA47
		bcc	loc_BA47
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	sub_A069
		jmp	loc_B00D

loc_BA47:				
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		lda	current_line_no_msb
		pha
		lda	current_line_no_lsb
		pha
		jmp	loc_B025



rstrip_detokenized_line:		
		ldy	byte_400
		beq	loc_BA65

loc_BA5B:				
		lda	$400,y
		cmp	#$20 ; ' '
		bne	loc_BA65
		dey
		bne	loc_BA5B

loc_BA65:				
					
		sty	byte_400
		rts
; End of function rstrip_detokenized_line


;-------------------------------------------------------------------------
;
; Find line in lines table.
;
; entry:
; 
; byte_2B.w - address of line to search for
;
; exit:
;
; X = Y coordinate * 2
; (if line not found, the Y coordinate is the bottom of the screen)

sub_BA69: .proc
					
		lda	text_window_bottom_y
		asl
		sta	byte_3A ;
		ldx	#0

loc_BA71:				
		lda	byte_6C0,x
		cmp	byte_2B
		bne	loc_BA82 ;taken if line doesn't match
		inx
		lda	byte_6C0,x
		cmp	byte_2C
		bne	loc_BA83 ;taken if line doesn't match
                ; return with C=1
		dex
		rts

loc_BA82:				
		inx

loc_BA83:				
		inx
		cpx	byte_3A
		beq	loc_BA71
		bcc	loc_BA71
		rts
                .pend

;-------------------------------------------------------------------------

back_command:				
		ldx	#0		; load colour index (0=background)

set_colour_from_command_line:		
		ldy	input_length
		dey
		beq	loc_BA98

back_command_error:					
		lda	#$15
		jmp	raise_error

loc_BA98:				
		lda	(input_ptr),y		; get char from	command	line
		and	#$DF		; toupper

find_colour_loop:			
		cmp	colour_chars,y	; matched colour char?
		beq	got_colour	; taken	if colour found
		iny			; next colour char
		cpy	#8		; last colour?
		bne	find_colour_loop ; taken if last colour	not yet	reached
		beq	back_command_error		; taken	if last	colour reached

got_colour:				
		sty	$A,x
                jmp set_palette
; End of function back_command




fore_command:				
		ldx	#1		; load colour index (1=foreground)
		bne	set_colour_from_command_line ; JMP, in effect
; End of function fore_command		; set appropriate colour




insert_command:				
		lda	#1

loc_BAB1:				
		sta	is_insert_mode	; 0=overtype 1=insert
		rts
; End of function insert_command




overtype_command:			
		lda	#0
		beq	loc_BAB1
; End of function overtype_command



help_command .proc
		lda	#<command_table
		sta	unk_33
		lda	#>command_table
                sta	unk_34

help_loop
                ldy #0
                lda (unk_33),y
                cmp #$ff
                beq done

                ; print command name
print_command_name_loop
                jsr oswrch
                iny
                lda (unk_33),y
                bne print_command_name_loop

                ; skip terminating 0
                iny
                
                ; fetch args flags into X
                lda (unk_33),y
                iny
                tax

                ; skip command ID
                iny

                ; point unk_34 at next command
                clc
                tya
                adc unk_33
                sta unk_33
                bcc nocarry
                inc unk_34
nocarry

                ; do args
                txa
                and #$20
                bne print_c

                txa
                and #$10
                bne s1s2

                txa
                and #$40
                bne n1n2

                txa
                and #$8
                bne print_p

                txa
                and #$2
                bne print_n

                txa
                and #5
                bne print_s

next_help:
                jsr print_next_string
                .text ", ",255
                
                jmp help_loop

print_c
                ldx #'c'
                bne onechar

print_p
                ldx #'p'
                bne onechar

print_n
                ldx #'n'
                bne onechar

print_s
                ldx #'s'
onechar
                lda #32
                jsr oswrch
                txa
                jsr oswrch
                jmp next_help

s1s2:
                jsr print_next_string
                .text " s1 s2",255
                jmp next_help

n1n2:
                jsr print_next_string
                .text " n1 n2",255
                jmp next_help           

done
print_help_footer:
                jsr print_next_string
                .text "n",$D,$A
                .byte $A
                .text "Where p is a program; s, s1, s2 are strings; n, n1, n2 are numbers; c is a colour [NRGYBMCW].",$D,$A
                .byte 255
                rts
                .pend
                
;-------------------------------------------------------------------------

goto_line_command .proc				
		lda	input_ptr+1
		sta	byte_2B
		lda	input_ptr+0
		sta	byte_2C
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		ldy	#1
		lda	(byte_2B),y
		bmi	loc_BBB0
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jmp	loc_9DA8

loc_BBB0:				
		jmp	end_edit_mode_command
.pend


print_bytes_free: .proc
                lda is_bad_program
                bne bad

                lda himem
                sbc top
                tax
                lda himem+1
                sbc top+1
                tay
                jmp print_number

bad:
                lda #'?'
                jmp oswrch
                .pend
                
info_command:				
                jsr	osnewl

                ; lda language_entry_mode
                ; clc
                ; adc #'A'
                ; jsr oswrch

                lda is_bad_program
                bne print_status

                ldx top
                sec
                lda top+1
                sbc oshwm+1
                tay
                jsr print_number

                jsr print_next_string
                .text " used, ",255

                jsr print_bytes_free
                
                jsr print_next_string
                .text " free",13,10,255

print_status:
                .if ENABLE_DEBUG

                jsr print_next_string
                .text "DBG: ",255

                lda debug_flag
                jsr print_on_off

                lda #' '
                jsr oswrch

                ldx debug_counter+0
                ldy debug_counter+1
                jsr itoa
                jsr print_itoa_result
                jsr osnewl
                
                .endif
                
                jsr print_next_string
                .text "Scroll: ",255

                lda is_scroll_on ;1=scroll 0=noscroll
                jsr print_on_off
                
                jsr osnewl

                jsr print_next_string
                .text "Insert: ",255

                lda is_insert_mode ;0=overtype 1=insert
                jsr print_on_off

                jsr osnewl

		lda	#$87		; get MODE in Y
		jsr	OSBYTE		; get MODE in Y
		cpy	#7		; MODE 7?
                beq loc_BC0B
					
		jsr	print_colour_scheme
		jsr	OSNEWL

loc_BC0B:				
		jsr	OSNEWL
		; LDX	#<aProgramName
		; LDY	#>aProgramName
		; LDA	#$E
                ; JSR	print_n_chars
                jsr print_next_string
                .text "Program name: ",255                
		lda	#2
		sta	editor_mode_id	; 1=command mode, 2=edit mode
                jsr print_program_name
                jsr	OSNEWL
		ldx	#<aLastSearch
		ldy	#>aLastSearch
		lda	search_string_length
		bne	loc_BC37
		lda	#aLastSearchNoneEnd-aLastSearch
		bne	loc_BC42

loc_BC37:				
		lda	#aLastSearchEnd-aLastSearch
		jsr	print_n_chars
		ldx	#<search_string
		ldy	#>search_string
		lda	search_string_length

loc_BC42:				
		jsr	print_n_chars
		lda	#1
		sta	editor_mode_id	; 1=command mode, 2=edit mode
		jsr	OSNEWL
                jsr	OSNEWL
                jsr print_next_string
                .text "Tab value   : ",255
		ldx	tab_value
		ldy	#0
		jsr	print_number
                jsr	move_to_column_21
                jsr print_next_string
                .text "No.of lines: ",255
		lda	is_bad_program
		bne	loc_BC94
		ldx	#0
		stx	byte_38
		stx	byte_39
		stx	byte_2B
		lda	oshwm+1
		sta	byte_2C

loc_BC7C:				
		ldy	#1
		lda	(byte_2B),y
		bmi	loc_BC8D
		jsr	advance_2b_to_next_line
		inc	byte_38
		bne	loc_BC8B
		inc	byte_39

loc_BC8B:				
		bne	loc_BC7C

loc_BC8D:				
		ldx	byte_38
		ldy	byte_39
		jsr	print_number

loc_BC94:				
		jsr	OSNEWL
		lda	is_bad_program
		beq	loc_BC9C
		rts

loc_BC9C:				
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_BCA4
		jmp	loc_BD22

loc_BCA4:				
                jsr print_next_string
                .text "First line  : ",255
                
		jsr	sub_BD8D
		jsr	move_to_column_21
                jsr print_next_string
                .text "Last line  : ",255
		lda	#-1
		sta	byte_2B
		jsr	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		ldy	#2
		lda	(unk_2F),y
		tax
		dey
		lda	(unk_2F),y
		tay
		jsr	print_number
                jsr	OSNEWL
                jsr print_next_string
                .text "Current line: ",255
		ldx	current_line_no_lsb
		ldy	current_line_no_msb
		jsr	print_number
		jsr	move_to_column_21
		jsr	sub_B37B
		php
		ldx	#<aMarkedLine
		ldy	#>aMarkedLine
		plp
		bne	loc_BCFF
		lda	#aMarkedLineEnd-aMarkedLine
		jsr	print_n_chars
		ldx	marked_line_no_lsb
		ldy	marked_line_no_msb
		jsr	print_number
		jmp	loc_BD04

loc_BCFF:				
		lda	#aMarkedLineNoneEnd-aMarkedLine
		jsr	print_n_chars

loc_BD04:				
		jsr	OSNEWL
		jsr	OSNEWL
		ldx	#<aPendingCommands
		ldy	#>aPendingCommands
		lda	byte_40
		cmp	#$20 ; ' '
		bne	loc_BD25
		lda	byte_46
		cmp	#$20 ; ' '
		bne	loc_BD25
		lda	#aPendingCommandsNoneEnd-aPendingCommands
		jsr	print_n_chars

loc_BD1F:				
		jsr	OSNEWL

loc_BD22:				
		jmp	OSNEWL

loc_BD25:				
					
		lda	#aPendingCommandsEnd-aPendingCommands
		jsr	print_n_chars
		jsr	OSNEWL
		lda	byte_40
		cmp	#$20 ; ' '
		beq	loc_BD46
		lda	byte_43
		cmp	#$20 ; ' '
		beq	loc_BD46
		jsr	sub_AD1A
		bcc	loc_BD46
		ldx	byte_40
		ldy	byte_43
		stx	byte_43
		sty	byte_40

loc_BD46:				
					
		lda	#0
		sta	byte_39

loc_BD4A:				
		ldx	byte_39
		cpx	#7
		bcs	loc_BD1F
		lda	byte_40,x
		cmp	#$20 ; ' '
		beq	loc_BD7B
		cmp	#$60 ; '`'
		bcc	loc_BD60
		sec
		sbc	#$20 ; ' '
		jsr	OSWRCH

loc_BD60:				
		jsr	OSWRCH
		lda	#$20 ; ' '
		jsr	OSWRCH
		lda	byte_41,x
		tay
		lda	byte_42,x
		tax
		jsr	print_number
		ldx	#3
		lda	#$20 ; ' '

loc_BD75:				
		jsr	OSWRCH
		dex
		bne	loc_BD75

loc_BD7B:				
		inc	byte_39
		inc	byte_39
		inc	byte_39
		bne	loc_BD4A
; End of function info_command




move_to_column_21:
		lda	#$86    ;read POS/VPOS (AUG p158)
		jsr	OSBYTE
		ldx	#21
		jmp	gotoxy




sub_BD8D:				
		ldy	#2		; offset of line number	MSB
		lda	(oshwm),y		; get line number MSB
		tax
		dey			; offset of line number	LSB
		lda	(oshwm),y		; get line number LSB
		tay
; End of function sub_BD8D




print_number: .proc			
					
		jsr	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string

                .pend

print_itoa_result: .proc

		ldx	#1
		ldy	#0
		lda	byte_0
		jmp	print_n_chars

                .pend

print_colour_scheme: .proc		
					
                ldx	foreground_colour
                lda #$df
                jsr	print_colour_name
                jsr print_next_string
                .text " on ",255
                ldx	background_colour
                lda #$ff

                ; fall through
print_colour_name:
                ldy colour_names_table,x
loop:
                and colour_names_table,y
                jsr oswrch
                iny
                tya
                cmp colour_names_table+1,x
                lda #$ff
                bcc loop
                rts
.pend

;-------------------------------------------------------------------------
; 
; Replace text in line
;
; Entry:
; (replace_text_ptr), ?replace_text_length - replace text
; (
                
sub_BDD3:				
					
		lda	input_ptr+0
		pha
		lda	input_ptr+1
		pha
		lda	replace_text_ptr+0
		sta	input_ptr+0
		lda	replace_text_ptr+1
		sta	input_ptr+1
		clc
		lda	cursor_offset	; offset of cursor in detokenized buffer
		adc	input_length    ;cursor_offset+search length
		bcs	loc_BDF5        ;taken if definite overflow
		sec
		sbc	#1
		cmp	byte_400
		beq	loc_BE09 ;taken if line too short to match
		bcc	loc_BE09 ;taken if line too short to match

loc_BDF5:				
		clc
		lda	cursor_offset	; offset of cursor in detokenized buffer
		adc	replace_text_length ;cursor_offset+replace text length
		bcs	loc_BE23 ;taken if definite overflow
		sec
		sbc	#1
		cmp	#252
		bcs	loc_BE23 ;
		sta	byte_400
		bcc	loc_BE57

loc_BE09:				
		sec
		lda	replace_text_length
		sbc	input_length
		sta	unk_6AE
		clc
		adc	byte_400
		pha
		ldy	unk_6AE
		bmi	loc_BE2B
		bcs	loc_BE23
		cmp	#252
		bcc	loc_BE2B

loc_BE23:				
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		lda	#37     ;Updates would make line too long
		jmp	raise_error

loc_BE2B:				
		clc
		lda	#<unk_401-1
		adc	cursor_offset	; offset of cursor in detokenized buffer
		adc	input_length
		sta	ptr0+0
		adc	unk_6AE
		sta	ptr1+0
		lda	#>unk_401-1
		sta	ptr0+1
		sta	ptr1+1
		ldx	#0
		clc
		lda	byte_400
		adc	#1
		sec
		sbc	cursor_offset	; offset of cursor in detokenized buffer
		sec
		sbc	input_length
		tay
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		pla
		sta	byte_400

loc_BE57:				
		lda	input_ptr+0
		sta	ptr0+0
		lda	input_ptr+1
		sta	ptr0+1
		clc
		lda	#<unk_401-1
		adc	cursor_offset	; offset of cursor in detokenized buffer
		sta	ptr1+0
		lda	#>unk_401-1
		sta	ptr1+1
		ldx	#0
		ldy	replace_text_length
		clc
		tya
		adc	cursor_offset	; offset of cursor in detokenized buffer
		sta	cursor_offset	; offset of cursor in detokenized buffer
		sta	byte_6B3
		jsr	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
		pla
		sta	input_ptr+1
		pla
		sta	input_ptr+0
                rts
; End of function sub_BDD3

;-------------------------------------------------------------------------



find_mode_getch:				
					
		jsr	kbflush
		lda	is_insert_mode	; 0=overtype 1=insert
		pha
		lda	#1
		sta	is_insert_mode	; 0=overtype 1=insert
		jsr	reset_cursor_shape
		pla
		sta	is_insert_mode	; 0=overtype 1=insert
		jsr	getch
		jmp	make_cursor_invisible
; End of function find_mode_getch




move_cursor_to_previous_line: .proc ;scroll up??
		jsr	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		bcc	line_empty
		lda	is_scroll_on	; 1=scroll, 0=noscroll
		bne	loc_BEB2        ;taken if scroll on
		rts

line_empty:    
		lda	is_scroll_on	; 1=scroll, 0=noscroll
		bne	loc_BEA9        ;taken if scroll on

loc_BEA6:				
		jmp	loc_BFBB

loc_BEA9:				
		lda	byte_3B
		bne	loc_BEA6         ;taken if Y!=0 - i.e.,
                                         ;scrolling is unnecessary
		jsr	is_program_empty ; sets	C if no	program
		bcc	loc_BEB5         ;taken if program is valid

loc_BEB2:				
		jmp	edit_mode_loop ;

loc_BEB5:				
		jsr	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		lda	unk_30
		beq	loc_BEB2 ;clearly bad if zero
		jsr	make_cursor_invisible
		lda	byte_2D
		sta	byte_35
		jsr	sub_A8C0
		jsr	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		txa
		sec
		sbc	byte_35
		sta	byte_35
		lda	screen_chars_in_line+0
		pha
		lda	screen_chars_in_line+1
		pha
		jsr	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		jsr	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jsr	detokenize_one_line
		jsr	calculate_screen_chars_in_line ;also sets
                                                       ;byte_2d to
                                                       ;line height
		ldx	#0
		ldy	#0
		jsr	gotoxy
		lda	#19
		sta	byte_6AB
		jsr	OSBYTE  ;this is actually worth doing in Mode
                                ;7...

                ; scroll screen up enough to fit new line
		ldy	byte_2D
		lda	#11

loc_BEF7:				
		jsr	OSWRCH
		dey
		bne	loc_BEF7

                ; 
		lda	byte_35
		beq	loc_BF04
                
		jmp	loc_BF5B

loc_BF04:

                ; ?byte_36 = (text_window_bottom_y - line_height) + 1
		sec
		lda	text_window_bottom_y
		sbc	byte_2D      
		sta	byte_36
		inc	byte_36


                ; erase any partial line at the bottom of the screen?
loc_BF0E:				
		lda	byte_36
		asl            
		tax            
		tay            
		inx            
		lda	byte_6C0,x 
		beq	loc_BF5B
		dey
		cmp	byte_6C0,y
		bne	loc_BF4F
		dex
		dey
		lda	byte_6C0,x
		cmp	byte_6C0,y
		bne	loc_BF4F
		lda	#0
		sta	byte_6C0,x
		sta	byte_6C1,x
		dec	byte_36

                ; gotoxy (0,y)
		clc
		lda	byte_36
		adc	byte_2D
		tay
		ldx	#0
		jsr	gotoxy

                ; fill with spaces
		clc
		lda	code_area_width
		adc	#6      ;account for line number area
		tay
		lda	#$20 ; ' '

loc_BF47:				
		jsr	OSWRCH
		dey
		bne	loc_BF47
		beq	loc_BF0E ;JMP, in effect

loc_BF4F:				
		lda	byte_36
		asl
		tax
		lda	#0
		sta	byte_6C0,x
		sta	byte_6C1,x

loc_BF5B:
		lda	byte_2D ;Y coord
		asl             ;*2
		sta	ptr1+0

                ; copy from $6c0 to $6c0+y - must copy down
		lda	#>byte_6c0
		sta	ptr0+1  ;src MSB
		sta	ptr1+1  ;dest MSB
		lda	#<byte_6c0
		sta	ptr0+0  ;src LSB
		clc
		adc	ptr1+0  ;dest LSB
		sta	ptr1+0  ;dest LSB
		bcc	loc_BF73
		inc	ptr1+1

loc_BF73:				
		clc
		lda	text_window_bottom_y
		adc	#1
		sec
		sbc	byte_2D
		asl

                .if KEEP_BF73_MEMMOVE

		tay
		ldx	#0
                ;
                ; called when scrolling up
		jsr	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (ptr0) points to src
					; (ptr1) points to dest
					; X is MSB of size
					; Y is LSB of size
                                        
                .else

                tay
                beq copy_rows_table_done
                dey              ;Y is offset
copy_rows_table_loop:
                lda (ptr0),y
                sta (ptr1),y
                dey
                cpy #$ff
                bne copy_rows_table_loop
copy_rows_table_done:

                .endif

		lda	byte_2B
		sta	byte_6C0
		lda	byte_2C
		sta	byte_6C1
		jsr	sub_9F00
		jsr	advance_2b_to_next_line
		lda	byte_2D
		sta	byte_3B
		asl
		tax
		lda	byte_2B
		sta	byte_6C0,x
		lda	byte_2C
		sta	byte_6C1,x
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		pla
		sta	screen_chars_in_line+1
		pla
		sta	screen_chars_in_line+0
		lda	byte_6B3
		bne	loc_BFB5
		lda	byte_35
		beq	loc_BFBE

loc_BFB5:				
		jsr	sub_AA17
		jmp	loc_BFBE

loc_BFBB:				
		jsr	sub_AA06

loc_BFBE:				
					
		lda	byte_3B
		asl
		tax
		bne	loc_BFCB
		sta	byte_2B
		sta	byte_2C
		jsr	sub_BA69

loc_BFCB:				
		dex
		jsr	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		jsr	sub_BA69
		txa
		lsr
		sta	byte_3B
		jsr	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		jmp	sub_A069
                .pend


; finds	current	line by	number.
;
; Entry:
; current_line_no_msb,
; current_line_no_lsb =	line number to search for
;
; Exit:
; (byte_2B) points to line found

find_current_line_by_number:		
		lda	current_line_no_msb
		sta	byte_2B
		lda	current_line_no_lsb
		sta	byte_2C
		jmp	find_line_by_number ; finds a line, given a line number
; End of function find_current_line_by_number ;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
                                        ; (byte_2B) points to most suitable line

zsave_command: .proc
                jsr find_program
                jsr find_program_name
                bcc no_program_name

                ; pretend program name was command line, and forward
                ; straight to SAVE.
                lda program_name_ptr+0
                sta input_ptr+0
                lda program_name_ptr+1
                sta input_ptr+1
                jmp save_command

no_program_name:
                lda #39         ;No program name
                jmp raise_error
.pend

zrun_command: .proc
                jsr zsave_command

                lda #CMD_RUN
                sta current_command_id
                jmp run_or_exit_command
.pend

print_program_name: .proc
                jsr find_program_name
                bcc done

                ldy #0
loop:
                lda (program_name_ptr),y
                cmp #13
                beq done
                jsr oswrch
                iny
                bne loop

done:
                rts
                .pend

;-------------------------------------------------------------------------

find_program_name: .proc
                ; check for intial 13.
                ldy #0
                lda (oshwm),y
                cmp #13
                bne no

                ; check line MSB - no program if -ve.
                iny

                lda (oshwm),y
                bmi no

                ldy #3
                ; look for REM
                jsr skipspaces
                cmp #REM_TOKEN
                bne no

                ; look for >
                jsr skipspaces
                cmp #'>'
                bne no

                ; no name if just spaces.
                jsr skipspaces
                cmp #13
                beq no

                ; point (byte_3e) at name
                clc
                tya
                adc $17
                sta program_name_ptr+0
                lda $18
                adc #0
                sta program_name_ptr+1
                sec
                rts

no:
                clc
                rts

skipspaces
                iny
                lda (oshwm),y
                cmp #32
                beq skipspaces
return:
                rts
                .pend

;-------------------------------------------------------------------------

maybe_verbose_exit_on_error: .proc
                bit language_entry_mode
                bpl find_program_name.return

                jsr display_error_message
                jmp exit_and_OLD
                
                .pend

;-------------------------------------------------------------------------

                .if ENABLE_DEBUG
reset_debug_values: .proc
                lda #0
                sta debug_counter+0
                sta debug_counter+1
                sta debug_flag
                rts
                .pend
                .endif

;-------------------------------------------------------------------------

                .if ENABLE_DEBUG
inc_debug_counter: .proc
                inc debug_counter+0
                bne done
                inc debug_counter+1
done:
                rts
                .pend
                .endif
                
;-------------------------------------------------------------------------
                .bend
                .send language
