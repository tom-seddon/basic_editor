;-------------------------------------------------------------------------
                
; COPRO==0: standard
; COPRO==1: HI
; COPRO==2: Relocatable ($8000 version)
; COPRO==3: Relocatable ($b800 version)

HI_ADDRESS = $b800

.if COPRO==0
                
RELOCATABLE = false
HI = false
SVC_BASE = $8000
LANG_BASE = $8000

.elsif COPRO==1
                
RELOCATABLE = false
HI = true
SVC_BASE = $8000
                LANG_BASE = HI_ADDRESS
                
.elsif COPRO==2
                
RELOCATABLE = true
HI = false
SVC_BASE = $8000
LANG_BASE = $8000

.elsif COPRO==3
                
RELOCATABLE = true
HI = false
SVC_BASE = $8000
                LANG_BASE = HI_ADDRESS
                
.endif

;-------------------------------------------------------------------------

                ; Language entry point modes.
                ;
                ; All modes must be non-zero.
                LANGUAGE_MODE_NORMAL=1
                LANGUAGE_MODE_ZSAVE=$80
                LANGUAGE_MODE_ZRUN=$81


;-------------------------------------------------------------------------
; SLRE---1-
; S=service
; L=language
; R=copro relocation
; E=electron soft key

.if HI||RELOCATABLE
ROM_FLAGS = %11100010
.else
ROM_FLAGS = %11000010
.endif
                
;-------------------------------------------------------------------------
                
                .dsection code
                * = SVC_BASE

rom_start:
                JMP     language_entry
                JMP     service_entry

                .byte ROM_FLAGS

                .byte  copyright-rom_start ;
                .byte     $FF
aTheBasicEditor_0:
                .text    "The "
                .if HI
                .text "HI"
                .endif
                .text "BASIC Editor",0
version_number_string:
                .text " $VER"
.if RELOCATABLE
                .text "r"
.endif
copyright:
                .byte 0
aC1984Acornsoft:
                ; was "(C) 1984 Acornsoft". Sorry, Acornsoft!
                .text "(C)",0
                .if HI||RELOCATABLE
                ; this address gets fixed up by make_reloc, based on
                ; the relocation value in the altrom.
                .word LANG_BASE
                .word 0
                .endif
                
; A = code, X = ROM number, Y = parameter.

service_entry .proc
                pha

maybe_star:
                cmp #4
                bne maybe_help
star:
                tya
                pha

check_be:
                ; *...
                lda ($f2),Y
                and #$df
                cmp #"B"
                bne star_done

                ; *B....
                iny
                lda ($f2),Y
                and #$df
                pha

                ; *B?...
                iny
                lda ($f2),Y
                cmp #13
                beq check_command
                pla
star_done:
                pla
                tay
                jmp done

check_command:
                ; *B?|M
                pla
                cmp #"E"
                bne try_z
                ; *BE|M
                ldx #LANGUAGE_MODE_NORMAL
                bne enter_language

try_z:
                cmp #"Z"
                bne try_r
                ; *BZ|M
                ldx #LANGUAGE_MODE_ZSAVE
                bne enter_language
                
try_r:
                cmp #"R"
                bne star_done
                ; *BR|M
                ldx #LANGUAGE_MODE_ZRUN
                
enter_language:
                ; set the user flag for the language entry point.
                lda #1
                ldy #0
                jsr osbyte
                
                .if HI
                ; if there's no Tube, just ignore the request - this
                ; gives the non-HI ROM a chance, if it's there, or a
                ; Bad Command, if it isn't (since the HI language code
                ; can't run in the IO processor).
                lda #$ea
                ldx #$00
                ldy #$ff
                jsr osbyte
                inx
                bne star_done
                .endif
                
                ldx $f4
                lda #$8e        ;enter language ROM
                jmp osbyte

maybe_help:
                cmp #9
                bne done
help:
                lda ($f2),Y
                cmp #" "
                beq help
                cmp #13
                bne done
print_help:
                tya
                pha
                jsr osnewl
                ldy #0
print_help_name_loop:
                lda aTheBasicEditor_0,Y
                jsr oswrch
                iny
                cpy #aC1984Acornsoft-aTheBasicEditor_0
                bne print_help_name_loop
                jsr osnewl
                pla
                tay
done:
                ldx $f4
                pla
                rts
.pend

;-------------------------------------------------------------------------

.logical LANG_BASE+(*-SVC_BASE)

init_language_entry_mode: .proc
                ; read the user flag that was set by the service call
                ; 4 handler.
                lda #1
                ldx #0
                ldy #$ff
                jsr osbyte

                stx language_entry_mode

                ; reset flag, whatever it was
                lda #1
                ldx #0
                ldy #0
                jsr osbyte

                lda language_entry_mode
                
                cmp #LANGUAGE_MODE_ZSAVE
                beq zsave

                cmp #LANGUAGE_MODE_ZRUN
                beq zrun
ret:
                rts

zsave:
                jsr saving_message
                jsr zsave_command
                jmp exit_and_OLD

zrun:
                jsr saving_message
                jsr zsave_command
                jmp exit_and_OLD_and_RUN

saving_message:
                lda program_name
                cmp #13
                beq ret
                
                ldx #<aSaving
                ldy #>aSaving
                lda #aSavingEnd-aSaving
                jsr print_n_chars

                jsr print_program_name
                jmp osnewl

aSaving: .text "Saving: "
aSavingEnd:

.pend
                
language_entry: .proc
                CMP     #1              ; normal language entry?
                BEQ     language_start
                RTS

language_start:
                JSR     init_brkv_and_oshwm
                JSR     clear_line_commands
                JSR     sub_B358
                JSR     reset_program_name
                LDX     #5
                STX     unk_61
                LDX     #$60 ; '`'
                STX     unk_31
                LDX     #0
                STX     byte_62
                INX
                STX     is_insert_mode  ; 0=overtype 1=insert
                STX     scroll_status   ; 1=scroll, 0=noscroll
                LDA     #$E4
                JSR     osbyte_with_y0
                JSR     clear_5B1_to_600
                ldx #$ff
                JSR     get_HIMEM_for_mode_X
                LDA     #0
                STA     background_colour
                sta case_insensitive_search
                LDA     #7
                STA     foreground_colour

                JSR     sub_8314
                JSR     find_program
                BCC     language_start_good_program
                JSR     clear_program
                JSR     clear_5B1_to_600

language_start_good_program:

                jsr     find_rem_name

                jsr init_language_entry_mode

                LDX     #0
                LDA     #$D2
                JSR     osbyte_with_y0 ;suppress sound
                
                ; print_n_chars skips control chars if editor_mode_id
                ; isn't 1. And since aResetOSWRCH is entirely control
                ; chars...
                lda #1
                sta editor_mode_id
                
                ldx #<aResetOSWRCH
                ldy #>aResetOSWRCH
                lda #aResetOSWRCHEnd-aResetOSWRCH
                jsr print_n_chars
                
command_prompt_loop:
                                        
                LDX     #$FF
                TXS
                JSR     initialise
                JSR     find_program
                BCS     loc_8147
                JSR     is_program_empty ; sets C if no program
                BCS     loc_8147
                LDA     current_line_no_lsb
                STA     byte_2B
                LDA     current_line_no_msb
                STA     byte_2C
                JSR     find_line_by_number ; finds a line, given a line number
                                        ;
                                        ; Entry:
                                        ; byte_2B: line number MSB
                                        ; byte_2C: line number LSB
                                        ;
                                        ; Exit:
                                        ; (byte_2B) points to most suitable line
                LDY     #1
                LDA     ($2B),Y
                BPL     loc_8144
                JSR     sub_AA77        ; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_8144:                               
                JSR     save_line_number ; saves line number from program.
                                        ;
                                        ; Entry:
                                        ; (byte_2b) points to current line
                                        ;
                                        ; Exit:
                                        ; current_line_no_lsb, current_line_no_msb = the line number

loc_8147:                               
                                        
                JSR     print_command_screen
                JSR     do_command_line

loc_814D:                               
                                        
                LDA     editor_mode_id  ; 1=command mode, 2=edit mode
                CMP     #2              ; edit mode?
                BNE     command_prompt_loop     ; branch taken if not edit mode
; edit mode
                LDA     byte_15
                BEQ     loc_8163
                LDA     current_line_no_lsb
                STA     byte_50
                LDA     current_line_no_msb
                STA     byte_51
                JMP     command_prompt_loop

loc_8163:                               
                LDA     byte_6C1
                CMP     #-1
                BEQ     command_prompt_loop
                STA     byte_3A
                LDA     byte_6C0
                STA     byte_39
                LDY     #1
                LDA     ($39),Y
                STA     byte_50
                INY
                LDA     ($39),Y
                STA     byte_51
                JMP     command_prompt_loop
; End of function language_entry
.pend



init_brkv_and_oshwm: .proc

                CLI
                CLD
                LDA     #<brk_handler
                STA     $202            ; BRKV+0
                LDA     #>brk_handler
                STA     $203            ; BRKV+1
                LDA     #0
                STA     oshwm
                STA     unk_6AD
                LDA     #$83
                JSR     OSBYTE          ; Read OSHWM
                STY     oshwm+1         ; $18 = MSB
                LDA     #$82
                JSR     OSBYTE          ; Read machine higher order address
                STX     higher_order_address
                STY     higher_order_address+1
                LDA     #0
                STA     unk_6B8
                LDA     #$A
                STA     unk_6B9
                RTS
.pend
                
get_HIMEM_for_mode_X: .proc
                LDY     higher_order_address
                INY
                BNE     is_tube
                LDY     higher_order_address+1
                INY
                BEQ     is_not_tube

is_tube:
                lda #<LANG_BASE
                sta HIMEM+0
                lda #>LANG_BASE
                sta HIMEM+1                
                RTS

is_not_tube:
                lda #132        ;read HIMEM for current MODE
                cpx #$ff
                beq get_HIMEM
                LDA     #133    ;read HIMEM for given MODE
get_HIMEM:
                JSR     OSBYTE
                STX     HIMEM
                STY     HIMEM+1
                RTS
; End of function validate_mode


.pend
print_command_screen .proc
TEXT_WINDOW_TOP = 3
                JSR     make_cursor_invisible
                JSR     get_text_window_left_bottom
                STX     byte_25
                STY     byte_26
                LDX     #$A
                JSR     OSBYTE
                STX     byte_27
                STY     byte_28
                LDA     #$86
                JSR     OSBYTE
                TYA
                PHA

                ; see if text window is set up. if it is, obviously
                ; (?) the HUD just needs updating. otherwise, redraw
                ; it completely.
                LDA     #26
                JSR     OSWRCH
                JSR     get_text_window_left_bottom
                CPY     byte_26
                BNE     loc_8218
                LDA     #0
                CMP     byte_25
                BNE     loc_8218
                lda #160        ;read VDU vars
                ldx #10         ;text window right
                jsr osbyte
                cpx byte_27
                BNE     loc_8218
                LDA     #TEXT_WINDOW_TOP
                CMP     byte_28
                BEQ     loc_823B

loc_8218:                               
                                        
                LDA     #0
                STA     byte_25         ; text window left
                lda #160                ;read VDU vars
                ldx #10                 ;text window right
                jsr osbyte
                stx byte_27     ;text window right
                ; LDA   #39
                ; STA   byte_27         ; text window right
                LDA     #TEXT_WINDOW_TOP
                STA     byte_28         ; text window top
                ; LDA   #$13            ; wait for vsync
                ; JSR   OSBYTE
; print "The BASIC Editor", "Program size" (etc.)
                LDX     #<hud_text_1_begin
                LDY     #>hud_text_1_begin
                LDA     #hud_text_1_end-hud_text_1_begin
                JSR     print_n_chars
                JSR     get_text_window_left_bottom
                STY     byte_26
                PLA
                LDA     #0
                PHA

loc_823B:                               
                LDA     #26             ; restore default text window
                JSR     OSWRCH
; print program size
                LDX     #6
                LDY     #0
                JSR     gotoxy
                LDA     unk_16
                BNE     loc_8259
                LDX     TOP
                SEC
                LDA     TOP+1
                SBC     oshwm+1
                TAY
                JSR     itoa            ; Gets string representation of 16-bit number.
                                        ;
                                        ; Entry:
                                        ; Y,X = value
                                        ;
                                        ; Exit:
                                        ; unk_0 holds digit count
                                        ; unk_1... filled with string
                JSR     print_number    ; print number.
                                        ;
                                        ; Suitable for use with the result of itoa.
                                        ;
                                        ; Entry:
                                        ; unk_0 = digit count
                                        ; unk_1... = digits

loc_8259:                               
                JSR     print_5_spaces
; print bytes free
                LDX     #19
                LDY     #0
                JSR     gotoxy
                LDA     unk_16
                BNE     loc_8278
                SEC
                LDA     HIMEM
                SBC     TOP
                TAX
                LDA     HIMEM+1
                SBC     TOP+1
                TAY
                JSR     itoa            ; Gets string representation of 16-bit number.
                                        ;
                                        ; Entry:
                                        ; Y,X = value
                                        ;
                                        ; Exit:
                                        ; unk_0 holds digit count
                                        ; unk_1... filled with string
                JSR     print_number    ; print number.
                                        ;
                                        ; Suitable for use with the result of itoa.
                                        ;
                                        ; Entry:
                                        ; unk_0 = digit count
                                        ; unk_1... = digits

loc_8278:                               
                JSR     print_5_spaces

; print program name

                ldx #6
                ldy #1
                jsr gotoxy
                jsr print_program_name_padded

                LDX     #<hud_text_2_begin
                LDY     #>hud_text_2_begin
                LDA     #hud_text_2_end-hud_text_2_begin
                JSR     print_n_chars

                
; set screen window
                LDA     #28
                STA     byte_24
                LDX     #$24 ; '$'
                LDY     #0
                LDA     #5
                JSR     print_n_chars
                PLA
                TAY
                LDX     #0
                JSR     gotoxy
                LDA     byte_15
                BEQ     loc_82CB
                jsr display_error_message

loc_82CB:                               
                LDA     #'>'
                JSR     OSWRCH
                LDA     is_insert_mode  ; 0=overtype 1=insert
                PHA
                LDA     unk_31
                PHA
                LDA     #0
                STA     is_insert_mode  ; 0=overtype 1=insert
                LDA     #$60 ; '`'
                STA     unk_31
                JSR     reset_cursor_shape
                PLA
                STA     unk_31
                PLA
                STA     is_insert_mode  ; 0=overtype 1=insert
                RTS
.pend

display_error_message: .proc

                JSR     OSNEWL

                LDX     #$4F ; 'O'
                LDY     #$28 ; '('

loc_82AE:                               
                LDA     $5D7,Y
                CMP     #$20 ; ' '
                BNE     loc_82BA
                DEY
                BNE     loc_82AE
                LDX     #$27 ; '''

loc_82BA:
                TXA
                LDX     #<unk_5B1
                LDY     #>unk_5B1
                JSR     print_n_chars
                
                JSR     OSNEWL
                JSR     OSNEWL
                JMP     beep
.pend

print_5_spaces .proc                               
                                        
                LDX     #<six_spaces_string
                LDY     #>six_spaces_string
                LDA     #5
                JMP     print_n_chars
.pend
; End of function print_5_spaces




get_text_window_left_bottom:            
                                        
                LDX     #8
                LDA     #$A0
                JMP     OSBYTE
; End of function get_text_window_left_bottom




clear_program:                          
                                        
                LDY     #0
                LDA     #$D
                STA     ($17),Y
                INY
                LDA     #-1
                STA     ($17),Y
                JSR     find_program
                LDA     #0
                STA     current_line_no_lsb
                LDA     #$A
                STA     current_line_no_msb
                JSR     sub_B358
                JMP     clear_line_commands
; End of function clear_program




sub_8314:                               
                                        
                LDA     #0
                STA     current_line_no_lsb
                STA     current_line_no_msb
                STA     byte_50
                STA     byte_51
                RTS
; End of function sub_8314




find_program:                           
                                        
                LDA     #0
                STA     unk_16
                STA     byte_38
                STA     byte_C
                STA     byte_D
                PHA
                LDA     #$FF
                PHA
                PHA
                LDA     oshwm+1
                STA     byte_39

find_program_scan_line:                         
                LDY     #0
                LDA     (byte_38),Y     ; get first char in line
                CMP     #$D             ; is it the required 13?
                BEQ     line_start_ok

bad_program:                            
                PLA
                PLA
                PLA
                INC     unk_16
                LDA     #1
                JSR     get_error       ; A = error code
                SEC                     ; bad program
                RTS

line_start_ok:                          
                INY
                LDA     (byte_38),Y     ; line MSB
                BPL     scan_valid_line ; if +ve, not end
; reached end, so set TOP to just past the terminating $FF
                CLC
                LDA     byte_38
                ADC     #2
                STA     TOP
                LDA     #0
                ADC     byte_39
; gone past the relevant HIMEM?
                STA     TOP+1
                CMP     HIMEM+1
                BCC     TOP_in_bounds
                BNE     force_mode_7
                LDA     HIMEM
                CMP     TOP
                BCS     TOP_in_bounds

force_mode_7:                           
                LDX     #$ff
                JSR     get_HIMEM_for_mode_X
                LDA     #3
                JSR     get_error       ; A = error code

TOP_in_bounds:                          
                                        
                PLA
                PLA
                PLA
                BEQ     find_program_good_program
                JSR     sub_8495

find_program_good_program:
                CLC
                RTS
; (seems to be maintaining its own notion of line numbering - not sure what for - it never does anything particular if it encounters a discrepancy)

scan_valid_line:                        
                LDA     byte_C
                BMI     loc_8387
                CLC
                LDA     byte_D
                ADC     #10
                STA     byte_D
                BCC     loc_8387
                INC     byte_C

loc_8387:                               
                                        
                PLA
                BMI     loc_83A0
                CMP     (byte_38),Y
                BEQ     loc_8392
                BCC     loc_83A0
                BCS     loc_839A

loc_8392:                               
                INY
                PLA
                CMP     (byte_38),Y
                BCS     loc_839B
                BCC     loc_83A1

loc_839A:                               
                PLA

loc_839B:                               
                PLA
                LDA     #1
                PHA
                PHA

loc_83A0:                               
                                        
                PLA

loc_83A1:                               
                LDY     #2

loc_83A3:                               
                LDA     (byte_38),Y
                PHA
                DEY
                BNE     loc_83A3
                LDY     #3
                LDA     (byte_38),Y     ; get line length
                BMI     next_line       ; if >=128, it's fine
                CMP     #4
                BCC     bad_program     ; if <4, bad program

next_line:                              
                CLC
                ADC     byte_38
                STA     byte_38
                BCC     scan_next_line
                INC     byte_39

scan_next_line:                         
                JMP     find_program_scan_line
; End of function find_program




initialise:                             
                JSR     init_brkv_and_oshwm
                LDX     #$ff
                JSR     get_HIMEM_for_mode_X
                LDX     #0              ; default output streams
                LDA     #3              ; select output streams (AUG p119)
                JSR     osbyte_with_y0
                LDX     #0              ; keyboard on, rs423 off
                LDA     #2              ; select input stream (AUG p118)
                JSR     OSBYTE
                LDX     #0              ; enable cursor editing
                LDA     #4              ; enable/disable cursor editing (AUG p120)
                JSR     OSBYTE
                LDA     #13             ; Disable events (AUG p129)
                LDX     #9
                STX     byte_3A

disable_all_events_loop:                
                LDX     byte_3A
                JSR     osbyte_with_y0
; X=0 now
                DEC     byte_3A
                BPL     disable_all_events_loop
                LDA     #200            ; set ESCAPE, BREAK effect (AUG p205)
                LDY     #%11111110      ; normal ESCAPE action (bit 0 reset)
                JSR     OSBYTE
                LDX     #0              ; TAB key produces CHR$0
                LDA     #219            ; read/write TAB key char (AUG p222)
                JSR     osbyte_with_y0
                LDX     #27             ; ESCAPE key produces CHR$27
                LDA     #220            ; read/write Escape char (AUG p223)
                JSR     osbyte_with_y0
                LDX     #0              ; ignore key
                LDA     #225            ; read/write function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ignore key
                LDA     #226            ; read/write SHIFT+function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ignore key
                LDA     #227            ; read/write CTRL+function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ESCAPE has normal action
                LDA     #229            ; read/write status of ESCAPE key (AUG p227)
                JSR     osbyte_with_y0
                LDX     #0              ; ESCAPE has normal effects
                LDA     #230            ; read/write flags determining ESCAPE effects (AUG p228)
                JSR     osbyte_with_y0
                LDA     #3              ; printer off
                JSR     OSWRCH
                ASL                     ; VDU6 - enable VDU drivers
                JSR     OSWRCH
                LDA     #1
                STA     editor_mode_id  ; 1=command mode, 2=edit mode
                LDA     #0
                STA     byte_6B3
                RTS
; End of function initialise


loc_8437:
; Set cursor keys and COPY to produce ASCII                 
                LDX     #2
                LDA     #4
                JSR     OSBYTE
; Set function keys to produce ASCII $A0...$A9
                LDX     #$A0
                LDA     #225
                JSR     osbyte_with_y0
; Set SHIFT+function keys to produce ASCII $B0...$B9
                LDX     #$B0
                LDA     #226
                JSR     osbyte_with_y0
; Set Ctrl+function keys to produce ASCII $C0...$C9
                LDX     #$C0 ; 'À'
                LDA     #227
                JMP     osbyte_with_y0

brk_handler: .proc
                JSR     clear_5B1_to_600
                LDY     higher_order_address
                INY
                BNE     loc_846C
                LDY     higher_order_address+1
                INY
                BNE     loc_846C
                LDA     $FE
                CMP     #1
                BEQ     loc_846C
                CMP     #$C0
                BCC     loc_848A

loc_846C:                               
                SEI
                INC     $FD
                BNE     loc_8473
                INC     $FE

loc_8473:                               
                LDY     #0

loc_8475:                               
                LDA     ($FD),Y
                CMP     #$20 ; ' '
                BCC     loc_8483
		STA	$5B1,Y
		INY
		CPY	#$4F ; 'O'
		BCC	loc_8475

loc_8483:				
		CLI
		LDA	#-1
		STA	byte_15
		BNE	loc_848F

loc_848A:				
		LDA	#2
		JSR	get_error	; A = error code

loc_848F:
                jsr maybe_verbose_exit_on_error
                JMP	language_entry.loc_814D

.pend
                
sub_8492:				
		JSR	find_program
; End of function sub_8492




sub_8495:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2
		BNE	loc_849F
		JSR	make_cursor_invisible

loc_849F:				
		LDX	#10
		LDA	byte_C
		BPL	loc_84A7
		LDX	#3

loc_84A7:				
		STX	byte_3A
		LDA	oshwm
		STA	unk_33
		STA	byte_27
		LDA	oshwm+1
		STA	byte_28

loc_84B3:				
		LDY	#1
		LDA	(byte_27),Y
		BPL	loc_84BC
		JMP	loc_854F

loc_84BC:				
		LDY	#3
		LDA	(byte_27),Y
		STA	unk_37
		LDA	#0
		STA	byte_38
		INY
		STY	unk_34

loc_84C9:				
		LDY	unk_34
		CLC
		TYA
		ADC	#3
		BCS	loc_84D5
		CMP	unk_37
		BCC	loc_84D8

loc_84D5:				
		JMP	loc_853F

loc_84D8:				
		LDA	byte_38
		BEQ	loc_84DF

loc_84DC:				
		JMP	loc_852E

loc_84DF:				
		LDA	(byte_27),Y
		CMP	#$8D
		BNE	loc_84DC
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		JSR	sub_85AC

loc_84EB:				
		LDY	#1
		LDA	(byte_25),Y
		BPL	loc_8505
		LDX	#4
		STX	unk_33
		LDY	unk_34
		LDA	#$40 ; '@'

loc_84F9:				
		STA	($27),Y
		INY
		DEX
		BNE	loc_84F9
		DEY

loc_8500:				
		STY	unk_34
		JMP	loc_852E

loc_8505:				
		CMP	byte_21
		BNE	loc_8529
		INY
		LDA	($25),Y
		CMP	byte_22
		BNE	loc_8529
		LDX	byte_35
		LDY	byte_36
		JSR	sub_85D8
		STX	byte_36
		STY	byte_35
		LDY	unk_34
		LDX	#2

loc_851F:				
		INY
		STA	($27),Y
		LDA	$34,X
		DEX
		BPL	loc_851F
		BMI	loc_8500

loc_8529:				
		JSR	sub_85BF
		BNE	loc_84EB

loc_852E:				
		LDA	($27),Y
		CMP	#$22 ; '"'
		BNE	loc_853A
		LDA	byte_38
		EOR	#1
		STA	byte_38

loc_853A:				
		INC	unk_34
		JMP	loc_84C9

loc_853F:				
		LDY	#3
		CLC
		LDA	($27),Y
		ADC	byte_27
		STA	byte_27
		BCC	loc_854C
		INC	byte_28

loc_854C:				
		JMP	loc_84B3

loc_854F:				
		JSR	sub_85AC

loc_8552:				
		LDY	#1
		LDA	($25),Y
		BMI	loc_858A
		LDX	#$11

loc_855A:				
		LDY	#2
		LDA	$40,X
		CMP	($25),Y
		BNE	loc_8575
		DEX
		DEY
		LDA	$40,X
		CMP	($25),Y
		BNE	loc_8576
		LDA	byte_35
		ORA	#$80 ; '€'
		STA	$40,X
		INX
		LDA	byte_36
		STA	$40,X

loc_8575:				
		DEX

loc_8576:				
		DEX
		DEX
		BPL	loc_855A
		LDY	#1
		LDA	byte_35
		STA	($25),Y
		INY
		LDA	byte_36
		STA	($25),Y
		JSR	sub_85BF
		BNE	loc_8552

loc_858A:				
		LDX	#$10

loc_858C:				
		LDA	$40,X
		AND	#$7F ; ''
		STA	$40,X
		DEX
		DEX
		DEX
		BPL	loc_858C
		LDA	unk_33
		BEQ	locret_85BE
		LDA	#7

loc_859D:				
					
		LDX	unk_6AD
		BEQ	loc_85A6
		STA	unk_6AD
		RTS

loc_85A6:				
		JSR	get_error	; A = error code
		JMP	language_entry.loc_814D
; End of function sub_8495




sub_85AC:				
		LDA	oshwm
		STA	byte_25
		LDA	oshwm+1
		STA	byte_26
		LDA	unk_6B8
		STA	byte_35
		LDA	unk_6B9
		STA	byte_36

locret_85BE:				
		RTS
; End of function sub_85AC




sub_85BF:				
		LDY	#3
		CLC
		LDA	($25),Y
		ADC	byte_25
		STA	byte_25
		BCC	loc_85CC
		INC	byte_26

loc_85CC:				
		CLC
		LDA	byte_3A
		ADC	byte_36
		STA	byte_36
		BCC	locret_85D7
		INC	byte_35

locret_85D7:				
		RTS
; End of function sub_85BF




sub_85D8:				
		STX	byte_C
		STY	byte_D
		LDX	#1
		STX	byte_E

loc_85E0:				
		LDA	$C,X
		ASL
		ROL	byte_E
		ASL
		ROL	byte_E
		SEC
		ROR
		LSR
		STA	$C,X
		DEX
		BPL	loc_85E0
		LDA	byte_E
		ASL
		ASL
		EOR	#$14
		LDX	byte_D
		LDY	byte_C
		RTS
; End of function sub_85D8
                ; 0
error_messages_table:.byte  $C2	; Â
aAdProgram:	.text "ad program" ;1
		.byte  $D5 ; Õ
aNknownErrorMessage:.text "nknown error" ;2
		.byte  $CE ; Î
aORoomModeReset:.text "o room - Mode reset" ;3
		.byte  $CC ; Ì
aIneTooLong:	.text "ine too long" ;4
		.byte  $CE ; Î
aORoom:		.text "o room"   ;5
		.byte  $CD ; Í
aIssingLineCommand:.text "issing line command" ;6
		.byte  $D4 ; Ô
aArgetNotFound:	.text "arget not found" ;7
		.byte  $D3 ; Ó
aTringNotFound:	.text "tring not found" ;8
		.byte  $C2 ; É
aNvalidCommand:	.text "ad command" ;9
		.byte  $C2 ; É
aNvalidArgument:.text "ad argument" ;10
		.byte  $C2 ; Â
aAdNumber:	.text "ad number" ;11
		.byte  $D4 ; Ô
aOoManyArguments:.text "oo many arguments" ;12
		.byte  $C2 ; Ï
aNlyModes013467AreValid:.text "ad mode" ;13
		.byte  $CE ; Î
aORoomForThisMode:.text	"o room for this mode" ;14
		.byte  $CE ; Î
aOReferencesToLabelsWereFound:.text "o references to labels were found" ;15
		.byte  $D5 ; Õ
aNresolvedLabelsPleaseCheck:.text "nresolved labels - please check" ;16
		.byte  $CC ; Ì
aIneTooLongToBeNumbered:.text "ine too long to be numbered" ;17
		.byte  $CC ; Ì
aIneTooLongToContainLabel:.text	"ine too long to contain label" ;18
		.byte  $CE ; Î
aOLabelsReinstated:.text "o labels reinstated" ;19
		.byte  $CC ; Ì
aInesTooLongToBeJoined:.text "ines too long to be joined" ;20
		.byte  $CF ; Ï
aNlyColoursNRGYBMCWAreValid:.text "nly [NRGYBMCW] are valid" ;21
		.byte  $C2 ; É
aNvalidLineNumber:.text	"ad line number" ;22
		.byte  $D2 ; Ò
aEplaceStringMissing:.text "eplace string missing" ;23
		.byte  $CF ; Ï
aNlyTwoStringsAllowed:.text "nly two strings allowed" ;24
		.byte  $D3 ; Ó
aTartLineIncrementTooBig:.text "tart line/Increment too big" ;25
		.byte  $D4 ; Ô
aOoManyLineCommands:.text "oo many line commands" ;26
		.byte  $C9 ; É
aNcompatibleLineCommands:.text "ncompatible line commands" ;27
		.byte  $C2 ; É
aNvalidDeleteCommand:.text "ad delete command" ;28
		.byte  $C2 ; É
aNvalidDestination:.text "ad destination" ;29
		.byte  $C4 ; Ä
aEstinationMissing:.text "estination missing" ;30
		.byte  $C9 ; É
aNcompleteLineCommand:.text "ncomplete line command" ;31
		.byte  $C1 ; Á
aRgumentMissing:.text "rgument missing" ;32
		.byte  $D4 ; Ô
aAbStopMustBeInRange080:.text "ab stop must be 0-80" ;33
		.byte  $CE ; Î
aOMarkedLine:	.text "o marked line" ;34
		.byte  $CE ; Î
aOSearchStringSetUp:.text "o search string set up" ;35
		.byte  $CC ; Ì
aIneHasBeenTruncated:.text "ine has been truncated" ;36
		.byte  $D5 ; Õ
aPdatesWouldMakeLineTooLong:.text "pdates would make line too long" ;37
		.byte  $C9 ; É
aNcrementMustBeInRange1255:.text "ncrement must be 1-255" ;38
.text $CE;39
aOName:
.text "o name"                                 
aONameEnd:
                .byte  $FF ;
                
aSearchString:	.text "  Search string  : "
aReplaceString:	.text "  Replace string : "

hud_text_1_begin:
                .byte 26,12
hud_text_1_end:

hud_text_2_begin:
                .text 30,"Size:",31,13,0,"Free:",13,10,"Name: "
hud_text_2_end:
                
empty_program_string:.byte  $1F	;
		.byte	 3 ;
		.byte	 0 ;
		.byte  $31 ; 1
		.byte  $30 ; 0
nur_dlo_string:	.byte	$D 
		.byte  $4E ; N
		.byte  $55 ; U
		.byte  $52 ; R
		.byte	$D ;
		.byte  $44 ; D
		.byte  $4C ; L
		.byte  $4F ; O
six_spaces_string:.byte	 $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
byte_89C1:	.byte 7, 7, 7, 7, 7, 7,	7, $12 
byte_89C9:	.byte 7, 7, 7, 9, 7, 7,	9, $13 
byte_89D1:	.byte 7, 7, 7, 7, 7, 7,	7, $13 
colour_chars:	.text "NRGYBMCW"        
colour_names_table:.byte  $C2 
					
aLack:		.text "lack"
		.byte  $D2 ; Ò
aEd:		.text "ed"
		.byte  $C7 ; Ç
aReen:		.text "reen"
		.byte  $D9 ; Ù
aEllow:		.text "ellow"
		.byte  $C2 ; Â
aLue:		.text "lue"
		.byte  $CD ; Í
aAgenta:	.text "agenta"
		.byte  $C3 ; Ã
aYan:		.text "yan"
		.byte  $D7 ; ×
aHite:		.text "hite"
                .byte  $FF ;

help_footer_begin:
                .text "n",$D,$A
		.byte $A
                .text "Where p is a program; s, s1, s2 are strings; n, n1, n2 are numbers; c is a colour [NRGYBMCW].",$D,$A
help_footer_end:
                
aS1S2:		.text " s1 s2"
aN1N2:		.text " n1 n2"
aInsert: .text "Insert: "
aInsertEnd:
aScroll: .text "Scroll: "
aScrollEnd:
aCase: .text "Ignore search case: "
aCaseEnd:
aProgramName:	.text "Program name: "
aFirstLine:	.text "First line  : "
aLastLine:	.text "Last line  : "
aCurrentLine:	.text "Current line: "
aMarkedLine:	.text "Marked line: "
aNone:		.text "None"
aNo_ofLines:	.text "No.of lines: "
aPendingCommands:.text "Pending commands: "
aNone_1:	.text "None"
aOn:		.text " on "
aTabValue:	.text "Tab value   : "
aLastSearch:	.text "Last search : "
aNone_0:	.text "None"
aResetOSWRCH:
                .byte 3          ;printer off
                .byte 6          ;enable VDU drivers
                .byte 4          ;use text cursor
                .byte 26         ;restore default windows
                .byte 12         ;CLS
                .byte 15         ;disable paged mode
                .byte 20         ;reset VDU19 stuff
                .byte 17,7       ;COLOUR7
                .byte 17,128     ;COLOUR128
aResetOSWRCHEnd:
print_on_off .proc
                pha
                
                lda #'O'
                jsr oswrch

                pla
                beq ff

                lda #'n'
                bne print

ff:
                lda #'f'
                jsr oswrch
print:
                jmp oswrch
.pend
do_command_line .proc		
		JSR	clear_5B1_to_600
		LDA	#0
		STA	readline_ptr_lsb
		LDA	#7
		STA	readline_ptr_msb
		LDA	#100
		JSR	read_line
		BCC got_command_line
; ESCAPE was pressed

                ldx #$ff        ;FF=shift, FE=ctrl
                jsr poll_key
                beq bye
                
		LDA	unk_16
		BNE do_command_line_done
		JMP	loc_9D67	; enter	editing	mode

got_command_line:			
		JSR	parse_command_line
		JMP	execute_command	; unk_6BD = command to run

do_command_line_done:					
                RTS

bye:
                lda #CMD_EXIT
                sta current_command_id
                jmp run_or_exit_command
                
                
; End of function do_command_line
.pend
command_table
                .text "APPEND",0
		.byte	 9 ;
		.byte CMD_APPEND
                .text "BACK",0
                .byte  $21 ; !
                .byte CMD_BACK
                .text "CHANGE",0
                .byte  $15 ;
                .byte CMD_CHANGE
                .text "CASE",0,0,CMD_CASE
                .text "END",0
                .byte	 0 ;
                .byte CMD_END
                .text "EDIT",0
                .byte	 5 ;
                .byte CMD_EDIT
                .text "EXIT",0
                .byte	 0 ;
                .byte CMD_EXIT
                .text "FIND",0
                .byte	 5 ;
                .byte CMD_FIND
                .text "FORE",0
                .byte  $21 ; !
                .byte CMD_FORE
                .text "GOTO",0
                .byte	 0 ;
                .byte CMD_GOTO
                .text "HELP",0
                .byte	 0 ;
                .byte CMD_HELP
                .text "IE",0
                .byte	 0 ;
                .byte CMD_IE
                .text "INFO",0
                .byte	 0 ;
                .byte CMD_INFO
                .text "INSERT",0
                .byte	 0 ;
                .byte CMD_INSERT
                .text "IT",0
                .byte	 0 ;
                .byte CMD_IT
                .text "LOAD",0
                .byte	 9 ;
                .byte CMD_LOAD
                .text "LABEL",0
                .byte	 0 ;
                .byte CMD_LABEL
                .text "MODE",0
                .byte	 3 ;
                .byte CMD_MODE
                .text "NEW",0
                .byte	 0 ;
                .byte CMD_NEW
                .text "NOSCROLL",0
                .byte	 0 ;
                .byte CMD_NOSCROLL
                .text "NUMBER",0
                .byte	 0 ;
                .byte CMD_NUMBER
                .text "NOCASE",0,0,CMD_NOCASE
                .text "OLD",0
                .byte	 0 ;
                .byte CMD_OLD
                .text "OVERTYPE",0
                .byte	 0 ;
                .byte CMD_OVERTYPE
                .text "QCHANGE",0
                .byte  $15 ;
                .byte CMD_QCHANGE
                .text "RUN",0
                .byte	 0 ;
                .byte CMD_RUN
                .text "RENUMBER",0
                .byte  $45 ; E
                .byte CMD_RENUMBER
                .text "SAVE",0
                .byte	 9 ;
                .byte CMD_SAVE
                .text "SCROLL",0
                .byte	 0 ;
                .byte CMD_SCROLL
                .text "TOP",0
                .byte	 0 ;
                .byte CMD_TOP
                .text "TAB",0
                .byte	 3 ;
                .byte CMD_TAB

                .text "ZSAVE",0
                .byte 0
                .byte CMD_ZAUTOSAVE
                
                .text "ZRUN",0
                .byte 0
                .byte CMD_ZRUN

		.byte  $FF ;
byte_8C95:	.byte $A		
					
byte_8C96:	.byte 9			



parse_command_line:			
		LDY	#0
		STY	current_command_id
		LDA	#0
		STA	byte_C
		LDA	#7
		STA	byte_D
; Skip spaces at the start of the command line

skip_initial_spaces_loop:		
		LDA	(byte_C),Y
		CMP	#32
		BNE	found_non_space
		INC	byte_C
		BNE	loc_8CB0
		INC	byte_D

loc_8CB0:				
		BNE	skip_initial_spaces_loop

found_non_space:			
		CMP	#$D
		BEQ	done2

try_star:				; is it	looking	like a * command?
		CMP	#'*'
		BNE	try_number	; branch taken if it's not a * command
		LDA	#CMD_star	; ok, it IS a *	command

store_current_command:			
					
		STA	current_command_id

done2:					
		RTS

try_number:				
		JSR	atoi		; entry: (unk_C) points	to text;
					; exit:	C set if error,	or (byte_3E,byte_3F) holds value
		BCS	try_command	; branch taken if it doesn't look like a number
		LDY	#0

skip_number_loop:			
		LDA	(byte_C),Y	; get number char
		CMP	#13
		BEQ	is_line_number	; branch taken if end of command line
		CMP	#32
		BEQ	skip_post_number_spaces_loop ; branch taken if end of number
		INY
		BNE	skip_number_loop

skip_post_number_spaces_loop:		
					
		INY
		LDA	(byte_C),Y	; get whitespace char
		CMP	#13		; end of command line?
		BEQ	is_line_number	; branch taken if end of command line
		CMP	#32            ; just a space?
		BEQ	skip_post_number_spaces_loop ; keep going if so
; any non-space chars after the line number are invalid.
		LDA	#$16		; "Invalid line	number"
		JMP	loc_859D

is_line_number:				
					
		LDA	#CMD_goto_line
		BNE	store_current_command ;	JMP, in	effect

try_command:				
		JSR	find_first_non_alpha_char
		LDA	#<command_table
		STA	byte_E
		LDA	#>command_table
		STA	byte_F

try_this_command:			
		LDY	#0
		LDA	(byte_E),Y	; get next char	from command table
		BMI	invalid_command	; invalid, if reached end of table
		JSR	compare_cmd_char_to_input_char ; entry:	(unk_C)	points to input	char, (unk_E) points to	command	table char
					; exit:	C set if matched
		BCS	char_matched
; advance to next command in table

find_end_of_command_name_loop:		
		LDA	(byte_E),Y
		BEQ	found_end_of_command_name
		INY
		BNE	find_end_of_command_name_loop

found_end_of_command_name:		
		INY			; skip terminating 0
		INY			; skip args byte
		INY			; skip command ID
; add Y to table pointer
		CLC
		TYA
		ADC	byte_E
		STA	byte_E
		BCC	loc_8D12
		INC	byte_F

loc_8D12:				
		BNE	try_this_command ; JMP,	in effect

invalid_command:			
		LDA	#9		; "Invalid command"
		JMP	loc_859D

char_matched:				
		STY	byte_3A

find_end_of_command_name_loop_2:	
		LDA	(byte_E),Y
		BEQ	found_end_of_command_name_2
		INY
		BNE	find_end_of_command_name_loop_2

found_end_of_command_name_2:		
		INY			; skip terminating 0
		STY	byte_39		; $39 =	Y pointing into	data
		LDA	($E),Y		; get first byte of command data
		STA	byte_49		; $49 =	first byte of command data
		LDY	byte_3A
		LDA	($C),Y		; get last matched input char
		LDX	#0
		CMP	#13		; end of line there?
		BEQ	loc_8D52
		CMP	#'.'            ; abbreviated input?
		BNE	skip_spaces	; branch taken if not abbreviated
		INY			; just skip the	'.'
; Skip spaces after command

skip_spaces:				
					
		LDA	(byte_C),Y
		CMP	#32
		BNE	spaces_skipped
		INY
		BNE	skip_spaces

spaces_skipped:				
		CMP	#13		; end of command line?
		BEQ	loc_8D52
		INX			; X=1
; Set ($3E) to point to remainder of command line
		CLC
		TYA
		ADC	byte_C
		STA	byte_3E
		LDA	byte_D
		ADC	#0
		STA	byte_3F

loc_8D52:				
					
		TXA			; get 0	(no args entered) or 1 (args entered)
		EOR	byte_49		; Set bit 0 if state differs from command's requirements
		AND	#1		; Extract bit 0
		BEQ	loc_8D69	; Branch taken if command wants	args and some were entered/it doesn't and there weren't
		LDA	byte_49
		AND	#4		; String arg?
		BNE	loc_8D69	; branch taken if string arg wanted but	one wasn't supplied
; "Invalid argument" if an unnecessary one was specified; "Argument missing" if a necessary one wasn't.
		LDA	#$A		; "Invalid argument"
		DEX
		BEQ	loc_8D66
		LDA	#$20 ; ' '      ; "Argument missing"

loc_8D66:				
		JMP	loc_859D

loc_8D69:				
					
		TXA			; get 0	(no args entered) or 1 (args entered)
		BEQ	no_args_entered	; branch taken if no args entered
		LDA	byte_49		; get args byte
		AND	#2		; test bit 1 (single numeric arg)
		BEQ	loc_8D94	; branch taken if command wants	something else
; command wants single numeric argument
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	skip_post_number_spaces
		LDA	#$B		; "Bad number"
		JMP	loc_859D

skip_post_number_spaces:		
					
		LDA	(byte_C),Y
		CMP	#32
		BNE	skipped_post_number_spaces
		INY
		BNE	skip_post_number_spaces

skipped_post_number_spaces:		
		CMP	#13		; end of command line after the	number?
		BEQ	loc_8D94	; branch taken if so
					;
					; (This	branch is wrong, I think, as 8D94...
					; keeps	scanning from (byte_3E), even
					; though that now contains the number.
					; It wants to go to got_command	instead.)
		LDA	#$C		; "Too many arguments"
		JMP	loc_859D

no_args_entered:			
		LDA	#$FF		; mark lack of args ($FF isn't the MSB of any valid number)
		STA	byte_3F
		BNE	got_command	; JMP, in effect

loc_8D94:				
					
		LDY	#0

find_end_of_command_line_loop:		
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	found_end_of_command_line
		INY
		BNE	find_end_of_command_line_loop

found_end_of_command_line:		
		DEY

find_end_of_last_argument_loop:		
		LDA	(byte_3E),Y
		CMP	#$20 ; ' '
		BNE	found_end_of_last_argument
		DEY
		JMP	find_end_of_last_argument_loop

found_end_of_last_argument:		
		INY
		STY	byte_6BE

got_command:				
		LDY	byte_39		; get index into table (currently pointing at args byte)
		INY
		LDA	($E),Y		; get command ID
		JMP	store_current_command
; End of function parse_command_line



; Gets string representation of	16-bit number.
;
; Entry:
; Y,X =	value
;
; Exit:
; unk_0	holds digit count
; unk_1... filled with string

itoa:					
					
		LDA	unk_37
		PHA
		LDA	byte_38
		PHA
		LDA	byte_39
		PHA
		LDA	byte_3A
		PHA
		STX	unk_37
		STY	byte_38
		LDA	#0
		STA	byte_0

loc_8DCA:				
		LDA	#0
		STA	byte_39
		STA	byte_3A
		LDX	#$10
		CLC

loc_8DD3:				
		ROL	unk_37
		ROL	byte_38
		ROL	byte_39
		ROL	byte_3A
		SEC
		LDA	byte_39
		SBC	#$A
		TAY
		LDA	byte_3A
		SBC	#0
		BCC	loc_8DEB
		STY	byte_39
		STA	byte_3A

loc_8DEB:				
		DEX
		BNE	loc_8DD3
		ROL	unk_37
		ROL	byte_38
		LDA	byte_39
		CLC
		ADC	#$30 ; '0'
		LDY	byte_0
		BEQ	loc_8E02

loc_8DFB:				
		LDX	byte_0,Y
		STX	unk_1,Y
		DEY
		BNE	loc_8DFB

loc_8E02:				
		STA	unk_1
		INC	byte_0
		LDA	unk_37
		ORA	byte_38
		BNE	loc_8DCA
		PLA
		STA	byte_3A
		PLA
		STA	byte_39
		PLA
		STA	byte_38
		PLA
		STA	unk_37
		RTS
; End of function itoa



; entry: (unk_C) points	to input char, (unk_E) points to command table char
; exit:	C set if matched

compare_cmd_char_to_input_char:		
		LDY	#0

compare_cmd_char_to_input_char_loop:					
		LDA	(byte_C),Y	; input	char
		CMP	#$41 ; 'A'
		BCC	not_alpha
		CMP	#$5B ; '['
		BCS	not_alpha
		LDA	(byte_E),Y	; command table	char
		BEQ	didnt_match	; end of command?
		LDA	(byte_C),Y	; input	char
		CMP	#$2E ; '.'      ; abbreviated?
		BNE	loc_8E35

not_alpha:				
					
		CPY	#0		; non-alpha at start?
		BEQ	didnt_match	; if so, didn't match
		SEC			; otherwise, did match (e.g., "MO6" = "MO.6" = "MODE 6")
		RTS

loc_8E35:				
		CMP	(byte_E),Y
		BNE	didnt_match
		INY
		BNE	compare_cmd_char_to_input_char_loop		; input	char

didnt_match:				
					
		CLC
		RTS
; End of function compare_cmd_char_to_input_char




find_first_non_alpha_char:		
		LDY	#0

find_first_non_alpha_char_loop:					
		LDA	($C),Y
		CMP	#$41 ; 'A'
		BCC	locret_8E6B
		CMP	#$5B ; '['
		BCC	next_char
		CMP	#$61 ; 'a'
		BCC	locret_8E6B
		CMP	#$7B ; '{'
		BCS	locret_8E6B
		EOR	#$20 ; ' '
		STA	($C),Y

next_char:				
		INY
		BNE	find_first_non_alpha_char_loop		; don't think Y is ever supposed to get to 0 again...
; End of function find_first_non_alpha_char




toggle_case:				
		CMP	#$41 ; 'A'
		BCC	locret_8E6B
		CMP	#$5B ; '['
		BCC	loc_8E69
		CMP	#$61 ; 'a'
		BCC	locret_8E6B
		CMP	#$7B ; '{'
		BCS	locret_8E6B

loc_8E69:				
		EOR	#$20 ; ' '

locret_8E6B:				
					
		RTS
; End of function toggle_case



; Set memory to	value.
;
; ($C) points to memory	to clear.
; X holds number of pages to clear.
; Y holds number of bytes to clear in Xth page.
; A holds value	to write.

memset:.proc
					
		STA	byte_3A
		TYA
		PHA			; save old Y
		LDA	byte_3A
		LDY	#0
		CPX	#0
		BEQ	fill_last_page

fill_pages_loop:			
		STA	($C),Y		; write	byte
		INY			; next byte...
		BNE	fill_pages_loop	; do a whole page
		INC	byte_D		; next page
		DEX			; done all pages?
		BNE	fill_pages_loop	; taken	if not all pages done yet

fill_last_page:				
		TAY			; Y = value to store
		PLA			; get original Y back
		BEQ	memset_done		; if 0 bytes to	fill in	last page, done
		TAX			; X = #	bytes to fill in last page
		TYA			; A = value to store
		LDY	#0

fill_last_page_loop:			
		STA	($C),Y		; write	byte
		INY			; next byte...
		DEX			; done all bytes?
		BNE	fill_last_page_loop ; taken if not all bytes done yet

memset_done:					
                RTS
.pend
; End of function memset




osbyte_with_y0:.proc
					
		LDY	#0
		JSR	OSBYTE
                RTS
.pend
; End of function osbyte_with_y0



; print	number.
;
; Suitable for use with	the result of itoa.
;
; Entry:
; unk_0	= digit	count
; unk_1... = digits

print_number:				
					
		LDX	#1
		LDY	#0
		LDA	byte_0
		JSR	print_n_chars
		RTS
; End of function print_number



; move (maybe overlapping) memory regions.
;
; Entry:
; (byte_C) points to src
; (byte_E) points to dest
; X is MSB of size
; Y is LSB of size

memmove: .proc			
		LDA	byte_D		; get src MSB
		CMP	byte_F		; compare to dest MSB
		BCC	copy_down	; taken	if src<dest
		BEQ	copying_same_page ; taken if src MSB==dest MSB

copy_up:				
		TYA
		PHA			; save original	Y
		LDY	#0
		CPX	#0		; Any whole pages?
		BEQ	copy_up_last_page ; branch taken if no whole pages to copy

copy_up_pages_loop:			
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		INY
		BNE	copy_up_pages_loop ; branch taken if not copied	whole page yet
		INC	byte_D		; next src page
		INC	byte_F		; next dest page
		DEX			; one more page	done
		BNE	copy_up_pages_loop ; branch taken if not done all pages	yet

copy_up_last_page:			
		PLA
		TAX			; get original Y in X
		BNE	copy_up_last_page_loop ; branch	taken if any bytes to copy in last page
		RTS

copy_up_last_page_loop:			
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		INY
		DEX			; one more byte	done
		BNE	copy_up_last_page_loop ; branch	taken if not done all bytes yet
		RTS

copying_same_page:			
		LDA	byte_C		; get src LSB
		CMP	byte_E		; compare to dest LSB
		BCS	copy_up		; branch taken if src>=dest

copy_down:				
		TXA			; get page count
; Point src and dest at last page of each
		CLC
		ADC	byte_D
		STA	byte_D
		TXA
		CLC
		ADC	byte_F
		STA	byte_F
		CPY	#0		; any bytes to copy at the end?
		BEQ	copy_down_pages	; branch taken if no bytes to copy at the end

copy_down_last_page_loop:		
		DEY
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		CPY	#0		; was that the last byte just copied?
		BNE	copy_down_last_page_loop ; branch taken	if not on last byte

copy_down_pages:			
		CPX	#0		; any pages to copy?
		BEQ	memmove_done		; branch taken if no pages to copy

copy_down_pages_loop:			
		DEC	byte_D		; point	to last	whole page in src
		DEC	byte_F		; point	to last	whole page in dest

copy_down_page_loop:			
		DEY
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		CPY	#0		; was that the last byte just copied?
		BNE	copy_down_page_loop ; branch taken if not on last byte
		DEX			; one more page	done
		BNE	copy_down_pages_loop ; branch taken if more pages to copy

memmove_done:					
		RTS
; End of function memmove



.pend
gotoxy .proc					
					
		LDA	#31		; set cursor location
		JSR	OSWRCH
		TXA
		JSR	OSWRCH
		TYA
		JMP	OSWRCH
; End of function gotoxy



.pend

; print char in A.
print_1_char: .proc
                sta print_1_char_a
                stx print_1_char_x
                sty print_1_char_y

                lda editor_mode_id
                beq done

                ldy #0
                cmp #1
                beq start
                ldy #' '
                
start:
                sty byte_3A

                lda print_1_char_a
                cmp #$7f
                beq print_space

                lda #$87
                jsr osbyte      ;get mode in Y
                tya

                and #7
                cmp #7
                bne not_teletext

teletext:
                lda print_1_char_a
                cmp #141
                beq print_space

not_teletext:
                lda print_1_char_a
                cmp byte_3A
                bcs print_char

print_space:
                lda #' '

print_char:
                jsr oswrch
                
done:
                ldy print_1_char_y
                ldx print_1_char_x
                lda print_1_char_a
                rts
                
.pend

print_next_string: .proc
                pla
                sta byte_C
                pla
                sta byte_D

                ldy #0
loop:
                inc byte_C
                bne print
                inc byte_D
print:
                lda (byte_C),Y
                beq done
                jsr print_1_char
                jmp loop
                
done:
                lda byte_D
                pha
                lda byte_C
                pha
                rts
.pend

print_n_chars: .proc
                pha
                stx byte_C
                sty byte_D
                tax
                beq done

                ldy #0
loop:
                lda (byte_C),Y
                jsr print_1_char
                iny
                dex
                bne loop
done:
                pla
                rts
.pend



; work out dimensions of line.
;
; Entry:
; X=line length
; Y=starting Y
;
; Exit:
; X=line length	MOD screen width
; Y=ending Y
get_line_dimensions .proc
					
		LDA	byte_39
		PHA
		LDA	byte_3A
		PHA
		STX	byte_39
		STY	byte_3A
		LDY	#0

loc_8F5A:				
		LDA	byte_3A		; get Y
		BNE	loc_8F65	; taken	if Y not zero
		LDA	byte_39		; get X
		CMP	code_area_width	; reached effective screen width?
		BCC	loc_8F74	; taken	if effective screen width not yet reached.

loc_8F65:				
		SEC
		LDA	byte_39		; get X
		SBC	code_area_width	; subtract effective screen width
		STA	byte_39		; save X
		BCS	loc_8F71	; taken	if no borrow
		DEC	byte_3A		; borrow occurred, so decrement	Y

loc_8F71:				
		INY
		BNE	loc_8F5A

loc_8F74:				
		LDX	byte_39
		PLA
		STA	byte_3A
		PLA
		STA	byte_39
                RTS
.pend
; End of function get_line_dimensions



; entry: (byte_3E) points to command line;
; exit:	C set if error,	or (byte_3E, byte_3F) holds result.

atoi_from_command_line:			
					
		LDA	byte_3E
		STA	byte_C
		LDA	byte_3F
		STA	byte_D
; End of function atoi_from_command_line



; entry: (unk_C) points	to text;
; exit:	C set if error,	or (byte_3E,byte_3F) holds value

atoi:					
		LDX	#0
		STX	byte_3E
		STX	byte_3F
		LDY	#0
		LDA	(byte_C),Y
		PHA

atoi_loop:				
		LDA	(byte_C),Y
		CMP	#32
		BEQ	atoi_done		; branch taken if space	char
		CMP	#13
		BEQ	atoi_done		; branch taken if CR
		CMP	#'0'
		BCC	atoi_error		; branch taken if definitely not digit
		CMP	#$3A ; ':'
		BCC	is_digit	; branch taken if digit

atoi_error:					
		PLA
		SEC
		RTS

is_digit:				
		INX			; count	number of digits
		CPX	#5		; 5 digits?
		BEQ	check_most_significant_digit ; ==5 is OK
		BCC	add_digit	; <5 is	OK
		BCS	atoi_error		; >5 is	an error

check_most_significant_digit:		
		PLA
		PHA
		CMP	#$34 ; '4'
		BCS	atoi_error		; error	if most	significant digit >'3' (since 32767 is the largest valid value)

add_digit:				
		ASL	byte_3E
		ROL	byte_3F		; value*2
		LDA	byte_3F
		PHA
		LDA	byte_3E
		ASL	byte_3E
		ROL	byte_3F		; value*4
		ASL	byte_3E
		ROL	byte_3F		; value*8
; value*8 + value*2 (=value*10)
		CLC
		ADC	byte_3E
		STA	byte_3E
		PLA
		ADC	byte_3F
		STA	byte_3F
		LDA	($C),Y		; get char (which is known to be a digit)
		SEC
		SBC	#'0'            ; -'0' to make it a number
		CLC
		ADC	byte_3E
		STA	byte_3E		; add in to accumulator
		BCC	done_digit
		INC	byte_3F		; adjust high byte for carry

done_digit:				
		INY
		BNE	atoi_loop

atoi_done:					
		LDA	byte_3F
		BMI	atoi_error
		PLA
		CLC
		RTS
; End of function atoi



; unk_6BD = command to run

execute_command:			
					
		LDA	#<command_jump_table
		STA	byte_39
		LDA	#>command_jump_table
		STA	byte_3A

loc_8FEF:				
		LDY	#0
		LDA	(byte_39),Y	; get control byte
		STA	byte_49		; ?unk_49 = control byte
		CMP	#$FF		; end of table?
		BNE	loc_8FFA	; branch taken if not end of table

execute_command_done:					
		RTS

loc_8FFA:				
		INY
		LDA	($39),Y		; get command ID
		CMP	current_command_id ; is	it the desired command?
		BEQ	loc_9005	; branch taken if desired command found
		JMP	next_command
; Create thunk at unk_6B0: JMP <command routine>

loc_9005:				
		LDA	#$4C		; JMP absolute
		STA	unk_6B0
		STA	byte_6A7
		INY
		LDA	($39),Y		; get command routine ptr LSB
		STA	unk_6B1		; store	JMP target LSB
		INY
		LDA	($39),Y		; get command routine ptr MSB
		STA	unk_6B2		; store	JMP target MSB
		LDA	byte_49		; get control byte
		AND	#1		; extract bit 0
		STA	byte_6AB	; ?unk_6AB = unknown byte bit 1

check_bit_1:				; get control byte
		LDA	byte_49
		AND	#2		; extract bit 1
		BNE	check_bit_2	; branch taken if bit 1	reset
; bit 1 set
		LDA	unk_16
		BNE	execute_command_done

check_bit_2:				
		LDA	byte_49		; get control byte
		AND	#4		; extract bit 2
		BEQ	check_bit_3	; branch taken if bit 2	reset
; bit 2 set
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2		; edit mode?
		BEQ	check_bit_3	; branch taken if edit mode
; not in edit mode
		JSR	enter_edit_mode
		LDA	byte_49		; get control byte
		AND	#$10		; extract bit 4
		BEQ	check_bit_6	; branch taken if bit 4	reset
; bit 4 set
		JSR	is_program_empty ; sets	C if no	program
		BCC	check_bit_6	; branch taken if program is present
		JMP	loc_9DA8

check_bit_3:				
					
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2		; edit mode?
		BNE	check_bit_6
		LDA	byte_49
		AND	#8
		BEQ	check_bit_4
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCS	check_bit_4
		JSR	sub_A8C0

check_bit_4:				
					
		LDA	byte_49
		AND	#$10
		BEQ	check_bit_5
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	check_bit_5
		JMP	loc_9DA8

check_bit_5:				
					
		LDA	byte_49
		AND	#$20 ; ' '
		BEQ	check_bit_6
		STA	byte_6B3
		JSR	sub_A8C0

check_bit_6:				
					
		LDA	byte_49
		AND	#$40 ; '@'
		EOR	#$40 ; '@'
		STA	byte_6A7
		JMP	unk_6B0

next_command:				
		CLC
		LDA	byte_39		; ptr LSB
		ADC	#4		; add 4	(size of each entry)
		STA	byte_39
		BCC	command_ptr_ok
		INC	byte_3A

command_ptr_ok:				
		JMP	loc_8FEF
; End of function execute_command




clear_5B1_to_600:			
					
		LDA	#0
		STA	byte_15
		LDA	#<unk_5B1
		STA	byte_C
		LDA	#>unk_5B1
		STA	byte_D
		LDX	#0
		LDY	#$4F
		LDA	#$20
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.
		RTS
; End of function clear_5B1_to_600



; A = error code

get_error:				
					
		PHA
		LDA	byte_15		; already got an error?
		BEQ	copy_error	; taken	if no error yet
		PLA
		RTS

copy_error:				
		JSR	clear_5B1_to_600
		PLA
		STA	byte_15		; store	error code
		LDA	#<error_messages_table
		STA	byte_C
		LDA	#>error_messages_table
		STA	byte_D
		LDY	#0		; offset into errors table
		LDX	#0		; current error	index

find_error_loop:			
					
		LDA	($C),Y		; next byte from table
		BPL	loc_90C5	; taken	if still looking at the	current	error
; hit a negative char, so this means it's looking at the next error, so bump the error index.
		INX

loc_90C5:				
		CPX	byte_15		; reached the desired error?
		BEQ	found_error	; taken	if desired error reached
		INC	byte_C
		BNE	find_error_loop
		INC	byte_D
		BNE	find_error_loop

found_error:				
		LDX	#0

copy_error_loop:			
		AND	#$7F		; mask out top bit (in case)
		STA	unk_5B1,X	; store	in error message buffer
		INY			; next source byte...
		INX			; next dest byte...
		LDA	($C),Y		; load next byte from error table
                BPL	copy_error_loop	; taken	if haven't ended up in the next error
                jsr maybe_verbose_exit_on_error
		RTS
; End of function get_error




find_command:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	byte_50
		PHA
		LDA	byte_51
		PHA
		LDX	byte_3F		; get MSB of pointer to	arg
		INX			; X=0 if it was	FF before
		BNE	got_search_string ; branch taken if pointer to arg appears valid
		JSR	get_search_string ; gets search	string.
					;
					; Exit:
					; (byte_3E) points to result
					; byte_6BE is length of	input excluding	final CR.
					; C set	if nothing entered.
		BCS	loc_912C

got_search_string:			
		LDY	byte_6BE
		STY	byte_62		; ?byte_62 = search string length

copy_search_string_loop:		
		DEY
		LDA	(byte_3E),Y
		STA	unk_643,Y
		CPY	#0
		BNE	copy_search_string_loop
		LDA	#0
		STA	byte_6AF
; point (byte_2B) at OSHWM
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_910F:				
		LDA	#0
		STA	byte_3B		; reset	"found anything" flag

loc_9113:				
		LDY	#1		; index	of MSB of line number
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	(byte_2B),Y	; fetch	MSB of line number
		BPL	line_valid	; branch taken if line appears valid
; reached end of program
		LDA	byte_3B		; was anything found?
		BEQ	loc_9122	; branch taken if nothing was found
		JMP	loc_91A6

loc_9122:				
		LDA	byte_6AF
		BNE	loc_912C
		LDA	#8		; "String not found"
		JSR	get_error	; A = error code

loc_912C:				
					
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JMP	language_entry.loc_814D

line_valid:				
		JSR	detokenize_one_line
		JSR	sub_9260
		BCC	loc_91A0
		LDY	byte_6AF
		BNE	loc_918A
		INY
		STY	byte_6AF
		JSR	enter_edit_mode
		LDA	current_command_id
                CMP	#CMD_EDIT ;was this EDIT?
                BNE	loc_918A  ;taken if not EDIT (i.e., FIND)
                
loc_9163:
                ; command was EDIT.
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	cls_and_reset_6c0_to_6ff
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069
		JSR	position_edit_mode_cursor
		JMP	edit_mode_loop

loc_918A:				

                ; command was FIND.
		LDA	byte_3B
		BNE	loc_9191
		JSR	cls_and_reset_6c0_to_6ff

loc_9191:				
		JSR	sub_9E5F
		BCC	loc_91A6
		JSR	sub_9E82
		CLC
		LDA	byte_3B
		ADC	byte_2D
		STA	byte_3B

loc_91A0:				
		JSR	advance_2b_to_next_line
		JMP	loc_9113

loc_91A6:				
					
		LDA	#0
		STA	byte_3B

loc_91AA:				
					
		LDX	#0
		LDY	byte_3B
		JSR	gotoxy
                JSR	find_mode_getch

		CMP	#$1B
		BNE	loc_91BB
		JMP	loc_912C

loc_91BB:				
		CMP	#$A7 ; -$59 ;	'§'
                beq edit_found_line
                cmp #13
                bne loc_91C5
edit_found_line:
		JSR	sub_9247
		JMP	loc_9DA8

loc_91C5:				
		CMP	#$AF ; -$51 ;	'¯'
		BNE	loc_91E3
		LDA	byte_3B
		BNE	loc_91DE
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		TXA
		LSR
		STA	byte_3B
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_91DE:				
		DEC	byte_3B
		JMP	loc_91AA

loc_91E3:				
		CMP	#$AE
		BNE	loc_9203
		LDX	byte_3B
		INX
		CPX	screen_height
		BEQ	loc_91F5
		BCC	loc_91F5
		LDX	#0
		BEQ	loc_91FE

loc_91F5:				
					
		TXA
		ASL
		TAY
		LDA	$6C1,Y
		BNE	loc_91FE
		TAX

loc_91FE:				
					
		STX	byte_3B

loc_9200:				
		JMP	loc_91AA

loc_9203:				
		CMP	#$A5
		BNE	loc_920A
		JMP	loc_910F

loc_920A:				
		CMP	#$A2
		BNE	loc_9211
		JMP	top_edit_mode_command

loc_9211:				
		CMP	#$A3
		BNE	loc_9218
		JMP	end_edit_mode_command

loc_9218:				
		CMP	#$C1
		BNE	loc_922E
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	goto_edit_mode_command
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JMP	loc_91AA

loc_922E:				
		CMP	#$C0
		BNE	loc_9200
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_9247
		JSR	mark_edit_mode_command
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JMP	loc_91AA
; End of function find_command




sub_9247:				
					
		LDA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JMP	save_line_number ; saves line number from program.
; End of function sub_9247		;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number



advance_2b_to_next_line:		
					
		LDY	#3		; offset of line length
		CLC
		LDA	($2B),Y		; get line length
		ADC	byte_2B
		STA	byte_2B
		BCC	advance_2b_to_next_line_done
		INC	byte_2C

advance_2b_to_next_line_done:					
		RTS
                ; End of function advance_2b_to_next_line
                
normalize_search_case .proc
                bit case_insensitive_search
                bpl done
                cmp #'a'
                bcc done
                cmp #1+'z'
                bcs done
                and #$df
done:
                rts
.pend
sub_9260 .proc			
					
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_926B
		BCC	loc_926B

loc_9269:				
		CLC

locret_926A:				
		RTS

loc_926B:				
		CLC
		ADC	byte_6BE
		BCC	loc_9275
		CMP	#$26 ; '&'
		BCS	loc_9269

loc_9275:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CLC
		ADC	#<byte_400
		STA	byte_C
                LDA	#0
                tax
                tay
		ADC	#>byte_400
		STA	byte_D

loc_9286:
                lda (byte_C,X)
                jsr normalize_search_case
                sta search_tmp

                lda (byte_3E),Y
                jsr normalize_search_case
                cmp search_tmp
                BNE	loc_929A
next_byte:
		INY
		INC	byte_C
		BNE	loc_9293
		INC	byte_D

loc_9293:				
		CPY	byte_6BE
		BCS	locret_926A
		BCC	loc_9286

loc_929A:				
		INC	cursor_offset	; offset of cursor in detokenized buffer
                BNE	sub_9260
.pend

change_or_qchange_command .proc	
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	byte_50
		PHA
		LDA	byte_51
		PHA
		LDX	byte_3F
		INX
		BEQ	loc_9308
		LDY	#0

loc_92B1:				
		LDA	($3E),Y
		CMP	#$20 ; ' '
		BEQ	loc_92C3
		CMP	#$D
		BEQ	loc_92BE
		INY
		BNE	loc_92B1

loc_92BE:				
		LDA	#$17

loc_92C0:				
		JMP	loc_859D

loc_92C3:				
		STY	byte_6BE

loc_92C6:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_92BE
		CMP	#$20 ; ' '
		BNE	loc_92D3
		INY
		BNE	loc_92C6

loc_92D3:				
		CLC
		TYA
		ADC	byte_3E
		STA	unk_6BA
		LDA	byte_3F
		ADC	#0
		STA	unk_6BB
		LDX	#0

loc_92E3:				
		LDA	($3E),Y
		CMP	#$20 ; ' '
		BEQ	loc_92F1
		CMP	#$D
		BEQ	loc_9302
		INX
		INY
		BNE	loc_92E3

loc_92F1:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_9302
		CMP	#$20 ; ' '
		BNE	loc_92FE
		INY
		BNE	loc_92F1

loc_92FE:				
		LDA	#$18
		BNE	loc_92C0

loc_9302:				
		STX	unk_6BC
		JMP	loc_932C

loc_9308:				
		JSR	get_search_string ; gets search	string.
					;
					; Exit:
					; (byte_3E) points to result
					; byte_6BE is length of	input excluding	final CR.
					; C set	if nothing entered.
		BCS	loc_9312
		JSR	get_replace_string
		BCC	loc_932C

loc_9312:				
					
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		RTS

loc_932C:				
		LDA	#0
		STA	byte_6AF
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9337:				
		LDY	#0
		STY	byte_6B3
		STY	unk_11
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	($2B),Y
		BMI	loc_9369
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line

loc_934B:				
					
		JSR	sub_9260
		BCS	loc_9359
		JSR	sub_93CF
		JSR	advance_2b_to_next_line
		JMP	loc_9337

loc_9359:				
		LDA	current_command_id
		STA	byte_6AF
		CMP	#$E2
		BEQ	loc_937E
		JSR	sub_BDD3
		JMP	loc_934B

loc_9369:				
		LDA	byte_6AF
		BNE	loc_9312
		PLA
		PLA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		LDA	#8
		JSR	get_error	; A = error code

loc_937B:				
		JMP	language_entry.loc_814D

loc_937E:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2
		BEQ	loc_9388
		JSR	enter_edit_mode

loc_9388:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069
		JSR	position_edit_mode_cursor

loc_93A9:				
		JSR	find_mode_getch
		CMP	#$1B
		BEQ	loc_937B
		CMP	#$A7
		BNE	loc_93B7
		JMP	edit_mode_loop

loc_93B7:				
		AND	#$DF
		CMP	#'Y'
		BNE	loc_93C6
		JSR	sub_BDD3
		JSR	sub_93CF
		JMP	loc_934B

loc_93C6:				
		CMP	#'N'
		BNE	loc_93A9
		INC	cursor_offset	; offset of cursor in detokenized buffer
		JMP	loc_934B
; End of function sub_9260




sub_93CF:				
					
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_A8C0
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
                RTS
.pend
; End of function sub_93CF




load_command .proc				
		LDA	#$FF
		JSR	do_osfile_from_oshwm
		JSR	clear_line_commands
                JSR	sub_B358
                jsr store_program_name
                jmp sub_8314
.pend
                
append_command .proc
		JSR	is_program_empty ; sets	C if no	program
		BCS	load_command
		JSR	loc_946F
		LDA	#$FF
		JSR	do_osfile
		JSR	find_program
		BCC	locret_9424
		JSR	loc_946F
		STX	byte_C
		STY	byte_D
		LDY	#0
		LDA	#$D
		STA	($C),Y
		INY
		LDA	#$FF
		STA	($C),Y

locret_9424:				
                RTS
.pend

save_command2 .proc
                jsr save_command
                jmp store_program_name
.pend

save_command
		LDA	TOP
		STA	byte_27		; save end address LSB
		LDA	TOP+1
		STA	byte_28		; save end address MSB
		LDA	#0		; OSFILE save memory block

do_osfile_from_oshwm:				
		LDX	oshwm
		LDY	oshwm+1
                jmp	do_osfile

do_osfile .proc
		PHA			; save OSFILE code
		LDA	byte_3E
		STA	readline_ptr_lsb ; filename ptr	LSB
		LDA	byte_3F
		STA	readline_ptr_msb ; filename ptr	MSB
		STX	unk_1B		; load address LSB
		STX	unk_1F		; exec address LSB
		STX	byte_23		; save start address LSB
		STY	unk_1C		; load address MSB
		STY	byte_20		; exec address MSB
		STY	byte_24		; save start address MSB
		LDA	higher_order_address
		STA	unk_1D		; load address bits 16...23
		STA	byte_21		; exec address bits 16...23
		STA	byte_25		; save start address bits 16...23
		STA	unk_29		; save end address bits	16...23
		LDA	higher_order_address+1
		STA	unk_1E		; load address bits 24...31
		STA	byte_22		; exec address bits 24...31
		STA	byte_26		; save start address bits 24...31
		STA	unk_2A		; save end address bits	24...31
		PLA			; get OSFILE code
		TAX			; OSFILE code in X
		INX			; 1 if load, 0 if save
		BNE call_osfile	; branch if not	save
		STX	unk_1F		; when loading - use load address provided, not	file's default

call_osfile				
		LDX	#$19
		LDY	#0
                JMP	OSFILE		; OSFILE
.pend
; End of function save_command


loc_946F .proc
		LDY	TOP+1
		SEC
		LDA	TOP
		SBC	#2
		TAX
		BCS	locret_947A
		DEY

locret_947A:				
                RTS
.pend

; entry: ($19) points to buffer
;
; exit:	C=0 if Return, C=1 if Escape
; A is line length+1

read_line .proc
					
		STA	unk_1B		; maximum line length
		LDA	#$20
		STA	unk_1C		; min acceptable char
		LDA	#$FF
		STA	unk_1D		; max acceptable char
		LDA	#0		; read input line
		LDX	#$19
		LDY	#0
		JSR	OSWORD
		PHP
		INY
		TYA
		PHA
		BCC	loc_9497
		JSR	OSNEWL

loc_9497:				
		JSR	clear_escape_condition
		PLA
		PLP
                RTS
.pend
; End of function read_line



; read <100 chars to $700; points (byte_3E) at result, sets byte_6BE to	length.

read_line_700:				
		LDA	#0
		STA	readline_ptr_lsb
		STA	byte_3E
		LDA	#7
		STA	readline_ptr_msb
		STA	byte_3F
		LDA	#$64 ; 'd'
		JSR	read_line
		STA	byte_6BE
		RTS
; End of function read_line_700




read_line_780:				
		LDA	#$80
		STA	readline_ptr_lsb
		STA	unk_6BA
		LDA	#7
		STA	readline_ptr_msb
		STA	unk_6BB
		LDA	#$64
		JSR	read_line
		STA	unk_6BC
		RTS
; End of function read_line_780



; gets search string.
;
; Exit:
; (byte_3E) points to result
; byte_6BE is length of	input excluding	final CR.
; C set	if nothing entered.

get_search_string:			
					
		LDX	#<aSearchString
		LDY	#>aSearchString
		LDA	#$13
		JSR	print_n_chars
		JSR	read_line_700	; read <100 chars to $700; points (byte_3E) at result, sets byte_6BE to	length.
		BCS	locret_94DD
		DEC	byte_6BE	; ignore 13
		BNE	locret_94DD
		SEC			; set carry if empty

locret_94DD:				
					
		RTS
; End of function get_search_string




get_replace_string:			
		LDX	#<aReplaceString
		LDY	#>aReplaceString
		LDA	#$13
		JSR	print_n_chars
		JSR	read_line_780
		DEC	unk_6BC		; ignore 13
		RTS
; End of function get_replace_string




reset_keys_settings:			
					
		LDX	#0		; Enable cursor	editing	(default)
		LDA	#4		; Enable/disable cursor	editing	(AUG P120)
		JSR	OSBYTE
		LDX	#9
		LDA	#219		; set TAB key to 9
		JSR	osbyte_with_y0
		JSR	kbflush
		LDX	#1
		LDA	#225		; reset	F key status?
		JSR	osbyte_with_y0
		LDX	#128
		LDA	#226		; reset	Shift+F	key status?
		JSR	osbyte_with_y0
		LDX	#0
		LDA	#227
		JMP	osbyte_with_y0
; End of function reset_keys_settings




run_star_command:			
		LDX	#7
		JSR	get_HIMEM_for_mode_X
		JSR	reset_keys_settings
		LDX	#0
		LDY	#7
		JSR	OSCLI
		JMP	clear_5B1_to_600
; End of function run_star_command




getch:					
					
		JSR	OSRDCH
; End of function getch




clear_escape_condition:			
		PHA
		LDA	#$7E ; '~'
		JSR	OSBYTE
		PLA
; End of function clear_escape_condition

		RTS
command_jump_table:.byte $20		   ; unknown
		.byte CMD_return_key	; command_id
		.word return_key_command; address
		.byte $24		; unknown
		.byte CMD_IE		; command_id
		.word ie_cmd		; address
		.byte $24		; unknown
		.byte CMD_IT		; command_id
		.word it_cmd		; address
		.byte 8			; unknown
		.byte $1B		; command_id
		.word language_entry.loc_814D		; address
		.byte 0			; unknown
		.byte CMD_toggle_insert_overtype; command_id
		.word toggle_insert_overtype_command; address
		.byte $19		; unknown
		.byte $A2		; command_id
		.word top_edit_mode_command; address
		.byte $19		; unknown
		.byte CMD_f2_key	; command_id
		.word end_edit_mode_command; address
		.byte $19		; unknown
		.byte CMD_f4_key	; command_id
		.word renumber_edit_mode_command; address
		.byte $A		; unknown
		.byte CMD_EXIT		; command_id
		.word run_or_exit_command; address
		.byte 2			; unknown
		.byte CMD_NEW		; command_id
		.word new_command	; address
		.byte 1			; unknown
		.byte CMD_OLD		; command_id
		.word old_command	; address
		.byte 0			; unknown
		.byte CMD_shift_f2_key	; command_id
		.word undo_edit_mode_command; address
		.byte 0			; unknown
		.byte CMD_shift_f4_key	; command_id
		.word extend_statement_edit_mode_command; address
		.byte	 0 ;
		.byte CMD_shift_f3_key
		.word swap_case_edit_mode_command
		.byte $19		; unknown
		.byte $A7		; command_id
		.word top_of_screen_edit_mode_command; address
		.byte 0			; unknown
		.byte $A0		; command_id
		.word execute_edit_mode_command; address
		; .byte 8			; unknown
		; .byte CMD_shift_f5_key	; command_id
		; .word mode_edit_mode_command; address
		.byte 0			; unknown
		.byte $C7		; command_id
		.word background_edit_mode_command; address
		.byte 0			; unknown
		.byte $C8		; command_id
		.word foreground_edit_mode_command; address
		.byte 0			; unknown
		.byte $A6		; command_id
		.word delete_to_end_of_line_edit_mode_command; address
		.byte 1			; unknown
		.byte CMD_delete_key	; command_id
		.word delete_key_command; address
		.byte 1			; unknown
		.byte CMD_shift_delete_key; command_id
		.word loc_AAC8		; address
		.byte 0			; unknown
		.byte $AC		; command_id
		.word cursor_left_edit_mode_command; address
		.byte 0			; unknown
		.byte $AD		; command_id
		.word cursor_right_edit_mode_command; address
		.byte 0			; unknown
		.byte $AE		; command_id
		.word cursor_down_edit_mode_command; address
		.byte 0			; unknown
		.byte $AF		; command_id
		.word cursor_up_edit_mode_command; address
		.byte 0			; unknown
		.byte $BC		; command_id
		.word shift_cursor_left_edit_mode_command; address
		.byte 0			; unknown
		.byte $BD		; command_id
		.word shift_cursor_right_edit_mode_command; address
		.byte $18		; unknown
		.byte $BE		; command_id
		.word shift_cursor_down_edit_mode_command; address
		.byte $18		; unknown
		.byte $BF		; command_id
		.word shift_cursor_up_edit_mode_command; address
		.byte 0			; unknown
		.byte $CC		; command_id
		.word ctrl_cursor_left_edit_mode_command; address
		.byte 0			; unknown
		.byte $CD		; command_id
		.word ctrl_cursor_right_edit_mode_command; address
		.byte $10		; unknown
		.byte $CE		; command_id
		.word ctrl_cursor_down_edit_mode_command; address
		.byte $10		; unknown
		.byte $CF		; command_id
		.word ctrl_cursor_up_edit_mode_command;	address
		.byte 2			; unknown
		.byte CMD_LOAD		; command_id
		.word load_command	; address
		.byte 0			; unknown
		.byte CMD_APPEND	; command_id
		.word append_command	; address
		.byte 0			; unknown
		.byte CMD_SAVE		; command_id
		.word save_command2	; address
		.byte 0			; unknown
		.byte CMD_FIND		; command_id
		.word find_command	; address
		.byte $40		; unknown
		.byte CMD_CHANGE	; command_id
		.word change_or_qchange_command; address
		.byte $40		; unknown
		.byte CMD_QCHANGE	; command_id
		.word change_or_qchange_command; address
		.byte 2			; unknown
		.byte CMD_star		; command_id
		.word run_star_command	; address
		.byte 0			; unknown
		.byte 3			; command_id
		.word set_primary_line_command;	address
		.byte 0			; unknown
		.byte 4			; command_id
		.word set_primary_line_command;	address
		.byte 0			; unknown
		.byte $D		; command_id
		.word set_primary_line_command;	address
		.byte 1			; unknown
		.byte 1			; command_id
		.word loc_A245		; address
		.byte 1			; unknown
		.byte 2			; command_id
		.word loc_A245		; address
		.byte 1			; unknown
		.byte 5			; command_id
		.word loc_A245		; address
		.byte 1			; unknown
		.byte $14		; command_id
		.word loc_A245		; address
		.byte 1			; unknown
		.byte $12		; command_id
		.word loc_A258		; address
		.byte 0			; unknown
		.byte $63		; command_id
		.word loc_AD39		; address
		.byte 0			; unknown
		.byte $64		; command_id
		.word loc_AEB9		; address
		.byte 0			; unknown
		.byte $6D		; command_id
		.word loc_AD39		; address
		.byte 0			; unknown
		.byte $AB		; command_id
		.word copy_key_edit_mode_command; address
		.byte 0			; unknown
		.byte CMD_tab_key	; command_id
		.word tab_key_command	; address
		.byte 0			; unknown
		.byte CMD_RUN		; command_id
		.word run_or_exit_command; address
		.byte 0			; unknown
		.byte CMD_MODE		; command_id
		.word mode_command	; address
		.byte 0			; unknown
		.byte $C0		; command_id
		.word mark_edit_mode_command; address
		.byte $1D		; unknown
		.byte $C1		; command_id
		.word goto_edit_mode_command; address
		.byte $40		; unknown
		.byte CMD_NUMBER	; command_id
		.word number_command	; address
		.byte $40		; unknown
		.byte CMD_LABEL		; command_id
		.word label_command	; address
		.byte 0			; unknown
		.byte $C2		; command_id
		.word split_statement_edit_mode_command; address
		.byte 1			; unknown
		.byte $C3		; command_id
		.word join_statements_edit_mode_command; address
		.byte $21		; unknown
		.byte $C4		; command_id
		.word repeat_edit_mode_command;	address
		.byte 0			; unknown
		.byte CMD_SCROLL	; command_id
		.word scroll_command	; address
		.byte 0			; unknown
		.byte CMD_NOSCROLL	; command_id
		.word noscroll_command	; address
		.byte 2			; unknown
		.byte CMD_HELP		; command_id
		.word help_command	; address
		.byte 0			; unknown
		.byte CMD_FORE		; command_id
		.word fore_command	; address
		.byte 0			; unknown
		.byte CMD_BACK		; command_id
		.word back_command	; address
		.byte 0			; unknown
		.byte CMD_INSERT	; command_id
		.word insert_command	; address
		.byte 0			; unknown
		.byte CMD_OVERTYPE	; command_id
		.word overtype_command	; address
		.byte 2			; unknown
		.byte CMD_INFO		; command_id
		.word info_command	; address
		.byte $49		; unknown
		.byte CMD_shift_f6_key	; command_id
		.word label_edit_mode_command; address
		.byte $49		; unknown
		.byte CMD_shift_f7_key	; command_id
		.word number_edit_mode_command;	address
		.byte $14		; unknown
		.byte CMD_goto_line	; command_id
		.word goto_line_command		; address
		.byte 0			; unknown
		.byte CMD_RENUMBER	; command_id
		.word renumber_command	; address
		.byte 0			; unknown
		.byte CMD_TAB		; command_id
		.word tab_command	; address
		.byte 0			; unknown
		.byte CMD_GOTO		; command_id
		.word goto_command	; address
		.byte 8			; unknown
		.byte $A5		; command_id
		.word continue_edit_mode_command; address
		.byte 0			; unknown
		.byte CMD_EDIT		; command_id
		.word find_command	; address
		.byte $14		; unknown
		.byte CMD_TOP		; command_id
		.word top_command	; address
		.byte $14		; unknown
		.byte CMD_END		; command_id
		.word end_command	; address
		.byte 0			; unknown
		.byte CMD_shift_tab_key	; command_id
                .word loc_9783		; address
                .byte 0                  ; unknown
                .byte CMD_ZAUTOSAVE      ; command_id
                .word zsave_command          ; address
                .byte 0,CMD_CASE
                .word case_command
                .byte 0,CMD_NOCASE
                .word nocase_command
                .byte 0,CMD_ZRUN
                .word zrun_command
                
		.byte  $FF ;

loc_967A:				
		JSR	sub_9698
		BCS	loc_9695
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JMP	sub_9FD8

loc_9695:				
		JMP	loc_9DA8



sub_9698:				
		LDA	byte_6C0
		STA	byte_27
		LDA	byte_6C1
		STA	byte_28
		CMP	#-1
		BEQ	loc_96BB
		LDY	#1
		LDA	current_line_no_lsb
		CMP	($27),Y
		BCS	loc_96B0

loc_96AE:				
		SEC
		RTS

loc_96B0:				
		BNE	loc_96BD
		INY
		LDA	current_line_no_msb
		CMP	($27),Y
		BCC	loc_96AE
		BNE	loc_96BD

loc_96BB:				
		CLC
		RTS

loc_96BD:				
		LDX	#$3F ; '?'

loc_96BF:				
		LDA	$6C0,X
		STA	$700,X
		DEX
		BPL	loc_96BF
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	#0
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_BA69
		TXA
		LSR
		CMP	screen_height
		BEQ	loc_96F7
		BCS	loc_96F8

loc_96F7:				
		CLC

loc_96F8:				
		PHP
		LDX	#$3F ; '?'

loc_96FB:				
		LDA	$700,X
		STA	$6C0,X
		DEX
		BPL	loc_96FB
		PLP
		RTS
; End of function sub_9698




sub_9706:				
		LDA	#0
		STA	byte_3B
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		RTS
; End of function sub_9706


tab_key_command:			
		LDA	unk_61
		STA	unk_6AA

loc_9720:				
		JSR	make_cursor_invisible
		LDA	byte_39
		PHA
		LDX	unk_6AA
		BEQ	loc_976D
		INX
		STX	byte_39
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		LDY	unk_11
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		TXA
		BNE	loc_973C
		LDA	code_area_width
		TAX

loc_973C:				
		CMP	byte_39
		BCC	loc_9745
		SBC	unk_6AA
		BNE	loc_973C

loc_9745:				
		STA	byte_3A
		SEC
		LDA	byte_39
		SBC	byte_3A
		TAY
		STX	byte_3A
		CLC
		ADC	byte_3A
		CMP	code_area_width
		BEQ	loc_9762
		BCC	loc_9762
		LDA	code_area_width
		SBC	byte_3A
		CLC
		ADC	#1
		TAY

loc_9762:				
		STY	unk_6AA

loc_9765:				
		JSR	cursor_right_edit_mode_command
		DEC	unk_6AA
		BNE	loc_9765

loc_976D:				
		PLA
		STA	byte_39
		RTS

tab_command:				
		LDA	byte_3F
		BEQ	loc_977A

loc_9775:				
		LDA	#$21 ; '!'
		JMP	loc_859D

loc_977A:				
		LDA	byte_3E
		CMP	#$51 ; 'Q'
		BCS	loc_9775
		STA	unk_61
		RTS

loc_9783:				
		LDA	#$50 ; 'P'
		STA	unk_6AA
		JMP	loc_9720

continue_edit_mode_command:		
		LDA	byte_62
		BNE	loc_9794
		LDA	#$23 ; '#'

loc_9791:				
		JMP	loc_859D

loc_9794:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_979D

loc_9799:				
		LDA	#8
		BNE	loc_9791

loc_979D:				
		LDA	#$43 ; 'C'
		STA	byte_3E
		LDA	#6
		STA	byte_3F
		LDA	byte_62
		STA	byte_6BE
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_97B0
		INC	unk_11

loc_97B0:				
		LDA	unk_11
		BEQ	loc_97C4
		BNE	loc_97F0

loc_97B6:				
		LDY	#0
		STY	unk_11
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	($2B),Y
		BMI	loc_9799
		JSR	detokenize_one_line

loc_97C4:				
		JSR	sub_9260
		BCC	loc_97F0
		LDA	byte_2B
		CMP	byte_6C0
		BNE	loc_97ED
		LDA	byte_2C
		CMP	byte_6C1
		BNE	loc_97ED
		LDA	byte_6B3
		BEQ	loc_97EA
		JSR	sub_AA17
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069

loc_97EA:				
		JMP	position_edit_mode_cursor

loc_97ED:				
		JMP	loc_9163

loc_97F0:				
		JSR	advance_2b_to_next_line
		JMP	loc_97B6

split_statement_edit_mode_command:	
		JSR	rstrip_detokenized_line
		CPY	#0
		BEQ	loc_9801
		LDA	unk_11
		BEQ	loc_9804

loc_9801:				
		JMP	beep

loc_9804:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	#1
		BEQ	loc_9801
		CMP	byte_400
		BEQ	loc_9811
		BCS	loc_9801

loc_9811:				
		LDY	#0

loc_9813:				
		LDA	$400,Y
		STA	$700,Y
		DEY
		BNE	loc_9813
		JSR	sub_A8C0
		LDY	#0

loc_9821:				
		LDA	$700,Y
		STA	$400,Y
		DEY
		BNE	loc_9821
		JSR	sub_9968
		PHA
		CMP	#0
		BNE	loc_9835
		JMP	loc_98DB

loc_9835:				
		LDA	byte_400
		CMP	#-5 ; 'û'
		BNE	loc_9840

loc_983C:				
		PLA
		JMP	renumber_edit_mode_command

loc_9840:				
		LDY	byte_400

loc_9843:				
		LDA	$400,Y
		CMP	#7
		BEQ	loc_983C
		DEY
		BNE	loc_9843
		LDY	byte_400

loc_9850:				
		LDA	$400,Y
		STA	$401,Y
		CPY	cursor_offset	; offset of cursor in detokenized buffer
		BEQ	loc_985D
		DEY
		BNE	loc_9850

loc_985D:				
		LDA	#7
		STA	$400,Y
		INC	byte_400
		LDA	#1
		STA	byte_6B3
		LDA	#0
		STA	byte_6A7
		JSR	sub_A8C0
		INC	byte_6A7
		LDA	#-1
		STA	unk_6AD
		JSR	sub_8492
		LDA	unk_6AD
		CMP	#-1
		BEQ	loc_9892
		JSR	sub_999A

loc_9887:				
		LDA	unk_6AD
		LDX	#0
		STX	unk_6AD
		JMP	loc_859D

loc_9892:				
		JSR	detokenize_one_line
		LDA	unk_6AD
		CMP	#-1
		BEQ	loc_98B5
		JSR	sub_999A
		LDA	#-1
		STA	unk_6AD
		JSR	detokenize_one_line
		LDA	unk_6AD
		CMP	#-1
		BNE	loc_9887
		INC	unk_6AD
		PLA
		JMP	loc_967A

loc_98B5:				
		INC	unk_6AD
		LDY	byte_400

loc_98BB:				
		LDA	$400,Y
		CMP	#7
		BEQ	loc_98C5
		DEY
		BNE	loc_98BB

loc_98C5:				
		STY	cursor_offset	; offset of cursor in detokenized buffer

loc_98C7:				
		LDA	$401,Y
		STA	$400,Y
		INY
		CPY	byte_400
		BNE	loc_98C7
		LDA	#$20 ; ' '
		STA	$400,Y
		DEC	byte_400

loc_98DB:				
		PLA
		STA	byte_36
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_C
		LDA	#4
		ADC	#0
		STA	byte_D
		LDA	#1
		STA	byte_E
		LDA	#7
		STA	byte_F
		SEC
		LDA	byte_400
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		TAY
		INY
		STY	unk_700
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		STX	byte_400
		LDA	#1
		STA	byte_6B3
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	byte_35
		LDA	#0
		STA	byte_C
		LDA	#7
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDY	unk_700
		INY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_992F:				
		LDX	current_line_no_lsb
		LDY	current_line_no_msb
		INC	current_line_no_msb
		BNE	loc_9939
		INC	current_line_no_lsb

loc_9939:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		TXA
		PHA
		TYA
		PHA
		LDA	byte_36
		PHA
		LDX	byte_35
		JMP	loc_AFBB



repeat_edit_mode_command:		
		JSR	sub_995B
		STA	byte_36
		JSR	detokenize_one_line
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	byte_35
		JMP	loc_992F
; End of function repeat_edit_mode_command




sub_995B:				
		JSR	sub_9968
		PHA
		CMP	#0
		BEQ	loc_9966
		JSR	sub_8492

loc_9966:				
		PLA
		RTS
; End of function sub_995B




sub_9968:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_9997
		LDY	#3
		CLC
		LDA	(byte_2B),Y
		ADC	byte_2B
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDX	current_line_no_lsb
		LDY	current_line_no_msb
		INY
		BNE	loc_9986
		INX
		BMI	loc_9993

loc_9986:				
		TYA
		LDY	#2
		CMP	(byte_C),Y
		BNE	loc_9997
		DEY
		TXA
		CMP	(byte_C),Y
		BNE	loc_9997

loc_9993:				
		LDA	#1
		BNE	locret_9999

loc_9997:				
		LDA	#0

locret_9999:				
		RTS
; End of function sub_9968




sub_999A:				
		JSR	find_program
		LDY	#4

loc_999F:				
		LDA	($2B),Y
		CMP	#7
		BEQ	loc_99A8
		INY
		BNE	loc_999F

loc_99A8:				
		TYA
		CLC
		ADC	byte_2B
		STA	byte_C
		STA	byte_E
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		STA	byte_F
		INC	byte_C
		BNE	loc_99BE
		INC	byte_D

loc_99BE:				
		SEC
		LDA	TOP
		SBC	byte_C
		TAY
		LDA	TOP+1
		SBC	byte_D
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#3
		LDA	($2B),Y
		SEC
		SBC	#1
		STA	($2B),Y
		RTS
; End of function sub_999A


renumber_command:			
		LDA	#$A
		STA	unk_6B9
		TAX
		LDA	#0
		STA	unk_6B8
		LDA	byte_3F
		BPL	loc_99E8
		JMP	loc_9A8B

loc_99E8:				
		LDY	#1

loc_99EA:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_99FD
		CMP	#$2C ; ','
		BNE	loc_99FA
		LDA	#$20 ; ' '
		STA	($3E),Y
		BNE	loc_99FD

loc_99FA:				
		INY
		BNE	loc_99EA

loc_99FD:				
		LDA	byte_3E
		PHA
		LDA	byte_3F
		PHA
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	loc_9A0D
		LDA	#$B
		JMP	loc_859D

loc_9A0D:				
		LDA	byte_3F
		STA	unk_6B8
		LDA	byte_3E
		STA	unk_6B9
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
		LDY	#0

loc_9A1F:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_9A39
		CMP	#$20 ; ' '
		BEQ	loc_9A2C
		INY
		BNE	loc_9A1F

loc_9A2C:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_9A39
		CMP	#$20 ; ' '
		BNE	loc_9A3E
		INY
		BNE	loc_9A2C

loc_9A39:				
		LDX	#$A
		JMP	loc_9A99

loc_9A3E:				
		CLC
		TYA
		ADC	byte_3E
		STA	byte_3E
		PHA
		BCC	loc_9A49
		INC	byte_3F

loc_9A49:				
		LDA	byte_3F
		PHA
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	loc_9A56
		LDA	#$B
		JMP	loc_859D

loc_9A56:				
		LDA	byte_3F
		BEQ	loc_9A5F

loc_9A5A:				
		LDA	#$26 ; '&'
		JMP	loc_859D

loc_9A5F:				
		LDA	byte_3E
		BEQ	loc_9A5A
		TAX
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
		LDY	#0

loc_9A6C:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_9A99
		CMP	#$20 ; ' '
		BEQ	loc_9A79
		INY
		BNE	loc_9A6C

loc_9A79:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_9A99
		CMP	#$20 ; ' '
		BNE	loc_9A86
		INY
		BNE	loc_9A79

loc_9A86:				
		LDA	#$C
		JMP	loc_859D

loc_9A8B:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	locret_9AD7
		JSR	sub_9AAD
		LDA	byte_39
		BPL	loc_9AAA
		LDX	#3

loc_9A99:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	locret_9AD7
		JSR	sub_9AAD
		LDA	byte_39
		BPL	loc_9AAA
		LDA	#$19
		JMP	loc_859D

loc_9AAA:				
		JMP	loc_84A7



sub_9AAD:				
		LDA	unk_6B8
		STA	byte_39
		LDA	unk_6B9
		STA	byte_3A
		LDA	oshwm
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9ABF:				
		JSR	advance_2b_to_next_line
		LDY	#1
		LDA	($2B),Y
		BMI	locret_9AD7
		CLC
		TXA
		ADC	byte_3A
		STA	byte_3A
		BCC	loc_9AD4
		INC	byte_39
		BMI	locret_9AD7

loc_9AD4:				
		JMP	loc_9ABF

locret_9AD7:				
		RTS
; End of function sub_9AAD




edit_mode_loop:				
					
		LDX	#$FF
		TXS
		STX	byte_6A7
		LDA	byte_6AB
		BEQ	loc_9AE6
		JSR	kbflush

loc_9AE6:				
		LDX	#0
		LDY	#$FF
		LDA	#216		; read length of soft key string
		JSR	OSBYTE		; flush	pending	soft key expansion
		STX	byte_3A		; save old value (??)
		JSR	reset_cursor_shape
		JSR	getch

check_return_key:			; return?
		CMP	#13
		BNE	check_tab_key
		LDA	#CMD_return_key
		BNE	run_command

check_tab_key:				
		CMP	#9
		BNE	check_delete_key
		LDA	#CMD_tab_key
		BNE	run_command

check_delete_key:			
		CMP	#$7F ; ''
		bne check_copy_key
                LDA	#CMD_delete_key
                bne run_command

check_copy_key:
                cmp #$ab
                bne run_command
                lda #CMD_shift_delete_key
                
run_command:				
					
		STA	current_command_id
		LDX	#0
		LDY	#$FF
		LDA	#216
		JSR	OSBYTE
		TXA
		ORA	byte_3A		; check	if both	soft key expansion states were 0
		BEQ	loc_9B2C	; branch taken if both were
		LDA	current_command_id
		CMP	#$20 ; ' '
		BCC	loc_9B28

loc_9B25:				
					
		JMP	dispatch_command

loc_9B28:				
		LDA	#$20 ; ' '
		BNE	set_command	; JMP, in effect

loc_9B2C:				
		LDX	#$FF		; query	keyboard buffer
		LDY	#$FF
		LDA	#128
		JSR	OSBYTE		; get ADVAL/buffer status (AUG p151)
		TXA
		BNE	loc_9B25	; branch taken if any keys in keyboard buffer
		LDA	current_command_id
		CMP	#CMD_return_key
		BNE	loc_9B4E
		LDX	#$9A
		JSR	poll_key	; poll state of	key.
					;
					; Entry:
					; X = -ve INKEY	value
					;
					; Exit:
					; X = 0	and Z set if key pressed
		BNE	loc_9B25
		LDA	#$D

set_command:				
					
		STA	current_command_id
		JMP	dispatch_command

loc_9B4E:				
		CMP	#CMD_tab_key
		BNE	loc_9B5D
		LDX	#$DA		; I key
		JSR	poll_key	; poll state of	key.
					;
					; Entry:
					; X = -ve INKEY	value
					;
					; Exit:
					; X = 0	and Z set if key pressed
		BNE	loc_9B5D	; branch taken if I not	pressed
		LDA	#9		; set command 9	(think this is some kind of fudge to stop Ctrl+I doing anything)
		BNE	set_command

loc_9B5D:				
					
		LDX	#0		; Don't change anything
		LDY	#$FF		; Read old value
		LDA	#202
		JSR	OSBYTE		; Read keyboard	status byte (AUG p207)
		STX	byte_38		; bit 3	- 1 if SHIFT pressed
					; bit 4	- 0 if CAPS LOCK engaged
					; bit 5	- 0 if SHIFT LOCK engaged
					; bit 6	- 1 if CTRL pressed
					; bit 7	- 1 if SHIFT is	to reverse CAPS	LOCK/SHIFT LOCK	status

check_shift_delete_key:
		LDA	current_command_id
		CMP	#CMD_delete_key
		BNE	check_shift_tab_key
		LDA	#8
		BIT	byte_38		; Check	SHIFT state
		BEQ	dispatch_command ; Branch taken	if SHIFT not pressed
		LDA	#CMD_shift_delete_key
		STA	current_command_id
		BNE	dispatch_command ; JMP,	in effect

check_shift_tab_key:			
		CMP	#CMD_tab_key
		BNE	dispatch_command
		LDA	#8
		BIT	byte_38		; Check	SHIFT state
		BEQ	dispatch_command ; Branch taken	if SHIFT not pressed
		LDA	#CMD_shift_tab_key
		STA	current_command_id

dispatch_command:			
					
		LDA	current_command_id
		CMP	#$20 ; ' '
		BCC	execute_non_key_command
		CMP	#$A0
		BCS	execute_non_key_command
		JSR	execute_key_command ; treats command ID	as ASCII char and puts that char into the current line as appropriate.
		JMP	edit_mode_loop

execute_non_key_command:		
					
		JSR	execute_command	; unk_6BD = command to run
		JMP	edit_mode_loop
; End of function edit_mode_loop



; poll state of	key.
;
; Entry:
; X = -ve INKEY	value
;
; Exit:
; X = 0	and Z set if key pressed

poll_key:				
					
		LDY	#$FF
		LDA	#129
		JSR	OSBYTE
		INX
		RTS
; End of function poll_key




make_cursor_invisible:			
					
		LDX	#10
		LDY	#32
; End of function make_cursor_invisible



; X = CRTC register
; Y = value

write_crtc:				
					
		PHA			; save A
		TYA
		PHA			; save Y
		TXA
		TAY			; value	to write = original X
		LDX	#0		; $FE00	(CRTC register select)
		LDA	#151		; write	SHEILA
		JSR	OSBYTE
		PLA
		TAY			; value	to write = original Y
		LDX	#1		; $FE01	(CRTC register value)
		LDA	#151		; write	SHEILA
		JSR	OSBYTE
		PLA
		RTS
; End of function write_crtc




reset_cursor_shape:			
					
		JSR	get_current_mode_in_x
		LDA	#0
		LDY	is_insert_mode	; 0=overtype 1=insert
		BNE	loc_9BD2
		LDA	byte_89C1,X

loc_9BD2:				
		ORA	unk_31
		TAY
		LDX	#10
		JSR	write_crtc
		JSR	get_current_mode_in_x
		LDA	is_insert_mode	; 0=overtype 1=insert
		BNE	loc_9BE6
		LDY	byte_89C9,X
		BNE	loc_9BE9

loc_9BE6:				
		LDY	byte_89D1,X

loc_9BE9:				
		LDX	#11
		JMP	write_crtc
; End of function reset_cursor_shape




get_current_mode_in_x:			
					
		LDA	#135
		JSR	OSBYTE
		TYA
		TAX
		RTS
; End of function get_current_mode_in_x




kbflush:				
					
		LDX	#0		; Flush	keyboard buffer
		STX	byte_6AB
		LDA	#21		; Flush	specific buffer	(AUG p138)
		JSR	OSBYTE
		LDA	#216		; Read/write length of soft key	string
		JSR	osbyte_with_y0	; Cancel any current soft key expansion
		JMP	clear_escape_condition
; End of function kbflush




detokenize_one_line:			
					
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
		LDX	#0
		STX	byte_400
		STX	byte_6A8
		INX			; X=1
		LDY	#$24 ; '$'
		LDA	#$20 ; ' '
		JSR	memset		; Clear	$401 - $525
		LDX	byte_2C		; get MSB of address
		INX
		BNE	loc_9C26	; branch taken if MSB of address wasn't $FF

locret_9C25:				
		RTS

loc_9C26:				
		JSR	detokenize_line	; detokenize line and store result.
					;
					; Entry:
					; (byte_2B) points to line
					;
					; Exit:
					; $400 = line length
					; $401... = line text
					; unk_6A8 incremented if line too long
		LDA	byte_6A8	; line too long?
		BEQ	locret_9C25	; branch taken if line not too long
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	#4		; "Line	too long"
		JMP	loc_859D
; End of function detokenize_one_line



; detokenize line and store result.
;
; Entry:
; (byte_2B) points to line
;
; Exit:
; $400 = line length
; $401... = line text
; unk_6A8 incremented if line too long

detokenize_line:			
					
		CLC
; Point (unk_27) at start of data of current line
		LDA	byte_2B
		ADC	#4		; +4 - skip 13,	line MSB, line LSB, line length.
		STA	byte_27
		LDA	byte_2C
		STA	byte_28
		BCC	loc_9C45
		INC	byte_28

loc_9C45:				
		LDA	#0
		STA	byte_400
		STA	byte_23		; index	in body	of line
		STA	byte_25		; not inside quotes
		LDY	#3		; index	of line	length
		LDA	(byte_2B),Y	; get total line length
		SEC
		SBC	#4		; subtract 4 as	the metadata is	already	considered
		STA	byte_24		; ?unk_24 = length of body of line
		BEQ	detokenize_line_done		; branch taken if line is empty

loc_9C59:				
		LDA	#4
		STA	byte_F
		CLC
		LDA	#1
		ADC	byte_400
		STA	byte_E
		BCC	loc_9C69
		INC	byte_F

loc_9C69:				
		LDX	byte_24		; get line length
		DEX			; -1 to	get index of last byte
		CPX	byte_23		; compare to current index
		BCS	loc_9C71	; branch taken if there's still more data to go

detokenize_line_done:					
		RTS

loc_9C71:				
		LDA	byte_25		; in string?
		BEQ	copy_tokenized	; branch taken if not in string
; point (byte_C) at byte in program

not_token:				
					
		LDA	byte_28
		STA	byte_D
		LDA	byte_23
		CLC
		ADC	byte_27
		STA	byte_C
		BCC	copy_whilst_checking_for_quotes
		INC	byte_D

copy_whilst_checking_for_quotes:	
		LDY	byte_23
		LDA	(byte_27),Y	; get next byte
		CMP	#34            ; quotes?
		BNE	read_byte
; toggle 'in quotes' flag
		LDA	byte_25
		EOR	#1
		STA	byte_25

read_byte:				
		LDY	#1
		BNE	advance

copy_tokenized:				
		LDY	byte_23
		LDA	(byte_27),Y	; get next byte	from line
		BPL	not_token	; if positive, not a taken
		CMP	#$8D		; is this a line number?
		BNE	token		; branch taken if not a	line number
		TYA
		CLC
		ADC	#3		; +3 - skip line number	data
		BCS	not_token	; if carry set,	assume end of line
		CMP	byte_24		; past end of line?
		BCS	not_token	; branch taken if past end of line
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		LDX	byte_22
		LDY	byte_21
		JSR	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string
		LDA	#<unk_1
		STA	byte_C
		LDA	#>unk_1
		STA	byte_D
; Skip 3 bytes (line number data)
		INC	byte_23
		INC	byte_23
		INC	byte_23
		LDY	byte_0
		BNE	advance		; JMP, in effect, I think...

token:					
		STA	byte_26		; ?byte_26 = token being searched for
		LDA	#<token_table
		STA	byte_C
		LDA	#>token_table
		STA	byte_D

loc_9CD0:				
		LDY	#0

find_token_value_loop:			
		LDA	(byte_C),Y	; get next byte	from token table
		BMI	found_token_value ; branch taken if it's a token value
		INY
		BNE	find_token_value_loop

found_token_value:			
		CMP	byte_26		; is it	the desired token?
		BEQ	advance		; branch taken if token	found
		CMP	#$D3		; HIMEM, statement version?
		BEQ	not_token	; ??? -	branch taken if	so
		INY			; skip token ID
		INY			; skip other byte
; advance (byte_C) to next entry in token table
		TYA
		CLC
		ADC	byte_C
		STA	byte_C
		BCC	loc_9CED
		INC	byte_D

loc_9CED:				
		BNE	loc_9CD0

advance:				
					
		TYA			; get length of	token
		CLC
		ADC	byte_400	; add to current length
		BCS	overflow	; branch taken if line too long...
		CMP	#$FC
		BCS	overflow	; branch taken if line too long...
		STA	byte_400	; store	new current length
		DEY			; Y = index of last char of token
		JSR	copy_detokenized_text ;	copy text whilst detokenizing.
					;
					; Entry:
					; (byte_C) points to source text
					; (byte_E) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		INC	byte_23		; next byte in line
		JMP	loc_9C59

overflow:				
					
		INC	byte_6A8
		RTS

copy_detokenized_text:			
					
		LDA	(byte_C),Y	; copy text whilst detokenizing.
					;
					; Entry:
					; (byte_C) points to source text
					; (byte_E) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		STA	(byte_E),Y
		DEY
		BPL	copy_detokenized_text ;	copy text whilst detokenizing.
					;
					; Entry:
					; (byte_C) points to source text
					; (byte_E) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		RTS
; End of function detokenize_line



; decode line number from program.
;
; Entry:
; (unk_27),Y points to 8D token
;
; Exit:
; unk_21.w is line number.

decode_line_number:			
					
		INY
		LDA	(byte_27),Y	; get first line number	byte
		PHA			; store
		LDX	#1

decode_line_number_loop:					
		PLA			; get last byte
		ROL
		ROL			; <<2
		PHA			; save
		AND	#%11000000
		INY
		EOR	(byte_27),Y
		STA	byte_21,X
		DEX
		BPL	decode_line_number_loop
		PLA
		RTS
; End of function decode_line_number




enter_edit_mode:			
					
		LDA	#1
		STA	byte_6AB

loc_9D2D:
                lda #26
                jsr oswrch
                lda #12
                jsr oswrch
		JSR	find_program
		BCC	loc_9D3F
		JMP	language_entry.loc_814D

loc_9D3F:				
		JSR	set_palette
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		LDA	#13
		JSR	OSWRCH
		LDX	#9		; VDU variable 9 - text	window coordinates, bottom (X) + right (Y) (AUG	p275)
		LDA	#160		; read VDU variable value (AUG p179)
		JSR	OSBYTE
		STX	screen_height	; store	screen height
		TYA			; get screen width in A
		SEC
		SBC	#6		; subtract 6 to	account	for line number	display
		STA	code_area_width	; store	usable screen width
		LDX	#9		; set TAB key to produce CHR$9
		LDA	#219		; Read/write character value returned by pressing TAB key (AUG p222)
		JSR	osbyte_with_y0
		JMP	loc_8437
; End of function enter_edit_mode


loc_9D67:				
		JSR	enter_edit_mode
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_9DA8
		LDA	byte_50
		STA	byte_2B
		LDA	byte_51
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	($2B),Y
		BMI	loc_9DA8
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JSR	sub_9698
		BCS	loc_9DA8
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		JSR	sub_9706
		JSR	cls_and_reset_6c0_to_6ff
		CLC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JMP	loc_9DE4

loc_9DA8:				
					
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_9DC9
		JSR	clear_program
		JSR	cls_and_reset_6c0_to_6ff
		LDX	#<empty_program_string
		LDY	#>empty_program_string
		LDA	#5
		JSR	print_n_chars
		LDX	#$FF
		STX	byte_6C0
		STX	byte_6C1
		STX	byte_2C
		JMP	loc_9DE4

loc_9DC9:				
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	current_line_no_lsb
		STA	byte_2B
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number

loc_9DE4:				
		JSR	sub_9FD8
		JMP	edit_mode_loop



sub_9DEA:				
					
		PHP
		JSR	make_cursor_invisible
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

loc_9DF1:				
		LDY	#1
		LDA	($2B),Y
		BMI	loc_9E19
		JSR	detokenize_one_line
		JSR	sub_9E5F
		BCC	loc_9E19
		PLP
		PHP
		BCC	loc_9E09
		JSR	sub_9F00
		JMP	loc_9E0C

loc_9E09:				
		JSR	sub_9E82

loc_9E0C:				
		CLC
		LDA	byte_3B
		ADC	byte_2D
		STA	byte_3B
		JSR	advance_2b_to_next_line
		JMP	loc_9DF1

loc_9E19:				
		PLP
		PHP
		BCC	loc_9E5D
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
		LDX	#0
		LDY	#$4F ; 'O'
		LDA	#$20 ; ' '
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.

loc_9E2E:				
		LDA	byte_3B
		CMP	screen_height
		BEQ	loc_9E37
		BCS	loc_9E5D

loc_9E37:				
		ASL
		TAY
		LDA	$6C1,Y
		BEQ	loc_9E5D
		LDX	#0
		TXA
		STA	$6C0,Y
		STA	$6C1,Y
		LDY	byte_3B
		JSR	gotoxy
		CLC
		LDA	code_area_width
		ADC	#6
		LDX	#<unk_401
		LDY	#>unk_401
		JSR	print_n_chars
		INC	byte_3B
		BNE	loc_9E2E

loc_9E5D:				
		PLA
		RTS
; End of function sub_9DEA




sub_9E5F:				
					
		JSR	sub_A01E
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	screen_height
		SEC
		SBC	byte_3B
		CLC
		ADC	#1
		CMP	byte_2D
		BCC	locret_9E81
		LDA	byte_3B
		ASL
		TAY
		LDA	byte_2B
		STA	$6C0,Y
		LDA	byte_2C
		STA	$6C1,Y
		SEC

locret_9E81:				
		RTS
; End of function sub_9E5F




sub_9E82:				
					
		LDA	#1
		LDX	byte_400
		LDY	#0
		JSR	sub_A0B1
		JMP	redraw_line_number
; End of function sub_9E82



; finds	a line,	given a	line number
;
; Entry:
; byte_2B: line	number MSB
; byte_2C: line	number LSB
;
; Exit:
; (byte_2B) points to most suitable line

find_line_by_number:			
					
		LDA	byte_2B
		STA	byte_39
		LDA	byte_2C
		STA	byte_3A
		LDA	oshwm
		STA	unk_30
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9EA1:				
		LDY	#1
		LDA	(byte_2B),Y	; get line MSB
		BMI	find_line_by_number_done		; -ve =	done
		CMP	byte_39
		BCC	loc_9EB4	; MSB<?39 -> 9eb4
		BNE	find_line_by_number_done
		INY			; offset of line LSB
		LDA	(byte_2B),Y	; get line LSB
		CMP	byte_3A
		BCS	find_line_by_number_done
; MSB<?39 && LSB<=?3A

loc_9EB4:				
		LDA	byte_2B
		STA	unk_2F
		LDA	byte_2C
		STA	unk_30
		JSR	advance_2b_to_next_line
		JMP	loc_9EA1

find_line_by_number_done:					
					
		RTS
; End of function find_line_by_number



; get height of	current	line
;
; Entry:
; ?byte_400 = line length
;
; Exit:
; X = line height

get_line_height:			
					
		LDY	#0
		LDX	byte_400	; get line length
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		TXA			; get width
		BEQ	loc_9ECF	; taken	if it fits exactly
		INY			; add an extra line, because it	needs it

loc_9ECF:				
		TYA
		TAX			; X = line height
		BNE	locret_9ED4
		INX			; set height to	1 if line is empty

locret_9ED4:				
		RTS
; End of function get_line_height


fg_table:
                ;    0 1 2 3 4 5 6 7
                .byte 1,3,7,1,1,3,1,0

set_palette:				
					
		LDX	#0		; set colour 0
		LDY	background_colour ; get	BACK colour
                JSR	set_palette_entry ; X=logical colour, Y=physical colour
                
		LDA	#$87		; get MODE in Y
                JSR	OSBYTE		; get MODE in Y
                tya
                and #7          ;the M128 only ever returns 0-7, but I
                                ;don't know what other systems do.
                tay
                ldx fg_table,Y
		LDY	foreground_colour ; get	FORE colour

set_palette_entry:			
		LDA	#19		; X=logical colour, Y=physical colour
		JSR	OSWRCH
		TXA
		JSR	OSWRCH
		TYA
		JSR	OSWRCH
		LDA	#0
		JSR	OSWRCH
		JSR	OSWRCH
                JSR	OSWRCH
set_palette_done:
		RTS
; End of function set_palette




sub_9F00:				
		JSR	make_cursor_invisible
		LDA	#1
		LDX	unk_8
		LDY	unk_9
		JSR	sub_A0B1
		LDX	#0
		STX	byte_36

loc_9F10:				
		LDX	#0
		CLC
		LDA	byte_36
		BEQ	loc_9F26
		ADC	byte_3B
		TAY
		JSR	gotoxy
		LDX	#<six_spaces_string
		LDY	#>six_spaces_string
		LDA	#6
		JSR	print_n_chars

loc_9F26:				
		INC	byte_36
		LDA	byte_36
		CMP	byte_2D
		BNE	loc_9F10
		JMP	redraw_line_number
; End of function sub_9F00



; treats command ID as ASCII char and puts that	char into the current line as appropriate.

execute_key_command:			
		LDA	unk_11
		BNE	beep
		JSR	sub_AB1E
		LDX	byte_400	; X = line length
		LDA	is_insert_mode	; 0=overtype 1=insert
		BEQ	loc_9F5C	; branch taken if overtype mode
		LDA	cursor_offset	; get cursor offset (?)
		CMP	byte_400	; compare to line length
		BEQ	loc_9F48
		BCS	loc_9F58	; branch taken if cursor offset	> line length

loc_9F48:				
		LDY	byte_400	; get line length
		BEQ	loc_9F55
		DEY
		LDA	$401,Y
		CMP	#$20 ; ' '
		BEQ	sub_9F6F

loc_9F55:				
		INX
		BNE	loc_9F65

loc_9F58:				
					
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_9F65

loc_9F5C:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	sub_9F6F
		BCS	loc_9F58

loc_9F65:				
					
		CPX	#$FC
		BCC	sub_9F6F
; End of function execute_key_command




beep:					
					
		LDA	#7
		JSR	OSWRCH
		RTS
; End of function beep




sub_9F6F:				
					
		TXA
		PHA
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		PHA
		PHA
		LDA	is_insert_mode	; 0=overtype 1=insert
		BEQ	store_char	; branch taken if overtype
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	insert		; branch taken if at end of line
		BCS	store_char	; branch taken if past end of line

insert:					
		PLA
		TXA
		PHA
		LDX	#$FF
		STX	byte_C
		INX
		STX	byte_E
		INX
		TXA
		JSR	sub_9FB2

store_char:				
		LDA	current_command_id ; get char to write
		LDY	cursor_offset	; offset of cursor in detokenized buffer
		DEY			; make relative	to tex
		STA	$401,Y		; store
		LDA	#1
		STA	byte_6B3
		PLA
		TAX
		PLA
		TAY
		PLA
		STA	byte_400
		TYA
		LDY	#0
		INC	cursor_offset	; advance to next char
		JSR	sub_A0B1
		JMP	position_edit_mode_cursor
; End of function sub_9F6F




sub_9FB2:				
		PHA
		LDX	#2
		JSR	adjust_pointer
		LDX	#0
		JSR	adjust_pointer
; X=0
		PLA
		CLC
		ADC	byte_400	; add line length
		SEC
		SBC	cursor_offset	; subtract cursor offset
		TAY			; LSB of size
		JMP	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

adjust_pointer:				
		CLC
		LDA	byte_C,X	; get pointer LSB
		ADC	#1		; increment
		CLC
		ADC	cursor_offset	; +?byte_10
		STA	byte_C,X	; store
		LDA	#4
		STA	byte_D,X	; copying in page 4.
		RTS
; End of function sub_9FB2




sub_9FD8:				
		JSR	sub_A069
		LDX	#1
		STX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		STX	unk_11
		LDX	#6
		LDY	byte_3B
		JMP	gotoxy
; End of function sub_9FD8



; sets C if no program

is_program_empty:			
					
		CLC
		LDY	#1
		LDA	(oshwm),Y
		BPL	locret_9FF1
		SEC

locret_9FF1:				
		RTS
; End of function is_program_empty




sub_9FF2:				
		CLC
		LDA	TOP
		ADC	byte_27
		TAX
		LDA	TOP+1
		ADC	byte_28
		CMP	HIMEM+1
		BCC	locret_A00D
		BEQ	loc_A007

loc_A002:				
		LDA	#5
		JMP	loc_859D

loc_A007:				
		CPX	HIMEM
		BEQ	locret_A00D
		BCS	loc_A002

locret_A00D:				
		RTS
; End of function sub_9FF2




cls_and_reset_6c0_to_6ff:		
					
		LDA	#12     ;cls_and_reset_6c0_to_6ff
		JSR	OSWRCH
		LDA	#0
		LDY	#$3F

loc_A017:				
		STA	byte_6C0,Y
		DEY
		BPL	loc_A017
		RTS
; End of function cls_and_reset_6c0_to_6ff




sub_A01E:				
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height

loc_A021:				
		STX	byte_2D
		LDA	#0
		STA	unk_8
		STA	unk_9

loc_A029:				
		LDA	code_area_width
		CLC
		ADC	unk_8
		STA	unk_8
		BCC	loc_A035
		INC	unk_9

loc_A035:				
		DEX
		BNE	loc_A029
		RTS
; End of function sub_A01E



; saves	line number from program.
;
; Entry:
; (byte_2b) points to current line
;
; Exit:
; current_line_no_lsb, current_line_no_msb = the line number

save_line_number:			
					
		LDY	#1
		LDA	(byte_2B),Y
		STA	current_line_no_lsb
		INY
		LDA	(byte_2B),Y
		STA	current_line_no_msb
		RTS
; End of function save_line_number



; gets pointer to line visible on screen.
;
; Entry:
; X = screen line number * 2 + 1
;
; Exit:
; (byte_2B) points to BASIC line
; X decremented

get_line_ptr:				
					
		LDA	$6C0,X
		STA	byte_2C
		DEX
		LDA	$6C0,X
		STA	byte_2B
		RTS
; End of function get_line_ptr



; determines whether current line is empty.
;
; Entry:
; detokenized line at $400...
;
; Exit:
; C set	if line	empty.

is_line_empty:				
					
		JSR	is_program_empty ; sets	C if no	program
		BCC	is_not_empty
		LDY	byte_400
		BEQ	is_empty

loc_A05B:				
		LDA	$400,Y
		CMP	#$20 ; ' '
		BNE	is_not_empty
		DEY
		BNE	loc_A05B

is_empty:				
		SEC
		RTS

is_not_empty:				
					
		CLC
		RTS
; End of function is_line_empty




sub_A069:				
					
		LDX	#0		; first	line on	screen

loc_A06B:				
		TXA
		LSR			; A = true screen line index
		CMP	screen_height	; check	against	height of screen
		BEQ	loc_A074
		BCS	loc_A093

loc_A074:				
		JSR	get_line_ptr2	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2
					;
					; Exit:
					; (byte_2B) points to BASIC line
					;
		LDY	$6C0,X
		BEQ	loc_A093
		INY
		BEQ	loc_A09B
		LDY	#1
		LDA	(byte_2B),Y
		CMP	current_line_no_lsb
		BCC	loc_A090
		BNE	loc_A095
		INY
		LDA	(byte_2B),Y
		CMP	current_line_no_msb
		BCS	loc_A095

loc_A090:				
		INX
		BNE	loc_A06B

loc_A093:				
		LDX	#1

loc_A095:				
		JSR	get_line_ptr_retainingX
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number

loc_A09B:				
		TXA
		LSR
		STA	byte_3B
		JSR	detokenize_one_line
		LDX	#0
		STX	byte_6B3
		JSR	sub_A01E
		RTS
; End of function sub_A069



; gets pointer to line visible on screen.
;
; Entry:
; X = screen line number * 2
;
; Exit:
; (byte_2B) points to BASIC line
;

get_line_ptr2:				
		INX			; bump X because get_line_ptr is wierd
; End of function get_line_ptr2




get_line_ptr_retainingX:		
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		INX			; restore original X
		RTS
; End of function get_line_ptr_retainingX




sub_A0B1:				
		CPX	#0
		BNE	loc_A0B6
		RTS

loc_A0B6:				
		STA	byte_28
		DEC	byte_28
		STY	byte_27
		DEX
		STX	byte_26
		JSR	make_cursor_invisible
		LDA	#$FF
		STA	byte_24
		STA	byte_23
		LDA	#0
		SEC
		SBC	code_area_width
		STA	byte_25

loc_A0D0:				
		CLC
		LDA	byte_25
		ADC	code_area_width
		STA	byte_25
		CLC
		LDA	byte_23
		ADC	code_area_width
		STA	byte_23
		BCC	loc_A0E4
		INC	byte_24

loc_A0E4:				
		LDA	#1
		STA	byte_20
		LDA	#4
		STA	byte_21
; (byte_20) points at detokenized line
		LDA	byte_24
		BNE	loc_A0F8
		LDA	byte_28
		CMP	byte_23
		BEQ	loc_A0F8
		BCS	loc_A0D0

loc_A0F8:				
		LDA	byte_28
		CMP	byte_25
		BCS	loc_A100
		LDA	byte_25

loc_A100:				
		STA	byte_22
		CLC
		ADC	byte_20
		STA	byte_20
		BCC	loc_A10B
		INC	byte_21

loc_A10B:				
		LDA	byte_27
		BNE	loc_A115
		LDA	byte_26
		CMP	byte_25
		BCC	locret_A16C

loc_A115:				
		LDX	#0
		LDA	byte_27
		CMP	byte_24
		BEQ	loc_A121
		BCS	loc_A129
		BCC	loc_A127

loc_A121:				
		LDA	byte_26
		CMP	byte_23
		BCS	loc_A129

loc_A127:				
		LDX	#3

loc_A129:				
		SEC
		LDA	byte_23,X
		SBC	byte_22
		CLC
		ADC	#1
		PHA
		LDX	byte_22
		LDY	#0
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		CLC
		TXA			; get X	coordinate
		ADC	#6		; offset by line numbers width
		TAX			; back in X
		CLC
		TYA			; get Y	coordinate
		ADC	byte_3B		; add base Y
		TAY			; back in Y
		JSR	gotoxy		; positino cursor
		LDA	byte_3B		; get screen Y
		ASL
		TAX
		LDA	$6C0,X
		PHA
		LDA	$6C1,X
		PHA
		TYA
		ASL
		TAX
		PLA
		STA	$6C1,X
		PLA
		STA	$6C0,X
		PLA
		LDX	byte_20
		LDY	byte_21
		JSR	print_n_chars
		LDA	byte_24
		BNE	locret_A16C
		JMP	loc_A0D0

locret_A16C:				
		RTS
; End of function sub_A0B1




redraw_line_number:			
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		BEQ	locret_A1D8
		JSR	make_cursor_invisible
		JSR	goto_start_of_line ; Entry:
					; byte_3B is Y coordinate.
		LDA	#0
		STA	readline_ptr_msb
; Line command slot 0
		TAX
		JSR	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
; Line command slot 3
		LDX	#3
		JSR	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
; Line command slot 6
		LDX	#6
		JSR	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
		LDA	readline_ptr_msb
		BNE	print_post_line_command_padding	; branch taken if any line command chars printed
		LDX	current_line_no_msb
		LDY	current_line_no_lsb
		JSR	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string
		SEC
		LDA	#5
		SBC	byte_0
; Right-justify number
		JSR	print_n_spaces	; prints N spaces.
					;
					; Entry:
					; A = number of	spaces to print	(max 6)
		JSR	print_number	; print	number.
					;
					; Suitable for use with	the result of itoa.
					;
					; Entry:
					; unk_0	= digit	count
					; unk_1... = digits

print_space_or_marker:			
		LDX	#12
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		LDA	#$20 ; ' '
		BCC	redraw_line_number_print_char
		LDA	#$2E ; '.'

redraw_line_number_print_char:				
		JMP	OSWRCH
; End of function redraw_line_number



; Entry:
; byte_3B is Y coordinate.

goto_start_of_line:			
		LDX	#0
		LDY	byte_3B
		JMP	gotoxy
; End of function goto_start_of_line



; prints N spaces.
;
; Entry:
; A = number of	spaces to print	(max 6)

print_n_spaces:				
					
		LDX	#<six_spaces_string
		LDY	#>six_spaces_string
		JMP	print_n_chars
; End of function print_n_spaces



; prints line command chars for	the current line, if any.
;
; Entry:
; current_line_no_lsb,
; current_line_no_msb =	current	line
; X = line command slot	ID
;
; Exit:
; readline_ptr_msb bumped by number of chars printed.

print_line_command_chars:		
					
		LDA	$40,X		; fetch	control	byte
		CMP	#$20 ; ' '
		BEQ	locret_A1D8	; branch taken if no line command here
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCC	locret_A1D8	; branch taken if no command here
; If char stored is lower-case, print it in upper case, but twice.
		CMP	#$60 ; '`'
		BCC	loc_A1D3
		SEC
		SBC	#$20 ; ' '
		JSR	OSWRCH
		INC	readline_ptr_msb

loc_A1D3:				
		JSR	OSWRCH
		INC	readline_ptr_msb

locret_A1D8:				
					
		RTS
; End of function print_line_command_chars


print_post_line_command_padding:	
		SEC
		LDA	#5
		SBC	readline_ptr_msb
		JSR	print_n_spaces	; prints N spaces.
					;
					; Entry:
					; A = number of	spaces to print	(max 6)
		JMP	print_space_or_marker



clear_line_commands:			
					
		LDA	#$20 ; ' '
		STA	byte_40
		STA	byte_43
		STA	byte_46
		RTS
; End of function clear_line_commands




set_primary_line_command:		
		LDX	#0
		JSR	is_line_command_slot_free ; check availability of line command slot.
					;
					; Entry:
					; X = slot ID
					;
					; Exit:
					; C set	if slot	is free.
		BCS	use_slot
		LDX	#3
		JSR	is_line_command_slot_free ; check availability of line command slot.
					;
					; Entry:
					; X = slot ID
					;
					; Exit:
					; C set	if slot	is free.

use_slot:				
		LDA	current_command_id
		CLC
		ADC	#$40		; make letter from command ID -- 'C', 'D' or 'M'
		LDY	$40,X		; get old command
		CPY	#$20 ; ' '      ; no command?
		BEQ	set_line_command ; branch taken	if no command.
					; just set command if taken.
		CMP	$40,X		; is this the command that's there already?
		BNE	set_line_command ; branch taken	if not same command.
					; overwrite old	command	with new one if	taken.
		CLC
		ADC	#$20 ; ' '      ; +$20 to indicate doubling of command

set_line_command:			
					
		STA	$40,X		; store	command
		LDA	current_line_no_lsb
		STA	$41,X		; store	line no	LSB
		LDA	current_line_no_msb
		STA	$42,X		; store	line no	MSB

loc_A216:				
		JSR	redraw_line_number ; update line number	with new commands
		JMP	position_edit_mode_cursor
; End of function set_primary_line_command



; checks if the	given line command is set on the current line.
;
; Entry:
; current_line_no_lsb,
; current_line_no_msb =	current	line
; X = line command slot	ID
;
; Exit:
; C set	if command is on current line.

is_current_line:			
					
		PHA
		LDA	current_line_no_lsb
		CMP	$41,X
		BNE	loc_A22C
		LDA	current_line_no_msb
		CMP	$42,X
		BNE	loc_A22C
		SEC
		BCS	loc_A22D

loc_A22C:				
					
		CLC

loc_A22D:				
		PLA

locret_A22E:				
					
		RTS
; End of function is_current_line



; check	availability of	line command slot.
;
; Entry:
; X = slot ID
;
; Exit:
; C set	if slot	is free.

is_line_command_slot_free:		
					
		LDA	$40,X		; get line command flag
		CMP	#$20 ; ' '      ; is it free?
		BEQ	locret_A22E	; branch taken if slot free.
					; return with C	set if taken.
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCS	locret_A22E	; branch taken if this slot is on the current line.
					; return with C	set if taken. (can change commands on current line.)
; slot is not free.
		CPX	#0		; was it slot ID 0 being checked?
		CLC			; clear	carry to indicate it isn't free
		BEQ	locret_A22E	; if it	was slot ID 0, just return with	carry clear
		JSR	beep		; otherwise, beep
		JMP	edit_mode_loop
; End of function is_line_command_slot_free


loc_A245:				
		CLC
		LDA	current_command_id
		ADC	#$40 ; '@'
		STA	byte_46
		LDA	current_line_no_lsb
		STA	byte_47
		LDA	current_line_no_msb
		STA	byte_48
		JMP	loc_AC08

loc_A258:				
		LDX	#0
		STX	readline_ptr_msb
		JSR	sub_A280
		LDX	#3
		JSR	sub_A280
		LDX	#6
		JSR	sub_A280
		LDX	#$C
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCC	loc_A276
		JSR	sub_B358
		JMP	loc_A216

loc_A276:				
		LDA	readline_ptr_msb
		BNE	loc_A216
		JSR	clear_line_commands
		JMP	loc_AC08



sub_A280:				
		LDA	$40,X
		CMP	#$20 ; ' '
		BEQ	locret_A2A0
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCC	locret_A2A0
		CPX	#0
		BNE	loc_A29A
		LDX	#3

loc_A291:				
		LDA	$42,X
		STA	$3F,X
		DEX
		BNE	loc_A291
		LDX	#3

loc_A29A:				
		LDA	#$20 ; ' '
		STA	$40,X
		INC	readline_ptr_msb

locret_A2A0:				
		RTS
; End of function sub_A280




sub_A2A1:				
					
		LDA	byte_46
		CMP	#$54 ; 'T'
		BNE	loc_A2B1
		LDY	#1
		LDA	($17),Y
		TAX
		INY
		LDA	($17),Y
		TAY
		RTS

loc_A2B1:				
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	($2F),Y
		TAX
		INY
		LDA	($2F),Y
		TAY
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		RTS
; End of function sub_A2A1

token_table:	.text "AND"
		.byte  $80 ; €
		.byte	 0 ;
aAbs:		.text "ABS"
		.byte  $94 ; ”
		.byte	 0 ;
aAcs:		.text "ACS"
		.byte  $95 ; •
		.byte	 0 ;
aAdval:		.text "ADVAL"
		.byte  $96 ; –
		.byte	 0 ;
aAsc:		.text "ASC"
		.byte  $97 ; —
		.byte	 0 ;
aAsn:		.text "ASN"
		.byte  $98 ; ˜
		.byte	 0 ;
aAtn:		.text "ATN"
		.byte  $99 ; ™
		.byte	 0 ;
aAuto:		.text "AUTO"
		.byte  $C6 ; Æ
		.byte  $10 ;
aBget:		.text "BGET"
		.byte  $9A ; š
		.byte	 1 ;
aBput:		.text "BPUT"
		.byte  $D5 ; Õ
		.byte	 3 ;
aColour:	.text "COLOUR"
		.byte  $FB ; û
		.byte	 2 ;
aColor:		.text "COLOR"
		.byte  $FB ; û
		.byte	 2 ;
aCall:		.text "CALL"
		.byte  $D6 ; Ö
		.byte	 2 ;
aChain:		.text "CHAIN"
		.byte  $D7 ; ×
		.byte	 2 ;
aChr:		.text "CHR$"
		.byte  $BD ; ½
		.byte	 0 ;
aClear:		.text "CLEAR"
		.byte  $D8 ; Ø
		.byte	 1 ;
aClose:		.text "CLOSE"
		.byte  $D9 ; Ù
		.byte	 3 ;
aClg:		.text "CLG"
		.byte  $DA ; Ú
		.byte	 1 ;
aCls:		.text "CLS"
		.byte  $DB ; Û
		.byte	 1 ;
aCos:		.text "COS"
		.byte  $9B ; ›
		.byte	 0 ;
aCount:		.text "COUNT"
		.byte  $9C ; œ
		.byte	 1 ;
aData:		.text "DATA"
		.byte  $DC ; Ü
		.byte  $20 ;
aDeg:		.text "DEG"
		.byte  $9D ; 
		.byte	 0 ;
aDef:		.text "DEF"
		.byte  $DD ; Ý
		.byte	 0 ;
aDelete:	.text "DELETE"
		.byte  $C7 ; Ç
		.byte  $10 ;
aDiv:		.text "DIV"
		.byte  $81 ; 
		.byte	 0 ;
aDim:		.text "DIM"
		.byte  $DE ; Þ
		.byte	 2 ;
aDraw:		.text "DRAW"
		.byte  $DF ; ß
		.byte	 2 ;
aEndproc:	.text "ENDPROC"
		.byte  $E1 ; á
		.byte	 1 ;
aEnd_0:		.text "END"
		.byte  $E0 ; à
		.byte	 1 ;
aEnvelope:	.text "ENVELOPE"
		.byte  $E2 ; â
		.byte	 2 ;
aElse:		.text "ELSE"
		.byte  $8B ; ‹
		.byte  $14 ;
aEval:		.text "EVAL"
		.byte  $A0 ;  
		.byte	 0 ;
aErl:		.text "ERL"
		.byte  $9E ; ž
		.byte	 1 ;
aError:		.text "ERROR"
		.byte  $85 ; …
		.byte	 4 ;
aEof:		.text "EOF"
		.byte  $C5 ; Å
		.byte	 1 ;
aEor:		.text "EOR"
		.byte  $82 ; ‚
		.byte	 0 ;
aErr:		.text "ERR"
		.byte  $9F ; Ÿ
		.byte	 1 ;
aExp:		.text "EXP"
		.byte  $A1 ; ¡
		.byte	 0 ;
aExt:		.text "EXT"
		.byte  $A2 ; ¢
		.byte	 1 ;
aFor:		.text "FOR"
		.byte  $E3 ; ã
		.byte	 2 ;
aFalse:		.text "FALSE"
		.byte  $A3 ; £
		.byte	 1 ;
aFn:		.text "FN"
		.byte  $A4 ; ¤
		.byte	 8 ;
aGoto_0:	.text "GOTO"
		.byte  $E5 ; å
		.byte  $12 ;
aGet_0:		.text "GET$"
		.byte  $BE ; ¾
		.byte	 0 ;
aGet:		.text "GET"
		.byte  $A5 ; ¥
		.byte	 0 ;
aGosub:		.text "GOSUB"
		.byte  $E4 ; ä
		.byte  $12 ;
aGcol:		.text "GCOL"
		.byte  $E6 ; æ
		.byte	 2 ;
aHimem_0:	.text "HIMEM"
		.byte  $93 ; “
		.byte  $43 ; C
aInput:		.text "INPUT"
		.byte  $E8 ; è
		.byte	 2 ;
aIf:		.text "IF"
		.byte  $E7 ; ç
		.byte	 2 ;
aInkey_0:	.text "INKEY$"
		.byte  $BF ; ¿
		.byte	 0 ;
aInkey:		.text "INKEY"
		.byte  $A6 ; ¦
		.byte	 0 ;
aInt:		.text "INT"
		.byte  $A8 ; ¨
		.byte	 0 ;
aInstr:		.text "INSTR("
		.byte  $A7 ; §
		.byte	 0 ;
aList:		.text "LIST"
		.byte  $C9 ; É
		.byte  $10 ;
aLine:		.text "LINE"
		.byte  $86 ; †
		.byte	 0 ;
aLoad_0:	.text "LOAD"
		.byte  $C8 ; È
		.byte	 2 ;
aLomem_0:	.text "LOMEM"
		.byte  $92 ; ’
		.byte  $43 ; C
aLocal:		.text "LOCAL"
		.byte  $EA ; ê
		.byte	 2 ;
aLeft:		.text "LEFT$("
		.byte  $C0 ; À
		.byte	 0 ;
aLen:		.text "LEN"
		.byte  $A9 ; ©
		.byte	 0 ;
aLet:		.text "LET"
		.byte  $E9 ; é
		.byte	 4 ;
aLog:		.text "LOG"
		.byte  $AB ; «
		.byte	 0 ;
aLn:		.text "LN"
		.byte  $AA ; ª
		.byte	 0 ;
aMid:		.text "MID$("
		.byte  $C1 ; Á
		.byte	 0 ;
aMode_0:	.text "MODE"
		.byte  $EB ; ë
		.byte	 2 ;
aMod:		.text "MOD"
		.byte  $83 ; ƒ
		.byte	 0 ;
aMove:		.text "MOVE"
		.byte  $EC ; ì
		.byte	 2 ;
aNext:		.text "NEXT"
		.byte  $ED ; í
		.byte	 2 ;
aNew_0:		.text "NEW"
		.byte  $CA ; Ê
		.byte	 1 ;
aNot:		.text "NOT"
		.byte  $AC ; ¬
		.byte	 0 ;
aOld_0:		.text "OLD"
		.byte  $CB ; Ë
		.byte	 1 ;
aOn_0:		.text "ON"
		.byte  $EE ; î
		.byte	 2 ;
aOff:		.text "OFF"
		.byte  $87 ; ‡
		.byte	 0 ;
aOr:		.text "OR"
		.byte  $84 ; „
		.byte	 0 ;
aOpenin:	.text "OPENIN"
		.byte  $8E ; Ž
		.byte	 0 ;
aOpenout:	.text "OPENOUT"
		.byte  $AE ; ®
		.byte	 0 ;
aOpenup:	.text "OPENUP"
		.byte  $AD ; ­
		.byte	 0 ;
aOscli:		.text "OSCLI"
		.byte  $FF ;
		.byte	 2 ;
aPrint:		.text "PRINT"
		.byte  $F1 ; ñ
		.byte	 2 ;
aPage_0:	.text "PAGE"
		.byte  $90 ; 
		.byte  $43 ; C
aPtr_0:		.text "PTR"
		.byte  $8F ; 
		.byte  $43 ; C
aPi:		.text "PI"
		.byte  $AF ; ¯
		.byte	 1 ;
aPlot:		.text "PLOT"
		.byte  $F0 ; ð
		.byte	 2 ;
aPoint:		.text "POINT("
		.byte  $B0 ; °
		.byte	 0 ;
aProc:		.text "PROC"
		.byte  $F2 ; ò
		.byte	$A ;
aPos:		.text "POS"
		.byte  $B1 ; ±
		.byte	 1 ;
aReturn:	.text "RETURN"
		.byte  $F8 ; ø
		.byte	 1 ;
aRepeat:	.text "REPEAT"
		.byte  $F5 ; õ
		.byte	 0 ;
aReport:	.text "REPORT"
		.byte  $F6 ; ö
		.byte	 1 ;
aRead:		.text "READ"
		.byte  $F3 ; ó
		.byte	 2 ;
aRem:		.text "REM"
		.byte  $F4 ; ô
		.byte  $20 ;
aRun_0:		.text "RUN"
		.byte  $F9 ; ù
		.byte	 1 ;
aRad:		.text "RAD"
		.byte  $B2 ; ²
		.byte	 0 ;
aRestore:	.text "RESTORE"
		.byte  $F7 ; ÷
		.byte  $12 ;
aRight:		.text "RIGHT$("
		.byte  $C2 ; Â
		.byte	 0 ;
aRnd:		.text "RND"
		.byte  $B3 ; ³
		.byte	 1 ;
aRenumber_0:	.text "RENUMBER"
		.byte  $CC ; Ì
		.byte  $10 ;
aStep:		.text "STEP"
		.byte  $88 ; ˆ
		.byte	 0 ;
aSave_0:	.text "SAVE"
		.byte  $CD ; Í
		.byte	 2 ;
aSgn:		.text "SGN"
		.byte  $B4 ; ´
		.byte	 0 ;
aSin:		.text "SIN"
		.byte  $B5 ; µ
		.byte	 0 ;
aSqr:		.text "SQR"
		.byte  $B6 ; ¶
		.byte	 0 ;
aSpc:		.text "SPC"
		.byte  $89 ; ‰
		.byte	 0 ;
aStr:		.text "STR$"
		.byte  $C3 ; Ã
		.byte	 0 ;
aString:	.text "STRING$("
		.byte  $C4 ; Ä
		.byte	 0 ;
aSound:		.text "SOUND"
		.byte  $D4 ; Ô
		.byte	 2 ;
aStop:		.text "STOP"
		.byte  $FA ; ú
		.byte	 1 ;
aTan:		.text "TAN"
		.byte  $B7 ; ·
		.byte	 0 ;
aThen:		.text "THEN"
		.byte  $8C ; Œ
		.byte  $14 ;
aTo:		.text "TO"
		.byte  $B8 ; ¸
		.byte	 0 ;
aTab_0:		.text "TAB("
		.byte  $8A ; Š
		.byte	 0 ;
aTrace:		.text "TRACE"
		.byte  $FC ; ü
		.byte  $12 ;
aTime_0:	.text "TIME"
		.byte  $91 ; ‘
		.byte  $43 ; C
aTrue:		.text "TRUE"
		.byte  $B9 ; ¹
		.byte	 1 ;
aUntil:		.text "UNTIL"
		.byte  $FD ; ý
		.byte	 2 ;
aUsr:		.text "USR"
		.byte  $BA ; º
		.byte	 0 ;
aVdu:		.text "VDU"
		.byte  $EF ; ï
		.byte	 2 ;
aVal:		.text "VAL"
		.byte  $BB ; »
		.byte	 0 ;
aVpos:		.text "VPOS"
		.byte  $BC ; ¼
		.byte	 1 ;
aWidth:		.text "WIDTH"
		.byte  $FE ; þ
		.byte	 2 ;
aPage:		.text "PAGE"
		.byte  $D0 ; Ð
		.byte	 0 ;
aPtr:		.text "PTR"
		.byte  $CF ; Ï
		.byte	 0 ;
aTime:		.text "TIME"
		.byte  $D1 ; Ñ
		.byte	 0 ;
aLomem:		.text "LOMEM"
		.byte  $D2 ; Ò
		.byte	 0 ;
aHimem:		.text "HIMEM"
		.byte  $D3 ; Ó
		.byte	 0 ;



toggle_insert_overtype_command:		
		LDX	#0
		LDA	is_insert_mode	; 0=overtype 1=insert
		BNE	loc_A5D9
		LDX	#1

loc_A5D9:				
		STX	is_insert_mode	; 0=overtype 1=insert
		RTS
; End of function toggle_insert_overtype_command




scroll_command:				
		LDX	#1

loc_A5DE:				
		STX	scroll_status	; 1=scroll, 0=noscroll
		RTS
; End of function scroll_command


noscroll_command:			
		LDX	#0
		BEQ	loc_A5DE

background_edit_mode_command:		
		LDY	#0
		BEQ	loc_A5EB

foreground_edit_mode_command:		
		LDY	#1

loc_A5EB:				
		LDA	$A,Y
		CLC
		ADC	#1
		CMP	#8
		BCC	loc_A5F7
		LDA	#0

loc_A5F7:				
		STA	$A,Y
		JSR	set_palette
		RTS

run_or_exit_command: .proc
		LDA	#0
		STA	is_insert_mode	; 0=overtype 1=insert
		LDA	#$60 ; '`'
		STA	unk_31
		JSR	reset_cursor_shape
		LDA	#26		; reset	text and graphics windows
		JSR	OSWRCH
		LDA	#12		; CLS (run_or_exit_command)
		JSR	OSWRCH
		JSR	reset_keys_settings
		LDX	#0
		LDA	#228
		JSR	osbyte_with_y0
		LDA	unk_16
                BNE	loc_A64D
run_or_exit_without_shutdown:
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_A64D
		LDX	#4		; ending position is by	default	after "OLD|M" part
		LDA	current_command_id
		CMP	#CMD_RUN	; is the command RUN?
		BNE	type_commands	; if not, just typing "OLD|M" is fine
		LDX	#0		; if RUN, type "OLD|MRUN|M"

type_commands:				
		LDA	#8
                STA	byte_3A		; position in "OLD|MRUN|M" string
                
		STX	byte_39		; ending position in string

type_commands_loop:			
		LDX	byte_3A
		DEX
		LDA	nur_dlo_string,X ; get next character
		TAY			; put char into	Y for OSBYTE
		LDX	#0		; 0 = keyboard buffer
		LDA	#138		; insert into keyboard buffer
		JSR	OSBYTE
		DEC	byte_3A		; next char in string
		LDA	byte_3A
		CMP	byte_39		; reached the end?
		BNE	type_commands_loop

loc_A64D:				
		LDX	#0
		LDY	#255
		LDA	#187		; get ROM containing BASIC
		JSR	OSBYTE
		LDA	#142		; enter	language ROM
                JSR	OSBYTE

.pend

exit_and_OLD: .proc
                ldx #4          ;"OLD|M"
                jmp run_or_exit_command.type_commands
.pend

exit_and_OLD_and_RUN: .proc
                ldx #0          ;"OLD|MRUN|M"
                jmp run_or_exit_command.type_commands
.pend

top_edit_mode_command:			
					
		LDA	#0
		STA	byte_2B
		STA	byte_2C

loc_A661:				
		LDA	#0
		STA	byte_3B
		SEC
		JSR	sub_9DEA
		JSR	sub_8314
		JSR	sub_9FD8
		JMP	edit_mode_loop

top_command:				
		JSR	sub_8314
		JMP	loc_9DA8

end_command:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		BEQ	loc_A681

end_edit_mode_command:			
					
		LDA	#1

loc_A681:				
		PHA
		LDA	#$FF
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		PLA
		TAX
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		TXA
		PHA
		JSR	sub_AA47
		LDA	#0
		STA	byte_3B
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		PLP
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JSR	sub_9FD8
		JMP	edit_mode_loop

new_command:				
		JSR	clear_program
		JSR	reset_program_name

loc_A6BE:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#1
		BEQ	locret_A6C8
		JMP	loc_9DA8

locret_A6C8:				
		RTS



reset_program_name:			
					
		LDX	#$E
		LDA	#13 ; ' '

loc_A6CD:				
		STA	program_name,X
		DEX
		BPL	loc_A6CD
		RTS
; End of function reset_program_name




old_command .proc				
		JSR	is_program_empty ; sets	C if no	program
		BCC good_program
		LDY	#1
		LDA	#0
		STA	($17),Y
		JSR	find_program
		BCC good_program
		JMP	language_entry.loc_814D

good_program:				
					
                JSR	sub_8314
                jsr find_rem_name
                JMP	loc_A6BE
.pend
; End of function old_command


extend_statement_edit_mode_command .proc	
		LDX	unk_9
		DEX
		BNE	loc_A6F4
		JMP	beep

loc_A6F4:				
		JSR	loc_AB3C
		JMP	position_edit_mode_cursor
.pend
                
swap_case_edit_mode_command: .proc
		LDX	unk_11
		DEX
		BEQ	loc_A715
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		LDA	$400,X
		JSR	toggle_case
		STA	$400,X
		LDA	#1
		STA	byte_6B3
		TXA
		LDY	#0
		JSR	sub_A0B1

loc_A715:				
		JMP	cursor_right_edit_mode_command
.pend
                
renumber_edit_mode_command:		
					
		JSR	sub_8492
		JMP	loc_967A

undo_edit_mode_command:			
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_A726
		JMP	loc_9DA8

loc_A726:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		JSR	sub_AA17
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JSR	sub_9FD8
		JMP	position_edit_mode_cursor

copy_key_edit_mode_command:		
		LDX	#0
		LDA	unk_31
		BNE	loc_A745
		LDX	#$40 ; '@'
		BNE	loc_A74B

loc_A745:				
		CMP	#$60 ; '`'
		BEQ	loc_A74B
		LDX	#$60 ; '`'

loc_A74B:				
		STX	unk_31
		RTS

top_of_screen_edit_mode_command:	
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		JMP	loc_A661



cursor_left_edit_mode_command:		
		JSR	sub_A775
		BCC	loc_A768
		LDA	unk_9
		STA	unk_11
		LDA	unk_8
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_A7A2

loc_A768:				
		SEC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		SBC	#1
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BCS	loc_A7A2
		DEC	unk_11
                BEQ	loc_A7A2
; End of function cursor_left_edit_mode_command




sub_A775: .proc
					
		CLC
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		BNE	locret_A783
		LDA	unk_11
		BNE	locret_A783
		JSR	sub_BE98
		SEC

locret_A783:				
                RTS
.pend
; End of function sub_A775




cursor_right_edit_mode_command:		
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	unk_8
		BNE	loc_A79C
		LDA	unk_11
		CMP	unk_9
		BNE	loc_A79C
		JSR	sub_B7A1

loc_A793:				
					
		LDX	#0
		STX	unk_11
		INX
		STX	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_A7A2

loc_A79C:				
					
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_A7A2
		INC	unk_11

loc_A7A2:				
					
		JMP	position_edit_mode_cursor
; End of function cursor_right_edit_mode_command


shift_cursor_left_edit_mode_command:	
		JSR	cursor_left_edit_mode_command
		JMP	cursor_left_edit_mode_command

shift_cursor_right_edit_mode_command:	
		JSR	cursor_right_edit_mode_command
		JMP	cursor_right_edit_mode_command

ctrl_cursor_left_edit_mode_command:	
		JSR	sub_A775
		JMP	loc_A793



ctrl_cursor_right_edit_mode_command:	
					
		JSR	sub_B7A1
		JMP	loc_A793
; End of function ctrl_cursor_right_edit_mode_command




sub_A7BD:				
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	code_area_width
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BCC	locret_A7C9
		INC	unk_11

locret_A7C9:				
		RTS
; End of function sub_A7BD


cursor_down_edit_mode_command:		
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		PHA
		LDA	unk_11
		PHA
		JSR	sub_A7BD
		SEC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		SBC	unk_8
		STA	cursor_offset	; offset of cursor in detokenized buffer
		LDA	unk_11
		SBC	unk_9
		STA	unk_11
		JSR	sub_A804
		BCC	loc_A7EA
		PLA
		PLA
		JMP	loc_A834

loc_A7EA:				
		PLA
		TAX
		PLA
		TAY
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		PHA
		LDA	unk_11
		PHA
		STX	unk_11
		STY	cursor_offset	; offset of cursor in detokenized buffer
		JSR	sub_B7A1
		PLA
		STA	unk_11
		PLA
		STA	cursor_offset	; offset of cursor in detokenized buffer
		JMP	position_edit_mode_cursor



sub_A804:				
		SEC
		LDA	unk_11
		BMI	locret_A812
		BEQ	loc_A80D
		BNE	loc_A811

loc_A80D:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		BEQ	locret_A812

loc_A811:				
		CLC

locret_A812:				
		RTS
; End of function sub_A804




sub_A813:				
		SEC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		SBC	code_area_width
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BCS	locret_A81F
		DEC	unk_11

locret_A81F:				
		RTS
; End of function sub_A813


cursor_up_edit_mode_command:		
		JSR	sub_A813

loc_A823:
		JSR	sub_A804
		BCS	loc_A82B
		JMP	loc_A7A2

loc_A82B:				
		JSR	sub_A7BD
		JSR	sub_BE98
		JSR	sub_A813

loc_A834:				
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	unk_8
		STA	cursor_offset	; offset of cursor in detokenized buffer
		LDA	unk_11
		ADC	unk_9
		STA	unk_11
		JMP	position_edit_mode_cursor

ctrl_cursor_up_edit_mode_command:	
		JSR	sub_AA06
		LDA	byte_6C0
		STA	byte_2B
		LDA	byte_6C1
		STA	byte_2C
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069
		JMP	loc_A793

ctrl_cursor_down_edit_mode_command:	
		JSR	sub_AA06
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		LDA	$6BF,X
		STA	byte_2C
		LDA	$6BE,X
		STA	byte_2B
		JSR	sub_BA69
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	sub_9FD8

shift_cursor_up_edit_mode_command:	
		LDX	byte_6C0
		LDY	byte_6C1
		CPX	#0
		BNE	loc_A88E
		CPY	oshwm+1
		BNE	loc_A88E
		JMP	top_edit_mode_command

loc_A88E:				
		STX	byte_2B
		STY	byte_2C
		JMP	loc_AA41

shift_cursor_down_edit_mode_command:	
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		DEX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	loc_9DA8



position_edit_mode_cursor:		
					
		LDY	unk_11
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_A8AF
		DEY

loc_A8AF:				
		DEX
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		TXA
		CLC
		ADC	#6
		TAX
		TYA
		CLC
		ADC	byte_3B
		TAY
		JMP	gotoxy
; End of function position_edit_mode_cursor




sub_A8C0:				
					
		LDA	byte_6B3
		BNE	loc_A8C6
		RTS

loc_A8C6:				
		LDA	#0
		STA	byte_6A8
		PHA

loc_A8CC:				
		JSR	rstrip_and_cr_terminate_detokenized_line
		CLC
		TXA
		ADC	#4
		STA	unk_503
		LDA	#$D
		STA	unk_500
		LDA	current_line_no_lsb
		STA	unk_501
		LDA	current_line_no_msb
		STA	unk_502
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
		LDA	#4
		STA	byte_E
		LDA	#5
		STA	byte_F
		LDX	#0
		LDY	#$FC
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JMP	loc_A905

loc_A8FF:				
		LDA	#0
		STA	byte_6A8
		PHA

loc_A905:				
		LDA	#0
		STA	byte_2B
		LDA	#5
		STA	byte_2C
		JSR	detokenize_line	; detokenize line and store result.
					;
					; Entry:
					; (byte_2B) points to line
					;
					; Exit:
					; $400 = line length
					; $401... = line text
					; unk_6A8 incremented if line too long
		LDA	byte_6A8
		BEQ	loc_A928
		LDA	byte_6A7
		BNE	loc_A91F
		LDA	#$25 ; '%'      ; "Updates would make line too long"
		JMP	loc_859D

loc_A91F:				
		PLA
		BNE	loc_A929
		LDA	#1
		PHA
		JMP	loc_A8CC

loc_A928:				
		PLA

loc_A929:				
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	($2B),Y
		CMP	current_line_no_lsb
		BNE	loc_A943
		INY
		LDA	($2B),Y
		CMP	current_line_no_msb
		BEQ	loc_A947

loc_A943:				
		LDX	#-1
		STX	byte_2C

loc_A947:				
		LDX	byte_2C
		INX
		STX	byte_25
		LDA	unk_503
		CPX	#0
		BEQ	loc_A958
		SEC
		LDY	#3
		SBC	($2B),Y

loc_A958:				
		STA	byte_27
		LDA	#0
		SBC	#0
		STA	byte_28
		JSR	find_program
		JSR	sub_9FF2
		LDX	current_line_no_msb
		LDY	current_line_no_lsb
		INX
		BNE	loc_A96E
		INY

loc_A96E:				
		STX	byte_2C
		STY	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2C
		STA	byte_D
		LDA	byte_2B
		STA	byte_C
		CLC
		ADC	byte_27
		STA	byte_E
		LDA	byte_2C
		ADC	byte_28
		STA	byte_F
		SEC
		LDA	TOP
		SBC	byte_C
		TAY
		LDA	TOP+1
		SBC	byte_D
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	#0
		STA	byte_C
		LDA	#5
		STA	byte_D
		LDY	#4
		LDX	byte_25
		BNE	loc_A9A6
		LDY	#0

loc_A9A6:				
		LDA	$2B,Y
		STA	byte_E
		LDA	$2C,Y
		STA	byte_F
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#1
		BEQ	loc_A9F3
		LDX	byte_2D
		LDA	byte_3B
		ASL
		TAY

loc_A9BD:				
		LDA	byte_E
		STA	byte_2B
		STA	$6C0,Y
		INY
		LDA	byte_F
		STA	byte_2C
		STA	$6C0,Y
		INY
		DEX
		BNE	loc_A9BD

loc_A9D0:				
		TYA
		LSR
		CMP	screen_height
		BEQ	loc_A9D9
		BCS	loc_A9F3

loc_A9D9:				
		LDA	$6C1,Y
		BEQ	loc_A9F3
		CLC
		LDA	$6C0,Y
		ADC	byte_27
		STA	$6C0,Y
		INY
		LDA	$6C0,Y
		ADC	byte_28
		STA	$6C0,Y
		INY
		BNE	loc_A9D0

loc_A9F3:				
					
		LDX	#0
		LDY	unk_503
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	byte_6A8
		BEQ	locret_AA05
		LDA	#$24 ; '$'
		JMP	loc_859D

locret_AA05:				
		RTS
; End of function sub_A8C0




sub_AA06:				
		LDA	byte_6B3
		PHA
		JSR	sub_A8C0
		PLA
		BNE	sub_AA17
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		CPX	byte_2D
		BEQ	locret_AA40
; End of function sub_AA06




sub_AA17:				
		LDA	unk_8
		PHA
		LDA	unk_9
		PHA
		JSR	sub_A069
		PLA
		TAX
		PLA
		CPX	unk_9
		BNE	loc_AA2E
		CMP	unk_8
		BNE	loc_AA2E
		JMP	sub_9F00

loc_AA2E:				
		LDA	byte_3B
		PHA
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B

locret_AA40:				
		RTS
; End of function sub_AA17


loc_AA41:				
		JSR	sub_AA47
		JMP	loc_9DA8



sub_AA47:				
		LDA	#$FF
		STA	unk_2E

loc_AA4B:				
		JSR	detokenize_one_line
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA			; A = line height
		CLC
		ADC	unk_2E		; Add to current coordinate
		CMP	screen_height	; Reached height of screen?
		BEQ	loc_AA5C	; taken	if reached screen height exactly
		BCS	loc_AA71	; taken	if gone	past screen height

loc_AA5C:				
		STA	unk_2E		; store	coordinate
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		BNE	loc_AA4B

loc_AA71:				
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JMP	save_line_number ; saves line number from program.
; End of function sub_AA47		;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number


; swap byte_2B with unk_2F, swap byte_2C with unk_30

sub_AA77:				
					
		LDX	byte_2B
		LDY	unk_2F
		STX	unk_2F
		STY	byte_2B
		LDX	byte_2C
		LDY	unk_30
		STX	unk_30
		STY	byte_2C
		RTS
; End of function sub_AA77


delete_key_command:			
		LDA	unk_11
		BNE	loc_AA97
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		BEQ	locret_AACC
		DEX
		CPX	byte_400
		BCC	loc_AA9A

loc_AA97:				
		JMP	cursor_left_edit_mode_command

loc_AA9A:				
		LDX	#-1
		STX	byte_C
		DEX
		STX	byte_E
		LDA	#1
		JSR	sub_9FB2

loc_AAA6:				
		LDA	byte_400
		PHA
		DEC	byte_400
		LDY	byte_400
		LDA	#$20 ; ' '
		STA	$401,Y
		DEC	cursor_offset	; offset of cursor in detokenized buffer

loc_AAB7:				
		LDA	#1
		STA	byte_6B3
		PLA
		TAX
		LDY	#0
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		JSR	sub_A0B1
		JMP	position_edit_mode_cursor

loc_AAC8:				
					
		LDA	unk_11
		BEQ	loc_AACD

locret_AACC:				
		RTS

loc_AACD:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_AAD8
		BCS	locret_AACC
		BCC	loc_AADC

loc_AAD8:				
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_AAA6

loc_AADC:				
		LDX	#0
		STX	byte_C
		TXA
		DEX
		STX	byte_E
		JSR	sub_9FB2
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_AAA6

delete_to_end_of_line_edit_mode_command: 
		LDA	unk_11
		BNE	locret_AACC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_AAC8
		BCS	locret_AACC
		CLC
		LDA	#1
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_C
		DEC	byte_C
		LDA	#4
		STA	byte_D
		SEC
		LDA	byte_400
		PHA
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		TAY
		INY
		LDX	#0
		LDA	#$20 ; ' '
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		STX	byte_400
		JMP	loc_AAB7



sub_AB1E:				
		LDA	unk_9
		BNE	locret_AB2D
		LDA	unk_8
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BEQ	loc_AB3C
		CMP	byte_400
		BEQ	loc_AB2E

locret_AB2D:				
		RTS

loc_AB2E:				
		LDA	is_insert_mode	; 0=overtype 1=insert
		BEQ	locret_AB2D
		LDX	byte_400
		LDA	$400,X
		CMP	#$20 ; ' '
		BEQ	locret_AB2D

loc_AB3C:				
		LDA	#4
		STA	byte_D
		LDA	#7
		STA	byte_F
		JSR	sub_ABDB
		LDA	unk_8
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	screen_height
		ASL
		TAX
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_AB6A
		LDA	$6C1,X
		CMP	byte_2C
		BNE	loc_AB6A
		LDA	#1
		STA	unk_37
		JSR	sub_B8BD

loc_AB6A:				
		CLC
		LDA	byte_3B
		PHA
		ADC	byte_2D
		PHA
		TAY
		LDX	#0
		JSR	gotoxy
		LDA	#6
		LDX	#<six_spaces_string
		LDY	#>six_spaces_string
		JSR	print_n_chars
		CLC
		LDA	unk_8
		ADC	code_area_width
		TAX
		LDA	#0
		ADC	#0
		TAY
		CLC
		LDA	unk_8
		ADC	#1
		JSR	sub_A0B1
		PLA
		CMP	screen_height
		BEQ	loc_ABB0
		STA	byte_3B
		INC	byte_3B
		LDY	current_line_no_lsb
		LDX	current_line_no_msb
		INX
		BNE	loc_ABA8
		INY
		BMI	loc_ABB0

loc_ABA8:				
		STX	byte_2C
		STY	byte_2B
		SEC
		JSR	sub_9DEA

loc_ABB0:				
		PLA
		STA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		CLC
		PLA
		ADC	code_area_width
		STA	unk_8
		TAX
		LDA	#0
		ADC	#0
		STA	unk_9
		TAY
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		STY	byte_2D
		LDA	#7
		STA	byte_D
		LDA	#4
		STA	byte_F
; End of function sub_AB1E




sub_ABDB:				
		LDY	#0
		STY	byte_C
		STY	byte_E
		LDX	#1
		JMP	memmove		; move (maybe overlapping) memory regions.
; End of function sub_ABDB		;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size



rstrip_and_cr_terminate_detokenized_line: 
		LDX	byte_400	; check	line length
		BEQ	at_end		; taken	if line	empty

find_last_non_space_loop:		
		LDA	$400,X
		CMP	#$20 ; ' '
		BNE	at_end
		DEX
		BNE	find_last_non_space_loop

at_end:					
					
		LDA	#$D		; CR
		STA	$401,X		; store	at end of text
		JSR	sub_B0AC
		LDX	#$FF

find_cr:				
		INX
		LDA	$401,X
		CMP	#$D
		BNE	find_cr
		RTS
; End of function rstrip_and_cr_terminate_detokenized_line


loc_AC08:				
		JSR	make_cursor_invisible
		LDA	byte_3B
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDX	#-1
		STX	byte_3B
		INX
		STX	byte_2B
		STX	byte_2C

loc_AC1D:				
		INC	byte_3B
		LDA	byte_3B
		CMP	screen_height
		BEQ	loc_AC28
		BCS	loc_AC5D

loc_AC28:				
		ASL
		TAX
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_AC38
		LDA	$6C1,X
		CMP	byte_2C
		BEQ	loc_AC1D

loc_AC38:				
		LDA	$6C0,X
		STA	byte_2B
		LDY	$6C1,X
		STY	byte_2C
		BEQ	loc_AC5D
		INY
		BNE	loc_AC54
		PLA
		TAX
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		PHA
		TXA
		PHA
		JMP	loc_AC57

loc_AC54:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number

loc_AC57:				
		JSR	redraw_line_number
		JMP	loc_AC1D

loc_AC5D:				
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		PLA
		STA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JMP	position_edit_mode_cursor



execute_edit_mode_command:		
		LDA	#$20 ; ' '
		CMP	byte_40		; slot ID 0 empty?
		BNE	loc_AC7E	; taken	if slot	not empty
		CMP	byte_46		; slot id 6 empty?
		BEQ	locret_AC7D	; taken	if slot	empty
		LDA	#6		; "Missing line	command"
		BNE	execute_edit_mode_command_error

locret_AC7D:				
		RTS

loc_AC7E:				
		STA	byte_6B3	; ?byte_6B3=$20
		JSR	sub_A8C0
		LDA	byte_40
		CMP	#$60 ; '`'
		BCS	loc_ACA7
		LDA	byte_43
		CMP	#$20 ; ' '
		BEQ	loc_AC94
		LDA	#$1A
		BNE	execute_edit_mode_command_error

loc_AC94:				
		LDA	byte_41
		STA	byte_44
		LDA	byte_42
		STA	byte_45
		LDA	#$20 ; ' '

loc_AC9E:				
		CLC
		ADC	byte_40
		STA	current_command_id
		JMP	execute_command	; unk_6BD = command to run

loc_ACA7:				
		CMP	byte_43
		BEQ	loc_ACD7
		LDY	byte_43
		CPY	#$20 ; ' '
		BNE	loc_ACC7
		CMP	#$64 ; 'd'
		BEQ	loc_ACB9
		LDA	#$1F		; "Incomplete line command"
		BNE	execute_edit_mode_command_error

loc_ACB9:				
		LDA	byte_46
		CMP	#$54 ; 'T'
		BEQ	loc_ACCC
		CMP	#$45 ; 'E'
		BEQ	loc_ACCC
		LDA	#$1C		; "Invalid delete command"
		BNE	execute_edit_mode_command_error

loc_ACC7:				
		LDA	#$1B		; "Incompatible	line commands"

execute_edit_mode_command_error:					
					
		JMP	loc_859D

loc_ACCC:				
					
		JSR	sub_A2A1
		STX	byte_44
		STY	byte_45
		LDA	#$20 ; ' '
		STA	byte_46

loc_ACD7:				
		JSR	sub_AD1A
		LDA	byte_46
		CMP	#$20 ; ' '
		BEQ	loc_AD09
		CMP	#$54 ; 'T'
		BEQ	loc_AD09
		CMP	#$45 ; 'E'
		BEQ	loc_AD09
		LDY	byte_48
		LDX	byte_47
		CMP	#$42 ; 'B'
		BEQ	loc_ACF4
		INY
		BNE	loc_ACF4
		INX

loc_ACF4:				
					
		TXA
		PHA
		LDX	#0
		JSR	sub_AD0E
		PLA
		BCC	loc_AD09
		LDX	#3
		JSR	sub_AD0E
		BCS	loc_AD09
		LDA	#$1D
		BNE	execute_edit_mode_command_error

loc_AD09:				
					
		LDA	#0
		JMP	loc_AC9E
; End of function execute_edit_mode_command




sub_AD0E:				
					
		CMP	$41,X
		BEQ	loc_AD13
		RTS

loc_AD13:				
		TYA
		CMP	$42,X
		BNE	locret_AD19
		CLC

locret_AD19:				
		RTS
; End of function sub_AD0E




sub_AD1A:				
					
		LDX	byte_41
		CPX	byte_44
		BCC	locret_AD38
		BEQ	loc_AD24
		BCS	loc_AD2A

loc_AD24:				
		LDY	byte_42
		CPY	byte_45
		BCC	locret_AD38

loc_AD2A:				
		LDY	byte_44
		STX	byte_44
		STY	byte_41
		LDX	byte_42
		LDY	byte_45
		STX	byte_45
		STY	byte_42

locret_AD38:				
		RTS
; End of function sub_AD1A


loc_AD39:				
		LDA	byte_46
		CMP	#$20 ; ' '
		BNE	loc_AD44
		LDA	#$1E
		JMP	loc_859D

loc_AD44:				
		LDA	byte_46
		PHA
		LDA	byte_47
		PHA
		LDA	byte_48
		PHA
		JSR	sub_AE78
		LDA	byte_6C0
		STA	byte_39
		LDA	byte_6C1
		STA	byte_3A
		LDA	current_command_id
		CMP	#$6D ; 'm'
		BNE	loc_AD74
		LDY	#1
		LDA	($39),Y
		CMP	byte_41
		BEQ	loc_AD6D
		BCS	loc_AD87
		BCC	loc_AD74

loc_AD6D:				
		INY
		LDA	($39),Y
		CMP	byte_42
		BCS	loc_AD87

loc_AD74:				
		LDY	#1
		LDA	($39),Y
		CMP	byte_47
		BNE	loc_AD87
		INY
		LDA	($39),Y
		CMP	byte_48
		BNE	loc_AD87
		LDA	byte_46
		CMP	#$42 ; 'B'

loc_AD87:				
		PHP
		JSR	find_program
		LDX	#3
		JSR	sub_AE93
		LDY	#3
		LDA	($2B),Y
		LDX	#2
		JSR	sub_AE9E
		LDX	#0
		JSR	sub_AE93
		LDA	#0
		TAX
		JSR	sub_AE9E
		SEC
		LDA	unk_37
		SBC	byte_35
		STA	byte_27
		LDA	byte_38
		SBC	byte_36
		STA	byte_28
		PLA
		TAY
		PLA
		STA	byte_48
		PLA
		STA	byte_47
		PLA
		STA	byte_46
		TYA
		PHA
		JSR	sub_9FF2
		STA	unk_34
		STX	unk_33
		JSR	sub_AE78
		LDX	#6
		JSR	sub_AE93
		LDA	byte_46
		CMP	#$42 ; 'B'
		BNE	loc_ADDA
		JSR	sub_AEAA
		LDA	#0
		BEQ	loc_ADE3

loc_ADDA:				
		STA	unk_32
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDY	#3
		LDA	($2B),Y

loc_ADE3:				
		LDX	#4
		JSR	sub_AE9E
		LDA	byte_3A
		CMP	byte_36
		BEQ	loc_ADF2
		BCS	loc_AE0D
		BCC	loc_ADFA

loc_ADF2:				
		LDA	byte_39
		CMP	byte_35
		BEQ	loc_ADFA
		BCS	loc_AE0D

loc_ADFA:				
		LDX	#2

loc_ADFC:				
		CLC
		LDA	byte_27
		ADC	$35,X
		STA	$35,X
		LDA	byte_28
		ADC	$36,X
		STA	$36,X
		DEX
		DEX
		BPL	loc_ADFC

loc_AE0D:				
		CLC
		LDA	byte_39
		STA	byte_C
		ADC	byte_27
		STA	byte_E
		LDA	byte_3A
		STA	byte_D
		ADC	byte_28
		STA	byte_F
		SEC
		LDA	TOP
		SBC	byte_39
		TAY
		LDA	TOP+1
		SBC	byte_3A
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	byte_35
		STA	byte_C
		LDA	byte_36
		STA	byte_D
		LDA	byte_39
		STA	byte_E
		LDA	byte_3A
		STA	byte_F
		LDX	byte_28
		LDY	byte_27
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	current_command_id
		CMP	#$6D ; 'm'
		BNE	loc_AE68
		LDA	unk_37
		STA	byte_C
		LDA	byte_38
		STA	byte_D
		LDA	byte_35
		STA	byte_E
		LDA	byte_36
		STA	byte_F
		SEC
		LDA	unk_33
		SBC	unk_37
		TAY
		LDA	unk_34
		SBC	byte_38
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_AE68:				
		JSR	clear_line_commands
		JSR	sub_8492
		LDA	unk_32
		BNE	loc_AE75
		JSR	sub_8314

loc_AE75:				
		JMP	loc_AF48



sub_AE78:				
		LDX	#$42 ; 'B'
		LDA	byte_46
		CMP	#$54 ; 'T'
		BEQ	loc_AE86
		CMP	#$45 ; 'E'
		BNE	locret_AE92
		LDX	#$41 ; 'A'

loc_AE86:				
		TXA
		PHA
		JSR	sub_A2A1
		STX	byte_47
		STY	byte_48
		PLA
		STA	byte_46

locret_AE92:				
		RTS
; End of function sub_AE78




sub_AE93:				
		LDY	$41,X
		STY	byte_2B
		LDY	$42,X
		STY	byte_2C
		JMP	find_line_by_number ; finds a line, given a line number
; End of function sub_AE93		;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line



sub_AE9E:				
		CLC
		ADC	byte_2B
		STA	$35,X
		LDA	#0
		ADC	byte_2C
		STA	$36,X

locret_AEA9:				
		RTS
; End of function sub_AE9E




sub_AEAA:				
		LDA	unk_30
		STA	unk_32
		BEQ	locret_AEA9
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
; End of function sub_AEAA


loc_AEB9:				
		LDA	byte_46
		CMP	#$20 ; ' '
		BEQ	loc_AEC4
		LDA	#$1C
		JMP	loc_859D

loc_AEC4:				
		LDA	unk_4D
		CMP	byte_41
		BCC	loc_AEE3
		LDA	unk_4E
		CMP	byte_42
		BCC	loc_AEE3
		LDA	unk_4D
		CMP	byte_44
		BCC	loc_AEE0
		BNE	loc_AEE3
		LDA	unk_4E
		CMP	byte_45
		BEQ	loc_AEE0
		BCS	loc_AEE3

loc_AEE0:				
		JSR	sub_B358

loc_AEE3:				
		LDA	byte_6C0
		STA	byte_39
		LDA	byte_6C1
		STA	byte_3A
		LDY	#1
		LDA	($39),Y
		CMP	byte_41
		BEQ	loc_AEF8
		JMP	loc_AEFD

loc_AEF8:				
		INY
		LDA	($39),Y
		CMP	byte_42

loc_AEFD:				
		PHP
		JSR	find_program
		LDX	#3
		JSR	sub_AE93
		LDY	#3
		LDA	($2B),Y
		LDX	#2
		JSR	sub_AE9E
		LDX	#0
		JSR	sub_AE93
		JSR	sub_AEAA
		LDA	unk_37
		STA	byte_C
		LDA	byte_38
		STA	byte_D
		LDA	byte_2B
		STA	byte_E
		LDA	byte_2C
		STA	byte_F
		SEC
		LDA	TOP
		SBC	unk_37
		TAY
		LDA	TOP+1
		SBC	byte_38
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_AF3D
		JMP	loc_9DA8

loc_AF3D:				
		JSR	clear_line_commands
		LDA	unk_32
		BNE	loc_AF48
		PLA
		JMP	top_edit_mode_command

loc_AF48:				
		PLP
		BCC	loc_AF4E
		JMP	loc_9DA8

loc_AF4E:				
		JMP	loc_967A

return_key_command:			
		LDA	#0
		PHA

loc_AF54:				
		LDA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented

loc_AF5C:				
		JSR	advance_2b_to_next_line
		LDY	#2
		LDA	($2B),Y
		STA	byte_38
		DEY
		LDA	($2B),Y
		STA	unk_37
		BPL	loc_AF70
		LDA	#$A
		BNE	loc_AF72

loc_AF70:				
		LDA	#1

loc_AF72:				
		TAY
		CLC
		ADC	current_line_no_msb
		STA	byte_3A
		LDA	#0
		ADC	current_line_no_lsb
		STA	byte_39
		BPL	loc_AF8C
		DEY
		BNE	loc_AF70

loc_AF83:				
		JSR	sub_8492
		PLA
		LDA	#1
		PHA
		BNE	loc_AF54

loc_AF8C:				
		LDX	byte_39
		LDY	byte_3A
		CPX	unk_37
		BNE	loc_AF9A
		CPY	byte_38
		BNE	loc_AF9A
		BEQ	loc_AF83

loc_AF9A:				
		PLA
		STA	byte_36
		TXA
		PHA
		TYA
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	byte_36
		PHA
		STX	current_line_no_lsb
		STY	current_line_no_msb
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		LDA	#1
		STA	byte_400
		LDA	#$20 ; ' '
		STA	unk_401

loc_AFBB:				
		STX	byte_36
		LDA	byte_6B3
		PHA
		LDA	#1
		STA	byte_6B3
		LDA	#-1
		STA	byte_2C
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	sub_A8C0
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_6B3
		PLA
		BEQ	loc_AFE9
		CMP	#1
		BEQ	loc_B03B
		CMP	#3
		BNE	loc_B01B
		JMP	end_edit_mode_command

loc_AFE9:				
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA
		CLC
		ADC	byte_3B
		ADC	byte_36
		SEC
		SBC	#1
		CMP	screen_height
		BEQ	loc_B025
		BCC	loc_B025
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		PLA
		PLA
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line

loc_B00D:				
		LDA	scroll_status	; 1=scroll, 0=noscroll
		PHA
		LDA	#1
		STA	scroll_status	; 1=scroll, 0=noscroll
		JSR	ctrl_cursor_right_edit_mode_command
		PLA
		STA	scroll_status	; 1=scroll, 0=noscroll
		RTS

loc_B01B:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		STA	byte_3B
		CLC
		BCC	loc_B026

loc_B025:				
		SEC

loc_B026:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JSR	sub_9FD8
		JMP	edit_mode_loop

loc_B03B:				
		PLA
		PLA
		PLA
		TAX
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		PHA
		TXA
		PHA
		JSR	sub_9698
		BCS	loc_B05C

loc_B04C:				
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JMP	sub_9FD8

loc_B05C:				
		JSR	sub_AA47
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JMP	loc_B04C

it_cmd:					
		JSR	sub_B0A3
		LDY	#1
		LDA	($17),Y
		BNE	loc_B07F
		INY
		LDA	($17),Y
		CMP	#2
		BCS	loc_B07F
		JSR	sub_8492

loc_B07F:				
		LDA	#2
		PHA
		LDX	#0
		LDY	#1
		STX	current_line_no_lsb
		STY	current_line_no_msb
		JMP	loc_AF9A

ie_cmd:					
		JSR	sub_B0A3
		LDA	#3
		PHA
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	loc_AF5C



sub_B0A3:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_B0A9
		RTS

loc_B0A9:				
		JMP	loc_9DA8
; End of function sub_B0A3




sub_B0AC:				
		TSX
		STX	old_stack_ptr
		LDA	#1
		STA	byte_27
		LDA	#4
		STA	byte_28
		JMP	sub_B196
; End of function sub_B0AC




sub_B0BB:				
					
		PHA
		CLC
		TYA
		ADC	byte_27
		STA	byte_25
		LDY	#0
		TYA
		ADC	byte_28
		STA	byte_26
		PLA
		STA	($27),Y

loc_B0CC:				
		INY
		LDA	($25),Y
		STA	($27),Y
		CMP	#$D
		BNE	loc_B0CC
		RTS
; End of function sub_B0BB




sub_B0D6:				
		AND	#$F
		STA	byte_21
		STY	byte_22

loc_B0DC:				
		INY
		LDA	($27),Y
		CMP	#$3A ; ':'
		BCS	loc_B119
		CMP	#$30 ; '0'
		BCC	loc_B119
		AND	#$F
		PHA
		LDX	byte_22
		LDA	byte_21
		ASL
		ROL	byte_22
		BMI	loc_B114
		ASL
		ROL	byte_22
		BMI	loc_B114
		ADC	byte_21
		STA	byte_21
		TXA
		ADC	byte_22
		ASL	byte_21
		ROL
		BMI	loc_B114
		BCS	loc_B114
		STA	byte_22
		PLA
		ADC	byte_21
		STA	byte_21
		BCC	loc_B0DC
		INC	byte_22
		BPL	loc_B0DC
		PHA

loc_B114:				
		PLA
		LDY	#0
		SEC
		RTS

loc_B119:				
		JSR	ensure_4_bytes_spare
		DEY
		LDA	#$8D ;-$73 ;	''
		JSR	sub_B0BB
		LDA	byte_27
		ADC	#2
		STA	byte_25
		LDA	byte_28
		ADC	#0
		STA	byte_26

loc_B12E:				
		LDA	($27),Y
		STA	($25),Y
		DEY
		BNE	loc_B12E
		LDY	#3
		LDA	byte_22
		ORA	#$40 ; '@'
		STA	($27),Y
		DEY
		LDA	byte_21
		AND	#$3F ; '?'
		ORA	#$40 ; '@'
		STA	($27),Y
		DEY
		LDA	byte_21
		AND	#-$40 ;	'À'
		STA	byte_21
		LDA	byte_22
		AND	#-$40 ;	'À'
		LSR
		LSR
		ORA	byte_21
		LSR
		LSR
		EOR	#$54 ; 'T'
		STA	($27),Y
		JSR	increment_27
		JSR	increment_27
		JSR	increment_27
		LDY	#0

clc_then_rts:				
		CLC
		RTS
; End of function sub_B0D6



; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	œ)

issymchar:				
		CMP	#$7B ; '{'
		BCS	clc_then_rts	; branch taken if >'z'
		CMP	#$5F ; '_'
		BCS	locret_B17E	; branch taken if >='_' (0x5F='_', 0x60='œ', 0x61='A', ...)
		CMP	#$5B ; '['
		BCS	clc_then_rts	; branch taken if >'Z'
		CMP	#$41 ; 'A'
		BCS	locret_B17E	; branch taken if >='A'
; End of function issymchar



; sets C if A is a digit char

isdigit:				
		CMP	#$3A ; ':'      ; >'9'?
		BCS	clc_then_rts	; branch taken if >'9'
		CMP	#$30 ; '0'

locret_B17E:				
		RTS
; End of function isdigit



; sets C if A is a number char (0-9 or '.')

isnumchar:				
		CMP	#$2E ; '.'
		BNE	isdigit		; sets C if A is a digit char
		RTS
; End of function isnumchar

		.byte  $B1 ; ±
		.byte  $27 ; '



increment_27:				
		JSR	ensure_1_byte_spare
		INC	byte_27
		BNE	locret_B17E
		INC	byte_28
		RTS
; End of function increment_27




fetch_next_byte:			
		JSR	increment_27
		LDA	($27),Y
		RTS
; End of function fetch_next_byte




sub_B196:				
		LDY	#0
		STY	byte_23
		STY	byte_24

sub_B196_scan_line:				
		LDA	(byte_27),Y
		CMP	#$D
		BEQ	locret_B17E
		CMP	#$20 ; ' '
		BNE	check_for_hex

skip_byte:				
		JSR	increment_27
		BNE	sub_B196_scan_line

check_for_hex:				
		CMP	#$26 ; '&'
		BNE	check_for_string

check_hex_value:			
		JSR	fetch_next_byte
		JSR	isdigit		; sets C if A is a digit char
		BCS	check_hex_value
		CMP	#$41 ; 'A'
		BCC	sub_B196_scan_line
		CMP	#$47 ; 'G'
		BCC	check_hex_value
		BCS	sub_B196_scan_line

check_for_string:			
		CMP	#$22 ; '"'
		BNE	check_for_colon

loc_B1C5:				
		JSR	fetch_next_byte
		CMP	#$22 ; '"'
		BEQ	skip_byte
		CMP	#$D
		BNE	loc_B1C5
		RTS

check_for_colon:			
		CMP	#$3A ; ':'
		BNE	check_for_comma
		STY	byte_23
		STY	byte_24
		BEQ	skip_byte

check_for_comma:			
		CMP	#$2C ; ','
		BEQ	skip_byte
		CMP	#$2A ; '*'
		BNE	check_for_dot
		LDA	byte_23
		BNE	loc_B228
		RTS

check_for_dot:				
		CMP	#$2E ; '.'
		BEQ	got_dot
		JSR	isdigit		; sets C if A is a digit char
		BCC	loc_B224
		LDX	byte_24
		BEQ	got_dot
		JSR	sub_B0D6
		BCC	loc_B22E

got_dot:				
		LDA	($27),Y
		JSR	isnumchar	; sets C if A is a number char (0-9 or '.')
		BCC	loc_B207
		JSR	increment_27
		JMP	got_dot

loc_B207:				
		LDX	#-1
		STX	byte_23
		STY	byte_24
		JMP	sub_B196_scan_line

loc_B210:				
		JSR	issymchar	; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	œ)
		BCC	loc_B228

loc_B215:				
		LDY	#0

loc_B217:				
		LDA	(byte_27),Y
		JSR	issymchar	; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	œ)
		BCC	loc_B207
		JSR	increment_27
		JMP	loc_B217

loc_B224:				
		CMP	#$41 ; 'A'
		BCS	loc_B231

loc_B228:				
		LDX	#-1
		STX	byte_23
		STY	byte_24

loc_B22E:				
		JMP	skip_byte

loc_B231:				
		CMP	#'X'
		BCS	loc_B210	; skip out if >=X, since no tokens start with X, Y or Z
		LDX	#<token_table
		STX	byte_25
		LDX	#>token_table
		STX	byte_26

loc_B23D:				
		CMP	(byte_25),Y	; compare to char in table
		BCC	loc_B217	; taken	if char	in table is less
		BNE	find_token_byte	; taken	if char	is different

loc_B243:				
		INY			; next char
		LDA	(byte_25),Y	; get next char	from table
		BMI	loc_B27C	; taken	if token value found
		CMP	(byte_27),Y	; compare to byte in program
		BEQ	loc_B243	; taken	if chars equal
		LDA	(byte_27),Y	; get byte from	program
		CMP	#'.'            ; is it an abbreviation?
		BEQ	loc_B25D	; taken	if abbreviated

find_token_byte:			
		INY
		LDA	(byte_25),Y
		BPL	find_token_byte
		CMP	#$FE		; reached WIDTH	in the table?
		BNE	loc_B26A	; taken	if not WIDTH
		BCS	loc_B215	; taken	if WIDTH or OSCLI (???)

loc_B25D:				
		INY

loc_B25E:				
		LDA	($25),Y
		BMI	loc_B27C
		INC	byte_25
		BNE	loc_B25E
		INC	byte_26
		BNE	loc_B25E

loc_B26A:				
		SEC
		INY
		TYA
		ADC	byte_25
		STA	byte_25
		BCC	loc_B275
		INC	byte_26

loc_B275:				
		LDY	#0
		LDA	($27),Y
		JMP	loc_B23D

loc_B27C:				
		TAX
		INY
		LDA	($25),Y
		STA	byte_21
		DEY
		LSR
		BCC	loc_B28D
		LDA	($27),Y
		JSR	issymchar	; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	œ)
		BCS	loc_B215

loc_B28D:				
		TXA
		BIT	byte_21
		BVC	loc_B299
		LDX	byte_23
		BNE	loc_B299
		CLC
		ADC	#$40 ; '@'

loc_B299:				
		DEY
		JSR	sub_B0BB
		LDY	#0
		LDX	#-1
		LDA	byte_21
		LSR
		LSR
		BCC	loc_B2AB
		STX	byte_23
		STY	byte_24

loc_B2AB:				
		LSR
		BCC	loc_B2B2
		STY	byte_23
		STY	byte_24

loc_B2B2:				
		LSR
		BCC	loc_B2C6
		PHA
		INY

loc_B2B7:				
		LDA	($27),Y
		JSR	issymchar	; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	œ)
		BCC	loc_B2C4
		JSR	increment_27
		JMP	loc_B2B7

loc_B2C4:				
		DEY
		PLA

loc_B2C6:				
		LSR
		BCC	loc_B2CB
		STX	byte_24

loc_B2CB:				
		LSR
		BCS	locret_B2D1
		JMP	skip_byte

locret_B2D1:				
		RTS
; End of function sub_B196




ensure_1_byte_spare:			
		PHP
		PHA
		LDA	#1
		BNE	loc_B2DC	; JMP, in effect
; End of function ensure_1_byte_spare




ensure_4_bytes_spare:			
		PHP
		PHA
		LDA	#4

loc_B2DC:				
		CLC
		ADC	byte_27
		BCS	longjmp
		CMP	#$FC
		BEQ	loc_B2E7
		BCS	longjmp

loc_B2E7:				
		PLA
		PLP
		RTS

longjmp:				
					
		LDY	#0
		LDA	#$D
		STA	($27),Y
		STA	byte_6A8
		LDX	old_stack_ptr
		TXS
		RTS
; End of function ensure_4_bytes_spare




mode_command:				
                ldy byte_3E
                cpy #$ff
                beq loc_B2FF
                ldy byte_3F
		BEQ	loc_B304

loc_B2FF:				
                ; TODO: can get rid of this bit???
					
		LDA	#$D		; "Only	modes 0,1,3,4,6,7 are valid"
		JMP	loc_859D

loc_B304:				
		LDX	byte_3E
		JSR	get_HIMEM_for_mode_X
		JSR	find_program
		LDX	byte_15
		BEQ	locret_B329
		JSR	clear_5B1_to_600
		LDA	#$E		; "No room for this mode"
		JMP	loc_859D

locret_B329:
                lda #22
                jsr oswrch
                lda byte_3E
                jsr oswrch
		RTS
; End of function mode_command


; mode_edit_mode_command:			
;                 LDY	screen_mode
                

; loc_B32C:				
; 		DEY
; 		CPY	#2
; 		BEQ	loc_B32C
; 		CPY	#5
; 		BEQ	loc_B32C
; 		CPY	#-1
; 		BNE	loc_B33B
; 		LDY	#7

; loc_B33B:				
; 		STY	screen_mode
; 		JSR	validate_mode
; 		JSR	find_program
; 		LDA	byte_15
; 		BEQ	loc_B34A
; 		JMP	language_entry.loc_814D

; loc_B34A:				
; 		JSR	loc_9D2D
; 		JSR	is_program_empty ; sets	C if no	program
; 		BCS	loc_B355
; 		JMP	loc_967A

; loc_B355:				
; 		JMP	loc_9DA8



sub_B358:				
					
		LDA	#$FF
		STA	unk_4D
		RTS
; End of function sub_B358




mark_edit_mode_command:			
					
		LDA	current_line_no_lsb
		STA	unk_4D
		LDA	current_line_no_msb
		STA	unk_4E
		JMP	loc_AC08
; End of function mark_edit_mode_command




goto_edit_mode_command:			
					
		JSR	sub_B37B
		BEQ	loc_B370
		JMP	beep

loc_B370:				
					
		LDA	unk_4D
		STA	current_line_no_lsb
		LDA	unk_4E
		STA	current_line_no_msb
		JMP	loc_9DA8
; End of function goto_edit_mode_command




sub_B37B:				
					
		LDA	unk_4D
		CMP	#-1
		BNE	loc_B384
		LDA	#1
		RTS

loc_B384:				
		STA	byte_2B
		LDA	unk_4E
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	($2B),Y
		CMP	unk_4D
		BNE	locret_B39A
		INY
		LDA	($2B),Y
		CMP	unk_4E

locret_B39A:				
		RTS
; End of function sub_B37B


goto_command:				
		JSR	sub_B37B
		BNE	loc_B3A6
		JSR	enter_edit_mode
		JMP	loc_B370

loc_B3A6:				
		LDA	#$22 ; '"'
		JMP	loc_859D

number_command:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	#0
		STA	unk_1E
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_B3BB:				
		LDY	#1
		LDA	($2B),Y
		BPL	loc_B3DB
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		LDA	unk_1E
		AND	#1
		BEQ	loc_B3D2
		LDA	#$10

loc_B3CF:				
		JMP	loc_859D

loc_B3D2:				
		LDA	unk_1E
		BNE	locret_B3DA
		LDA	#$F
		BNE	loc_B3CF

locret_B3DA:				
		RTS

loc_B3DB:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#5
		STA	byte_F
		LDX	#0
		LDY	#3
		LDA	($2B),Y
		TAY
		INY
		BNE	loc_B3F9
		INX

loc_B3F9:				
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	#0
		STX	unk_11
		STX	unk_37
		STX	byte_36
		STX	byte_6B3
		INX
		STX	cursor_offset	; offset of cursor in detokenized buffer
		LDA	#4
		STA	unk_1F
		LDA	#5
		STA	byte_20

loc_B412:				
		SEC
		LDA	unk_503
		SBC	#4
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BCC	loc_B476
		LDY	#0
		LDA	($1F),Y
		CMP	#$20 ; ' '
		BEQ	loc_B461
		CMP	#$22 ; '"'
		BNE	loc_B430
		STA	byte_36
		LDA	unk_37
		EOR	#1
		STA	unk_37

loc_B430:				
		LDA	unk_37
		BNE	loc_B461
		LDA	($1F),Y
		CMP	#$f4 ;-$C ; 'ô' REM
		BEQ	loc_B476
		CMP	#$DC ; -$24 ;	'Ü' DATA
		BEQ	loc_B476
		CMP	#$2A ; '*'
		BNE	loc_B446
		LDX	byte_36
		BEQ	loc_B476

loc_B446:				
		CMP	#$3A ; ':'
		BNE	loc_B44E
		STY	byte_36
		BEQ	loc_B461

loc_B44E:				
		LDX	#1
		STX	byte_36
		CMP	#$8D ; -$73 ;	'' line number
		BNE	loc_B45A
		LDX	#4
		BNE	loc_B463

loc_B45A:				
		CMP	#$40 ; '@'
		BNE	loc_B461
		JMP	loc_B4B7

loc_B461:				
		LDX	#1

loc_B463:				
		CLC
		TXA
		ADC	unk_1F
		STA	unk_1F
		BCC	loc_B46D
		INC	byte_20

loc_B46D:				
		CLC
		TXA
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		JMP	loc_B412

loc_B476:				
		LDA	byte_6B3
		BEQ	loc_B47E
		JSR	sub_B4A7

loc_B47E:				
		JSR	advance_2b_to_next_line
		JMP	loc_B3BB



sub_B484:				
		CMP	#'0'
		BCC	loc_B49C
		CMP	#':'
		BCC	loc_B49E
		CMP	#'A'
		BCC	loc_B49C
		CMP	#'['
		BCC	loc_B49E
		CMP	#'_'
		BCC	loc_B49C
		CMP	#'{'
		BCC	loc_B49E

loc_B49C:				
		CLC
		RTS

loc_B49E:				
		SEC
		RTS
; End of function sub_B484




sub_B4A0:				
		LDY	#1
		LDA	($C),Y
		JMP	sub_B484
; End of function sub_B4A0




sub_B4A7:				
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	loc_A8FF
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		RTS
; End of function sub_B4A7


loc_B4B7:				
		LDA	unk_1F
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		JSR	sub_B4A0
		BCS	loc_B4C7

loc_B4C4:				
		JMP	loc_B461

loc_B4C7:				
		LDA	#0
		STA	unk_33
		LDA	oshwm+1
		STA	unk_34

loc_B4CF:				
		LDY	#1
		LDA	($33),Y
		BPL	loc_B4DD
		LDA	unk_1E
		ORA	#1
		STA	unk_1E
		BNE	loc_B4C4

loc_B4DD:				
		LDA	unk_33
		PHA
		LDA	unk_34
		PHA
		LDY	#4

loc_B4E5:				
		LDA	($33),Y
		CMP	#$20 ; ' '
		BNE	loc_B4EF
		INY
		JMP	loc_B4E5

loc_B4EF:				
		CMP	#$F4 ; -$C ; 'ô'
		BNE	loc_B52F
		INY

loc_B4F4:				
		LDA	($33),Y
		CMP	#$20 ; ' '
		BNE	loc_B4FE
		INY
		JMP	loc_B4F4

loc_B4FE:				
		CLC
		TYA
		ADC	unk_33
		STA	unk_33
		BCC	loc_B508
		INC	unk_34

loc_B508:				
		LDY	#0
		LDA	($33),Y
		CMP	#$40 ; '@'
		BEQ	loc_B512
		BNE	loc_B52F

loc_B512:				
		INY

loc_B513:				
		LDA	($33),Y
		CMP	($1F),Y
		BNE	loc_B521
		JSR	sub_B484
		BCC	loc_B532
		INY
		BNE	loc_B513

loc_B521:				
		JSR	sub_B484
		BCS	loc_B52F
		LDA	($1F),Y
		JSR	sub_B484
		BCS	loc_B52F
		BCC	loc_B532

loc_B52F:				
		CLC
		BCC	loc_B533

loc_B532:				
		SEC

loc_B533:				
		PLA
		STA	unk_34
		PLA
		STA	unk_33
		BCS	loc_B53E
		JMP	loc_B5A3

loc_B53E:				
		STY	byte_35
		LDA	unk_503
		SEC
		SBC	byte_35
		CLC
		ADC	#4
		BCS	loc_B59E
		STA	unk_503
		CLC
		LDA	unk_1F
		ADC	byte_35
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		STA	byte_F
		CLC
		LDA	unk_1F
		ADC	#4
		STA	byte_E
		SEC
		LDA	unk_503
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SEC
		SBC	#6
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#1
		LDA	($33),Y
		TAX
		INY
		LDA	($33),Y
		TAY
		JSR	sub_85D8
		PHA
		TYA
		LDY	#3
		STA	($1F),Y
		DEY
		TXA
		STA	($1F),Y
		DEY
		PLA
		STA	($1F),Y
		DEY
		LDA	#$8d ; -$73 ;	''
		STA	($1F),Y
		STA	byte_6B3
		LDA	unk_1E
		ORA	#2
		STA	unk_1E
		LDX	#4
		JMP	loc_B463

loc_B59E:				
		LDA	#$11
		JMP	loc_859D

loc_B5A3:				
		LDY	#3
		CLC
		LDA	($33),Y
		ADC	unk_33
		STA	unk_33
		BCC	loc_B5B0
		INC	unk_34

loc_B5B0:				
		JMP	loc_B4CF

label_command:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	#0
		STA	unk_1E
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_B5C3:				
		LDY	#1
		LDA	($2B),Y
		BMI	loc_B5EC
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	#0
		STA	byte_6B3
		JMP	loc_B65A

loc_B5D4:				
		LDA	byte_6B3
		BEQ	loc_B5DC
		JSR	sub_B4A7

loc_B5DC:				
		LDY	#3
		CLC
		LDA	($2B),Y
		ADC	byte_2B
		STA	byte_2B
		BCC	loc_B5E9
		INC	byte_2C

loc_B5E9:				
		JMP	loc_B5C3

loc_B5EC:				
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		LDA	unk_1E
		BNE	locret_B5FB
		LDA	#$13
		JMP	loc_859D

locret_B5FB:				
		RTS

label_edit_mode_command:		
		LDA	#$13
		PHA
		LDA	#<label_command ; $B3 ; -$4D ;	'³'
		STA	unk_6B1
		LDA	#>label_command ; $B5 ; -$4B ;	'µ'
		STA	unk_6B2
		BNE	loc_B618

number_edit_mode_command:		
		LDA	#$F
		PHA
		LDA	#<number_command ; $AB ; -$55 ;	'«'
		STA	unk_6B1
		LDA	#>number_command ; $B3 ; -$4D ;	'³'
		STA	unk_6B2

loc_B618:				
		JSR	is_program_empty ; sets	C if no	program
		PLA
		BCC	loc_B621
		JMP	loc_859D

loc_B621:				
		LDA	byte_6C0
		STA	byte_39
		LDA	byte_6C1
		STA	byte_3A
		LDY	#1
		LDA	($39),Y
		PHA
		INY
		LDA	($39),Y
		PHA
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	make_cursor_invisible
		JSR	unk_6B0
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JMP	loc_967A

loc_B65A:				
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#5
		STA	byte_F
		LDX	#0
		LDY	#3
		LDA	($2B),Y
		TAY
		INY
		BNE	loc_B675
		INX

loc_B675:				
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#0
		STY	unk_37
		STY	unk_11
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	#4
		STA	unk_1F
		LDA	#5
		STA	byte_20

loc_B689:				
		SEC
		LDA	unk_503
		SBC	#7
		BCC	loc_B695
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BCS	loc_B698

loc_B695:				
		JMP	loc_B5D4

loc_B698:				
		LDY	#0
		LDA	($1F),Y
		CMP	#$22 ; '"'
		BNE	loc_B6A6
		LDA	unk_37
		EOR	#1
		STA	unk_37

loc_B6A6:				
		LDX	unk_37
		BEQ	loc_B6AD

loc_B6AA:				
		JMP	loc_B78C

loc_B6AD:				
		LDA	($1F),Y
		CMP	#$8d ; -$73 ;	''
		BNE	loc_B6AA
		LDA	unk_1F
		STA	byte_27
		LDA	byte_20
		STA	byte_28
		LDY	#0
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		LDA	byte_21
		STA	byte_2B
		LDA	byte_22
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JMP	loc_B6DF

loc_B6D4:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B

loc_B6DA:				
		LDX	#4
		JMP	loc_B78E

loc_B6DF:				
		LDY	#1
		LDA	($2B),Y
		CMP	byte_21
		BNE	loc_B6D4
		INY
		LDA	($2B),Y
		CMP	byte_22
		BNE	loc_B6D4
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		LDY	#4

loc_B6F9:				
		LDA	($2F),Y
		CMP	#$20 ; ' '
		BNE	loc_B703
		INY
		JMP	loc_B6F9

loc_B703:				
		CMP	#$f4 ; -$C ; 'ô'
		BNE	loc_B6DA
		INY

loc_B708:				
		LDA	($2F),Y
		CMP	#$20 ; ' '
		BNE	loc_B712
		INY
		JMP	loc_B708

loc_B712:				
		CMP	#$40 ; '@'
		BNE	loc_B6DA
		LDX	#1
		CLC
		TYA
		LDY	#0
		ADC	unk_2F
		STA	unk_2F
		BCC	loc_B724
		INC	unk_30

loc_B724:				
		INY
		LDA	($2F),Y
		JSR	sub_B484
		BCC	loc_B72F
		INX
		BNE	loc_B724

loc_B72F:				
		CPX	#1
		BEQ	loc_B6DA
		STX	byte_36
		SEC
		LDA	unk_503
		SBC	#4
		CLC
		ADC	byte_36
		BCC	loc_B745
		LDA	#$12
		JMP	loc_859D

loc_B745:				
		STA	unk_503
		CLC
		LDA	unk_1F
		ADC	#4
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		STA	byte_F
		CLC
		LDA	unk_1F
		ADC	byte_36
		STA	byte_E
		SEC
		LDA	unk_503
		SBC	byte_36
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SBC	#2
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	unk_2F
		STA	byte_C
		LDA	unk_30
		STA	byte_D
		LDA	unk_1F
		STA	byte_E
		LDA	byte_20
		STA	byte_F
		LDY	byte_36
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	byte_36
		STX	byte_6B3
		STX	unk_1E
		BNE	loc_B78E

loc_B78C:				
		LDX	#1

loc_B78E:				
		TXA
		CLC
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		TXA
		CLC
		ADC	unk_1F
		STA	unk_1F
		BCC	loc_B79E
		INC	byte_20

loc_B79E:				
		JMP	loc_B689



sub_B7A1:				
					
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	loc_B7AB
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_B7B7
		RTS

loc_B7AB:				
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_B7B2
		JMP	loc_B89A

loc_B7B2:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_B7BA

loc_B7B7:				
		JMP	edit_mode_loop

loc_B7BA:				
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		STA	byte_36
		JSR	sub_BA69
		TXA
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		TAX
		LDA	$6BF,X
		CMP	byte_2C
		BNE	loc_B7DD
		LDA	$6BE,X
		CMP	byte_2B
		BNE	loc_B7DD
		INC	byte_36

loc_B7DD:				
		LDY	#3
		CLC
		LDA	byte_2B
		ADC	($2B),Y
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDY	#1
		LDA	($C),Y
		BMI	loc_B7B7
		LDA	byte_2D
		STA	unk_34
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	unk_37
		STX	byte_35
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	advance_2b_to_next_line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		JSR	sub_A01E
		CLC
		LDA	byte_2D
		ADC	unk_37
		ADC	byte_3B
		SEC
		SBC	#1
		SEC
		SBC	screen_height
		STA	unk_37
		BEQ	loc_B826
		BPL	loc_B829

loc_B826:				
		JMP	loc_B82C

loc_B829:				
		JSR	sub_B8BD

loc_B82C:				
		LDA	unk_37
		BEQ	loc_B832
		BPL	loc_B85D

loc_B832:				
		LDA	byte_36
		BNE	loc_B85D
		LDA	byte_6B3
		BEQ	loc_B852
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		LDX	unk_34
		JSR	loc_A021
		JSR	sub_AA17
		JMP	loc_B89D

loc_B852:				
		LDA	byte_35
		CMP	unk_34
		BNE	loc_B880

loc_B858:				
		PLA
		PLA
		JMP	loc_B89D

loc_B85D:				
		LDA	byte_6B3
		BEQ	loc_B880
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	byte_3B
		PHA
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B
		JMP	loc_B89D

loc_B880:				
		CLC
		LDA	byte_3B
		PHA
		ADC	byte_35
		STA	byte_3B
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B
		JMP	loc_B858

loc_B89A:				
		JSR	sub_AA06

loc_B89D:				
		LDA	byte_3B
		ASL
		TAX
		INX
		LDY	$6C0,X
		BNE	loc_B8AE
		DEY
		STY	current_line_no_lsb
		STY	current_line_no_msb
		BNE	loc_B8BA

loc_B8AE:				
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		INC	current_line_no_msb
		BNE	loc_B8BA
		INC	current_line_no_lsb

loc_B8BA:				
					
		JMP	sub_A069
; End of function sub_B7A1




sub_B8BD:				
		SEC
		LDA	unk_37
		SBC	#1
		ASL
		TAX
		TAY

loc_B8C5:				
		INY
		INY
		LDA	$6C0,X
		CMP	$6C0,Y
		BNE	loc_B8DB
		LDA	$6C1,X
		CMP	$6C1,Y
		BNE	loc_B8DB
		INC	unk_37
		BNE	loc_B8C5

loc_B8DB:				
		CLC
		TYA
		ADC	#-$40 ;	'À'
		STA	byte_C
		LDA	#6
		STA	byte_F
		ADC	#0
		STA	byte_D
		LDA	#-$40 ;	'À'
		STA	byte_E
		CLC
		LDA	screen_height
		ADC	#1
		SEC
		SBC	unk_37
		ASL
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JSR	make_cursor_invisible
		LDX	#0
		LDY	screen_height
		STY	byte_6AB
		JSR	gotoxy
		LDA	#$13
		JSR	OSBYTE
		LDY	unk_37
		LDA	#$A

loc_B914:				
		JSR	OSWRCH
		DEY
		BNE	loc_B914
		SEC
		LDA	byte_3B
		SBC	unk_37
		STA	byte_3B
		RTS
; End of function sub_B8BD


join_statements_edit_mode_command:	
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_B92A

loc_B927:				
		JMP	beep

loc_B92A:				
		LDY	#3
; set (byte_C) to point at next line
		CLC
		LDA	(byte_2B),Y
		ADC	byte_2B
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDY	#1
		LDA	(byte_C),Y
		BMI	loc_B927	; branch taken if next line is end of program
		JSR	sub_A8C0
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	advance_2b_to_next_line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		JSR	rstrip_detokenized_line
		LDA	byte_400
		STA	unk_700
		BEQ	loc_B987
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
		LDY	#0

loc_B966:				
		LDA	($C),Y
		CMP	#$20 ; ' '
		BNE	loc_B977
		DEC	unk_700
		INC	byte_C
		BNE	loc_B975
		INC	byte_D

loc_B975:				
		BNE	loc_B966

loc_B977:				
		LDA	#1
		STA	byte_E
		LDA	#7
		STA	byte_F
		LDX	#0
		LDY	unk_700
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_B987:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		JSR	rstrip_detokenized_line
		LDA	unk_700
		BEQ	loc_B9E5
		CLC
		ADC	byte_400
		BCS	loc_B9AD
		STA	unk_37
		LDX	byte_400
		BEQ	loc_B9C4
		CLC
		ADC	#1
		BCC	loc_B9B2

loc_B9AD:				
		LDA	#$14
		JMP	loc_859D

loc_B9B2:				
		CMP	#$FC ; -4 ; 'ü'
		BCS	loc_B9AD
		STA	unk_37
		LDA	#$3A ; ':'
		LDY	byte_400
		STA	$401,Y
		INY
		STY	byte_400

loc_B9C4:				
		CLC
		LDA	byte_400
		ADC	#1
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDA	#1
		STA	byte_C
		LDA	#7
		STA	byte_D
		LDX	#0
		LDY	unk_700
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	unk_37
		STA	byte_400

loc_B9E5:				
		LDA	#0
		STA	byte_6A7
		LDA	#1
		STA	byte_6B3
		JSR	sub_A8C0
		LDA	#1
		STA	byte_6A7
		JSR	find_program
		JSR	advance_2b_to_next_line
		LDA	byte_2B
		STA	byte_E
		LDA	byte_2C
		STA	byte_F
		JSR	advance_2b_to_next_line
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		SEC
		LDA	TOP
		SBC	byte_C
		TAY
		LDA	TOP+1
		SBC	byte_D
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JSR	sub_A01E
		CLC
		LDA	byte_3B
		ADC	byte_2D
		SEC
		SBC	#1
		CMP	screen_height
		BEQ	loc_BA47
		BCC	loc_BA47
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069
		JMP	loc_B00D

loc_BA47:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		JMP	loc_B025



rstrip_detokenized_line:		
		LDY	byte_400
		BEQ	loc_BA65

loc_BA5B:				
		LDA	$400,Y
		CMP	#$20 ; ' '
		BNE	loc_BA65
		DEY
		BNE	loc_BA5B

loc_BA65:				
					
		STY	byte_400
		RTS
; End of function rstrip_detokenized_line




sub_BA69:				
					
		LDA	screen_height
		ASL
		STA	byte_3A
		LDX	#0

loc_BA71:				
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_BA82
		INX
		LDA	$6C0,X
		CMP	byte_2C
		BNE	loc_BA83
		DEX
		RTS

loc_BA82:				
		INX

loc_BA83:				
		INX
		CPX	byte_3A
		BEQ	loc_BA71
		BCC	loc_BA71
		RTS
; End of function sub_BA69




back_command:				
		LDX	#0		; load colour index (0=background)

set_colour_from_command_line:		
		LDY	byte_6BE
		DEY
		BEQ	loc_BA98

back_command_error:					
		LDA	#$15
		JMP	loc_859D

loc_BA98:				
		LDA	($3E),Y		; get char from	command	line
		AND	#$DF		; toupper

find_colour_loop:			
		CMP	colour_chars,Y	; matched colour char?
		BEQ	got_colour	; taken	if colour found
		INY			; next colour char
		CPY	#8		; last colour?
		BNE	find_colour_loop ; taken if last colour	not yet	reached
		BEQ	back_command_error		; taken	if last	colour reached

got_colour:				
		STY	$A,X
		RTS
; End of function back_command




fore_command:				
		LDX	#1		; load colour index (1=foreground)
		BNE	set_colour_from_command_line ; JMP, in effect
; End of function fore_command		; set appropriate colour




insert_command:				
		LDA	#1

loc_BAB1:				
		STA	is_insert_mode	; 0=overtype 1=insert
		RTS
; End of function insert_command




overtype_command:			
		LDA	#0
		BEQ	loc_BAB1
; End of function overtype_command



help_command .proc
		LDA	#<command_table
		STA	unk_33
		LDA	#>command_table
                STA	unk_34

help_loop
                ldy #0
                lda (unk_33),y
                cmp #$ff
                beq done

                ; print command name
print_command_name_loop
                jsr oswrch
                iny
                lda (unk_33),y
                bne print_command_name_loop

                ; skip terminating 0
                iny
                
                ; fetch args flags into X
                lda (unk_33),y
                iny
                tax

                ; skip command ID
                iny

                ; point unk_34 at next command
                clc
                tya
                adc unk_33
                sta unk_33
                bcc nocarry
                inc unk_34
nocarry

                ; do args
                txa
                and #$20
                bne print_c

                txa
                and #$10
                bne s1s2

                txa
                and #$40
                bne n1n2

                txa
                and #$8
                bne print_p

                txa
                and #$2
                bne print_n

                txa
                and #5
                bne print_s

next_help
                lda #","
                jsr oswrch

                lda #32
                jsr oswrch
                
                jmp help_loop

print_c
                ldx #'c'
                bne onechar

print_p
                ldx #'p'
                bne onechar

print_n
                ldx #'n'
                bne onechar

print_s
                ldx #'s'
onechar
                lda #32
                jsr oswrch
                txa
                jsr oswrch
                jmp next_help

s1s2
                ldx #<aS1S2
                ldy #>aS1S2
                lda #6
                bne nchars

n1n2
                ldx #<aN1N2
                ldy #>aN1N2
                lda #6
nchars
                jsr print_n_chars
                jmp next_help

done
print_help_footer:			
                LDX	#<help_footer_begin
		LDY	#>help_footer_begin
		LDA	#help_footer_end-help_footer_begin
		JMP	print_n_chars	; Print	"Where:	p is a program;" (etc.)
.pend
;-------------------------------------------------------------------------

goto_line_command .proc				
		LDA	byte_3F
		STA	byte_2B
		LDA	byte_3E
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	($2B),Y
		BMI	loc_BBB0
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	loc_9DA8

loc_BBB0:				
		JMP	end_edit_mode_command
.pend


info_command:				
                JSR	osnewl

                ; lda language_entry_mode
                ; clc
                ; adc #'A'
                ; jsr oswrch                

                
                ldx #<aScroll
                ldy #>aScroll
                lda #aScrollEnd-aScroll
                jsr print_n_chars

                lda scroll_status ;1=scroll 0=noscroll
                jsr print_on_off
                
                jsr osnewl

                ldx #<aInsert
                ldy #>aInsert
                lda #aInsertEnd-aInsert
                jsr print_n_chars

                lda is_insert_mode ;0=overtype 1=insert
                jsr print_on_off

                jsr osnewl

                ldx #<aCase
                ldy #>aCase
                lda #aCaseEnd-aCase
                jsr print_n_chars

                lda case_insensitive_search
                jsr print_on_off

                jsr osnewl
                
		LDA	#$87		; get MODE in Y
		JSR	OSBYTE		; get MODE in Y
		CPY	#7		; MODE 7?
		BNE	print_colours
		LDA	background_colour
		PHA
		LDA	foreground_colour
		PHA
		LDA	#7
		STA	foreground_colour ; foreground is white
		LDA	#0
		STA	background_colour ; background is black
		JSR	print_colour_scheme
		PLA
		STA	foreground_colour
		PLA
		STA	background_colour
		BPL	loc_BC0B

print_colours:				
					
		JSR	print_colour_scheme

loc_BC0B:				
		JSR	OSNEWL
		JSR	OSNEWL
		LDX	#<aProgramName
		LDY	#>aProgramName
		LDA	#$E
		JSR	print_n_chars
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		LDX	#<program_name
		LDY	#>program_name
		LDA	#$F
		JSR	print_n_chars
		JSR	OSNEWL
		LDX	#<aLastSearch
		LDY	#>aLastSearch
		LDA	byte_62
		BNE	loc_BC37
		LDA	#$12
		BNE	loc_BC42

loc_BC37:				
		LDA	#$E
		JSR	print_n_chars
		LDX	#<unk_643
		LDY	#>unk_643
		LDA	byte_62

loc_BC42:				
		JSR	print_n_chars
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	OSNEWL
		JSR	OSNEWL
		LDX	#<aTabValue
		LDY	#>aTabValue
		LDA	#$E
		JSR	print_n_chars
		LDX	unk_61
		LDY	#0
		JSR	sub_BD96
		JSR	sub_BD83
		LDX	#<aNo_ofLines
		LDY	#>aNo_ofLines
		LDA	#$D
		JSR	print_n_chars
		LDA	unk_16
		BNE	loc_BC94
		LDX	#0
		STX	byte_38
		STX	byte_39
		STX	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_BC7C:				
		LDY	#1
		LDA	($2B),Y
		BMI	loc_BC8D
		JSR	advance_2b_to_next_line
		INC	byte_38
		BNE	loc_BC8B
		INC	byte_39

loc_BC8B:				
		BNE	loc_BC7C

loc_BC8D:				
		LDX	byte_38
		LDY	byte_39
		JSR	sub_BD96

loc_BC94:				
		JSR	OSNEWL
		LDA	unk_16
		BEQ	loc_BC9C
		RTS

loc_BC9C:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_BCA4
		JMP	loc_BD22

loc_BCA4:				
		LDX	#<aFirstLine
		LDY	#>aFirstLine
		LDA	#$E
		JSR	print_n_chars
		JSR	sub_BD8D
		JSR	sub_BD83
		LDX	#<aLastLine
		LDY	#>aLastLine
		LDA	#$D
		JSR	print_n_chars
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#2
		LDA	($2F),Y
		TAX
		DEY
		LDA	($2F),Y
		TAY
		JSR	sub_BD96
		JSR	OSNEWL
		LDX	#<aCurrentLine
		LDY	#>aCurrentLine
		LDA	#$E
		JSR	print_n_chars
		LDX	current_line_no_msb
		LDY	current_line_no_lsb
		JSR	sub_BD96
		JSR	sub_BD83
		JSR	sub_B37B
		PHP
		LDX	#<aMarkedLine
		LDY	#>aMarkedLine
		PLP
		BNE	loc_BCFF
		LDA	#$D
		JSR	print_n_chars
		LDX	unk_4E
		LDY	unk_4D
		JSR	sub_BD96
		JMP	loc_BD04

loc_BCFF:				
		LDA	#$11
		JSR	print_n_chars

loc_BD04:				
		JSR	OSNEWL
		JSR	OSNEWL
		LDX	#<aPendingCommands
		LDY	#>aPendingCommands
		LDA	byte_40
		CMP	#$20 ; ' '
		BNE	loc_BD25
		LDA	byte_46
		CMP	#$20 ; ' '
		BNE	loc_BD25
		LDA	#$16
		JSR	print_n_chars

loc_BD1F:				
		JSR	OSNEWL

loc_BD22:				
		JMP	OSNEWL

loc_BD25:				
					
		LDA	#$12
		JSR	print_n_chars
		JSR	OSNEWL
		LDA	byte_40
		CMP	#$20 ; ' '
		BEQ	loc_BD46
		LDA	byte_43
		CMP	#$20 ; ' '
		BEQ	loc_BD46
		JSR	sub_AD1A
		BCC	loc_BD46
		LDX	byte_40
		LDY	byte_43
		STX	byte_43
		STY	byte_40

loc_BD46:				
					
		LDA	#0
		STA	byte_39

loc_BD4A:				
		LDX	byte_39
		CPX	#7
		BCS	loc_BD1F
		LDA	$40,X
		CMP	#$20 ; ' '
		BEQ	loc_BD7B
		CMP	#$60 ; '`'
		BCC	loc_BD60
		SEC
		SBC	#$20 ; ' '
		JSR	OSWRCH

loc_BD60:				
		JSR	OSWRCH
		LDA	#$20 ; ' '
		JSR	OSWRCH
		LDA	$41,X
		TAY
		LDA	$42,X
		TAX
		JSR	sub_BD96
		LDX	#3
		LDA	#$20 ; ' '

loc_BD75:				
		JSR	OSWRCH
		DEX
		BNE	loc_BD75

loc_BD7B:				
		INC	byte_39
		INC	byte_39
		INC	byte_39
		BNE	loc_BD4A
; End of function info_command




sub_BD83:				
					
		LDA	#$86 ; -$7A ;	'†'
		JSR	OSBYTE
		LDX	#$15
		JMP	gotoxy
; End of function sub_BD83




sub_BD8D:				
		LDY	#2		; offset of line number	MSB
		LDA	($17),Y		; get line number MSB
		TAX
		DEY			; offset of line number	LSB
		LDA	($17),Y		; get line number LSB
		TAY
; End of function sub_BD8D




sub_BD96:				
					
		JSR	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string
		JMP	print_number	; print	number.
; End of function sub_BD96		;
					; Suitable for use with	the result of itoa.
					;
					; Entry:
					; unk_0	= digit	count
					; unk_1... = digits



print_colour_scheme:			
					
		LDA	foreground_colour ; get	foreground colour
		CLC			; capitalize
		JSR	print_colour_name
		LDX	#<aOn
		LDY	#>aOn
		LDA	#4
		JSR	print_n_chars	; print	" on "
		LDA	background_colour
		SEC			; don't capitalize

print_colour_name:			
		PHP
		STA	byte_3A
		LDX	#$FF		; index	of current colour name
		LDY	#0		; offset into table

loc_BDB5:				
		LDA	colour_names_table,Y ; get next	byte
		BPL	next_byte	; if +ve, still	current	name
		INX			; just found new colour	name, so inc X
		CPX	byte_3A		; is it	the one?
		BEQ	print_name	; print	if so.

next_byte:				
		INY
		BNE	loc_BDB5

print_name:				
		AND	#$7F		; make printable
		PLP
		BCC	print_chars	; capitalize?
		ORA	#$20 ; ' '      ; toupper

print_chars:				
					
		JSR	OSWRCH
		INY
		LDA	colour_names_table,Y
		BPL	print_chars
		RTS
; End of function print_colour_scheme




sub_BDD3:				
					
		LDA	byte_3E
		PHA
		LDA	byte_3F
		PHA
		LDA	unk_6BA
		STA	byte_3E
		LDA	unk_6BB
		STA	byte_3F
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	byte_6BE
		BCS	loc_BDF5
		SEC
		SBC	#1
		CMP	byte_400
		BEQ	loc_BE09
		BCC	loc_BE09

loc_BDF5:				
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	unk_6BC
		BCS	loc_BE23
		SEC
		SBC	#1
		CMP	#-4 ; 'ü'
		BCS	loc_BE23
		STA	byte_400
		BCC	loc_BE57

loc_BE09:				
		SEC
		LDA	unk_6BC
		SBC	byte_6BE
		STA	unk_6AE
		CLC
		ADC	byte_400
		PHA
		LDY	unk_6AE
		BMI	loc_BE2B
		BCS	loc_BE23
		CMP	#-4 ; 'ü'
		BCC	loc_BE2B

loc_BE23:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	#$25 ; '%'
		JMP	loc_859D

loc_BE2B:				
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		ADC	byte_6BE
		STA	byte_C
		ADC	unk_6AE
		STA	byte_E
		LDA	#4
		STA	byte_D
		STA	byte_F
		LDX	#0
		CLC
		LDA	byte_400
		ADC	#1
		SEC
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SEC
		SBC	byte_6BE
		TAY
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		PLA
		STA	byte_400

loc_BE57:				
		LDA	byte_3E
		STA	byte_C
		LDA	byte_3F
		STA	byte_D
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDX	#0
		LDY	unk_6BC
		CLC
		TYA
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_6B3
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
                RTS
; End of function sub_BDD3




find_mode_getch:				
					
		JSR	kbflush
		LDA	is_insert_mode	; 0=overtype 1=insert
		PHA
		LDA	#1
		STA	is_insert_mode	; 0=overtype 1=insert
		JSR	reset_cursor_shape
		PLA
		STA	is_insert_mode	; 0=overtype 1=insert
		JSR	getch
		JMP	make_cursor_invisible
; End of function find_mode_getch




sub_BE98:				
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	loc_BEA2
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_BEB2
		RTS

loc_BEA2:				
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_BEA9

loc_BEA6:				
		JMP	loc_BFBB

loc_BEA9:				
		LDA	byte_3B
		BNE	loc_BEA6
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_BEB5

loc_BEB2:				
		JMP	edit_mode_loop

loc_BEB5:				
		JSR	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		LDA	unk_30
		BEQ	loc_BEB2
		JSR	make_cursor_invisible
		LDA	byte_2D
		STA	byte_35
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA
		SEC
		SBC	byte_35
		STA	byte_35
		LDA	unk_8
		PHA
		LDA	unk_9
		PHA
		JSR	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		JSR	sub_A01E
		LDX	#0
		LDY	#0
		JSR	gotoxy
		LDA	#19
		STA	byte_6AB
		JSR	OSBYTE
		LDY	byte_2D
		LDA	#11

loc_BEF7:				
		JSR	OSWRCH
		DEY
		BNE	loc_BEF7
		LDA	byte_35
		BEQ	loc_BF04
		JMP	loc_BF5B

loc_BF04:				
		SEC
		LDA	screen_height
		SBC	byte_2D
		STA	byte_36
		INC	byte_36

loc_BF0E:				
		LDA	byte_36
		ASL
		TAX
		TAY
		INX
		LDA	$6C0,X
		BEQ	loc_BF5B
		DEY
		CMP	$6C0,Y
		BNE	loc_BF4F
		DEX
		DEY
		LDA	$6C0,X
		CMP	$6C0,Y
		BNE	loc_BF4F
		LDA	#0
		STA	$6C0,X
		STA	$6C1,X
		DEC	byte_36
		CLC
		LDA	byte_36
		ADC	byte_2D
		TAY
		LDX	#0
		JSR	gotoxy
		CLC
		LDA	code_area_width
		ADC	#6
		TAY
		LDA	#$20 ; ' '

loc_BF47:				
		JSR	OSWRCH
		DEY
		BNE	loc_BF47
		BEQ	loc_BF0E

loc_BF4F:				
		LDA	byte_36
		ASL
		TAX
		LDA	#0
		STA	$6C0,X
		STA	$6C1,X

loc_BF5B:				
		LDA	byte_2D
		ASL
		STA	byte_E
		LDA	#6
		STA	byte_D
		STA	byte_F
		LDA	#-$40 ;	'À'
		STA	byte_C
		CLC
		ADC	byte_E
		STA	byte_E
		BCC	loc_BF73
		INC	byte_F

loc_BF73:				
		CLC
		LDA	screen_height
		ADC	#1
		SEC
		SBC	byte_2D
		ASL
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JSR	sub_9F00
		JSR	advance_2b_to_next_line
		LDA	byte_2D
		STA	byte_3B
		ASL
		TAX
		LDA	byte_2B
		STA	$6C0,X
		LDA	byte_2C
		STA	$6C1,X
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		PLA
		STA	unk_9
		PLA
		STA	unk_8
		LDA	byte_6B3
		BNE	loc_BFB5
		LDA	byte_35
		BEQ	loc_BFBE

loc_BFB5:				
		JSR	sub_AA17
		JMP	loc_BFBE

loc_BFBB:				
		JSR	sub_AA06

loc_BFBE:				
					
		LDA	byte_3B
		ASL
		TAX
		BNE	loc_BFCB
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69

loc_BFCB:				
		DEX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	sub_BA69
		TXA
		LSR
		STA	byte_3B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	sub_A069
; End of function sub_BE98



; finds	current	line by	number.
;
; Entry:
; current_line_no_lsb,
; current_line_no_msb =	line number to search for
;
; Exit:
; (byte_2B) points to line found

find_current_line_by_number:		
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		JMP	find_line_by_number ; finds a line, given a line number
; End of function find_current_line_by_number ;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
                                        ; (byte_2B) points to most suitable line

zsave_command: .proc
                lda program_name
                cmp #13
                beq no_program_name

                ; pretend program name was command line, and forward
                ; straight to SAVE.
                lda #<program_name
                sta byte_3E
                lda #>program_name
                sta byte_3F
                jmp save_command

no_program_name:
                lda #39         ;No program name
                jmp loc_859D
.pend

zrun_command: .proc
                jsr zsave_command

                lda #CMD_RUN
                sta current_command_id
                jmp run_or_exit_command
.pend

store_program_name .proc
                jsr reset_program_name

                ldy #0
loop
                lda ($3e),y     ;next char from command line or whatever
                cmp #13
                beq store_program_name.done
                sta program_name,y
                iny
                cpy #14         ;leave at least one 13
                bne loop
done

                rts
.pend
print_program_name_padded .proc

                jsr print_program_name
                
loop
                cpx #14
                bcs done

                lda #32
                jsr oswrch
                inx
                bne loop

done
                rts
.pend
print_program_name .proc
                ldx #0
loop
                lda program_name,X
                cmp #13
                beq done
                jsr oswrch
                inx
                bne loop
                
done
                rts
.pend
find_rem_name .proc
                ; check for intial 13.
                ldy #0
                lda ($17),y
                cmp #13
                bne done

                ; check line MSB - no program if -ve.
                iny

                lda ($17),y
                bmi done

                ldy #3
                ; look for REM
                jsr skipspaces
                cmp #$F4        ;REM
                bne done

                ; look for >
                jsr skipspaces
                cmp #'>'
                bne done

                ; no name if just spaces.
                jsr skipspaces
                cmp #13
                beq done

                ; point ($3e) at name
                clc
                tya
                adc $17
                sta $3e
                lda $18
                adc #0
                sta $3f
                jsr store_program_name
done
                rts

skipspaces
                iny
                lda ($17),y
                cmp #32
                beq skipspaces
                rts

.pend
case_command .proc
                lda #0
                sta case_insensitive_search
                rts
.pend
                
nocase_command .proc
                lda #$80
                sta case_insensitive_search
return:
                rts
.pend

maybe_verbose_exit_on_error: .proc
                bit language_entry_mode
                bpl nocase_command.return

                jsr display_error_message
                jmp exit_and_OLD
                
.pend

.here
; end of 'seg002'

