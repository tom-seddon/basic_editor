;-------------------------------------------------------------------------

KEEP_DELETE_LINE_MEMSET = false
KEEP_CLEAR_5B1_TO_600_MEMSET = false
KEEP_DETOKENIZE_ONE_LINE_MEMSET = false
KEEP_9E1D_MEMSET = false

; I strip out the memmove calls one at a time...
KEEP_B8DB_MEMMOVE = false
KEEP_BF73_MEMMOVE = false
KEEP_A8C0_MEMMOVE = false

;-------------------------------------------------------------------------

ENABLE_DEBUG = false
                
;-------------------------------------------------------------------------

LINE_NUMBER_TOKEN=$8d
REM_TOKEN=$f4

; max length of text of line, +1.
LINE_LENGTH_LIMIT=$fc           

; if true, CTRL+up/down = move cursor to first/last line of screen.
;
; if false, CTRL+up/down = move cursor between program lines
ORIGINAL_CTRL_UP_DOWN=true

; if X bit 7 clear: set options byte to X, return old value
; if X bit 7 set: leave options alone, return old value
OPTIONS_OSBYTE=26

OPTION_SHIFT_ESCAPE=1
OPTION_EDIT_MODE=2
                
;-------------------------------------------------------------------------

; Language entry point modes.
;
LANGUAGE_MODE_NORMAL=1
LANGUAGE_MODE_SHIFT_ESCAPE=2
                
LANGUAGE_MODE_ZSAVE=$80
LANGUAGE_MODE_ZRUN=$81

;-------------------------------------------------------------------------
; SLRE---1-
; S=service
; L=language
; R=copro relocation
; E=electron soft key

.if HI||RELOCATABLE
ROM_FLAGS = %11100010
.else
ROM_FLAGS = %11000010
.endif

;-------------------------------------------------------------------------

                
;-------------------------------------------------------------------------
                
                .section service
                .block
                
osbyte_var: .function index
                .cerror index<$a6||index>$ff,"bad OSBYTE"
                .endf $190+index

                .if BUILD_TYPE==4

push_addrs: .macro
                .for i=0,i<len(\1),i+=1
                lda \1[i]
                pha
                .next
                .endm

pop_addrs: .macro
                .for i=len(\1)-1,i>=0,i-=1
                pla
                sta \1[i]
                .next
                .endm

push_and_copy_addrs: .macro
                .for i=0,i<len(\1),i+=1
                lda \1[i]
                pha
                lda \2+i
                sta \1[i]
                .next
                .endm

pop_and_copy_addrs: .macro
                .for i=len(\1)-1,i>=0,i-=1
                lda \1[i]
                sta \2+i
                pla
                sta \1[i]
                .next
                .endm

                ; Y/X points to string on entry. On exit, $70/$71
                ; holds result and $72 holds final status register
                ; value.
                jmp test_atoi   ;+0

                ; random thing I wanted to test.
                jmp language.clear_5B1_to_600 ;+3

                ; random thing I wanted to test.
                jmp test_detokenize_one_line_memset ;+6

                ; random thing I wanted to test.
                jmp test_loc_9e1d_memset ;+9

                ; ; A/X/Y as per memset. Changes $70.
                jmp test_memset ;+12

                ; X=replacement byte
                ; Y=# chars to remove
                ; ($72) is pointer
                ; changes $70
                jmp test_B0BB   ;+15

test_B0BB: .proc
addrs:=(byte_25,byte_26,byte_27,byte_28)
                push_and_copy_addrs addrs,$70
                txa
                jsr language.sub_B0BB
                pop_and_copy_addrs addrs,$70
                rts
                .pend

test_loc_9e1d_memset: .proc
addrs:=(byte_C,byte_D,byte_3A)
                push_addrs addrs
                lda language.sub_9DEA.loc_9e2e
                pha
                lda #$60
                sta language.sub_9DEA.loc_9e2e
                jsr language.sub_9DEA.loc_9e1d
                pla
                sta language.sub_9DEA.loc_9e2e
                pop_addrs addrs
                rts
                
                .pend

test_detokenize_one_line_memset: .proc
addrs:=(byte_C,byte_D,byte_2C,byte_3A)
                push_addrs addrs
                lda #$ff        ;make it just do the memset
                sta byte_2C
                jsr language.detokenize_one_line
                pop_addrs addrs
                rts
                .pend

test_memset: .proc
addrs:=(byte_C,byte_D,byte_3A)
                sta $70
                push_addrs addrs
                lda $70
                jsr language.memset
                pop_addrs addrs
                rts
                .pend

test_atoi: .proc
addrs:=(byte_C,byte_D,byte_3E,byte_3F)
                push_addrs addrs
                stx byte_C
                sty byte_D
                jsr language.atoi
                php
                pla
                sta $72
                lda byte_3E
                sta $70
                lda byte_3F
                sta $71
                pop_addrs addrs
                rts
                .pend     

                .endif

rom_start:
                JMP     language.language_entry
                JMP     svc

                .byte ROM_FLAGS

                .byte  copyright-rom_start ;
                .byte     $FF
aTheBasicEditor_0:
                .text    "The "
                .if HI
                .text "HI"
                .endif
                .text "BASIC Editor"
                .if ENABLE_DEBUG
                .text " (DEBUG)"
                .endif
                .text 0
                .text VER
.if ELECTRON
				.text "E"
.endif
.if RELOCATABLE
                .text "r"
.endif
copyright:
                .byte 0
aC1984Acornsoft:
                ; was "(C) 1984 Acornsoft". Sorry, Acornsoft!
                .text "(C)",0
                .if HI||RELOCATABLE
                ; this address gets fixed up by make_reloc, based on
                ; the relocation value in the altrom.
                .word LANG_BASE
                .word 0
                .endif
                
; A = code, X = ROM number, Y = parameter.

svc: .proc
                pha

                cmp #4
                beq svc_star

                .if !HI
                cmp #6
                beq svc_brk
                .endif

                cmp #7
                beq svc_osbyte
                
                cmp #9
                beq svc_help

done:
                pla
                ldx $f4
                rts

claimed:
                pla
                lda #0
                ldx $f4
                rts
                
                .pend

;-------------------------------------------------------------------------

svc_star: .proc
                tya
                pha

                .if HI
                ; if there's no Tube, just ignore the request - this
                ; gives the non-HI ROM a chance, if it's there, or a
                ; Bad Command, if it isn't (since the HI language code
                ; can't run in the IO processor).
                ldx osbyte_var($ea)
                inx
                bne ply_and_svc_done
                .endif
                
check_be:
                ; *...
                lda ($f2),Y
                and #$df
                cmp #"B"
                bne ply_and_svc_done

                ; *B....
                iny
                iny
                lda ($f2),Y
                cmp #13
                bne ply_and_svc_done

check_command:
                ; *B?|M
                dey
                lda ($f2),y
                
                ldx #LANGUAGE_MODE_NORMAL
                cmp #"E"
                beq enter_language

                ldx #LANGUAGE_MODE_ZSAVE
                cmp #"Z"
                beq enter_language

                ldx #LANGUAGE_MODE_ZRUN
                cmp #"R"
                beq enter_language
                ; fall through
                .pend
ply_and_svc_done: .block
                pla
                tay
                jmp svc.done
                .bend

;-------------------------------------------------------------------------

enter_language: .proc
                ; set the user flag for the language entry point.
                lda #1
                jsr osbyte

                ldx $f4
                lda #$8e        ;enter language ROM
                jmp osbyte
                .pend

;-------------------------------------------------------------------------

svc_help: .proc
                lda ($f2),Y
                cmp #" "
                beq print_help
                cmp #13
                bne svc.done
print_help:
                tya
                pha
                jsr osnewl
                ldy #0
print_help_name_loop:
                lda aTheBasicEditor_0,Y
                bne +
                lda #32
+
                jsr oswrch
                iny
                cpy #aC1984Acornsoft-aTheBasicEditor_0
                bne print_help_name_loop
                jsr osnewl
                jmp ply_and_svc_done
                .pend

;-------------------------------------------------------------------------

svc_brk: .proc
                tya
                pha

                jsr language.get_options
                and #OPTION_SHIFT_ESCAPE
                beq ply_and_svc_done ;taken if SHIFT+ESCAPE not enabled
                
                ldy osbyte_var($ba) ;ROM active at last BRK (MasRef
                                    ;D.2-56)
                cpy osbyte_var($bb) ;ROM number of socket containing
                                    ;BASIC (MasRef D.2-57)
                bne ply_and_svc_done;taken if not BRK in BASIC

                ; MasRef D.6-1
                lda $fd         ;error address LSB
                sta $f6         ;osrdsc address LSB
                
                lda $fe         ;... MSB
                sta $f7         ;... MSB

                ; Y=rom #
                jsr osrdsc

                cmp #17          ;was it Escape?
                bne ply_and_svc_done ;taken if not Escape

                jsr language.poll_shift
                bne ply_and_svc_done ;taken shift not pressed

                ; Shift+ESCAPE pressed during BASIC...
                lda #$7e        ;acknowledge escape (MasRef D.2-37)
                jsr osbyte
                
                ldx #LANGUAGE_MODE_SHIFT_ESCAPE
                jmp enter_language
                
                .pend

;-------------------------------------------------------------------------

svc_osbyte: .proc
                lda $ef
                cmp #OPTIONS_OSBYTE
                bne svc.done

                ; save off old value
                lda $df0,x
                pha

                ; update value, if X bit 7 clear
                lda $f0
                bmi +
                sta $df0,x
+

                ; return old value in X
                pla
                sta $f0
                jmp svc.claimed
                
                .pend

;-------------------------------------------------------------------------

osbyte_x00_yff:
                ldx #$00
osbyte_yff:
                ldy #$ff
                jmp osbyte

;-------------------------------------------------------------------------

; get_default_wordv: .proc
;                 lda $ffb7
;                 sta $a8
;                 lda $ffb8
;                 sta $a9
;                 ldy #<wordv
;                 lda ($a8),y     ;lsb
;                 tax
;                 lda ($a8),y     ;msb
;                 tay
;                 rts
;                 .pend

; osword_hook: .proc
;                 sta $ef
;                 stx $f0
;                 sty $f1
;                 jsr get_default_wordv
;                 jsr call_osword

;                 php
;                 pha
;                 txa
;                 pha
;                 tya
;                 pha
                
;                 bcc not_us

;                 lda #$fc        ;read language ROM number (AUG 243)
;                 jsr osbyte_x00_yff
;                 sta $ef
                
;                 lda #$bb        ;read BASIC ROM number
;                 jsr osbyte_x00_yff
;                 txa

;                 tsx
;                 cmp $ef
;                 bne not_us      ;taken if not BASIC ROM

;                 ; poll SHIFT
;                 lda #$81        ;poll for key (MasRef D.2-38)
;                 ldx #$ff        ;-1, shift
;                 jsr osbyte_yff
;                 inx
;                 bne not_us      ;taken if X!=$ff, i.e., shift not
;                                 ;pressed
                
;                 ; Shift+ESCAPE pressed during BASIC...
;                 lda #$7e        ;acknowledge escape (MasRef D.2-37)
;                 jsr osbyte
                
;                 ldx #LANGUAGE_MODE_NORMAL
;                 jmp enter_language

; not_us:
;                 pla
;                 tay
;                 pla
;                 tax
;                 pla
;                 sta $ef
;                 plp
;                 rts

; call_osword:
;                 lda $f0
;                 stx $f0
;                 tax
;                 lda $f1
;                 sty $f1
;                 tay
;                 lda $ef
;                 jmp ($f0)
                
                ; .pend

;-------------------------------------------------------------------------
                
                .bend
                .send service
;-------------------------------------------------------------------------

                .section language
language: .block
; .logical LANG_BASE+(*-SVC_BASE)

init_language_entry_mode: .proc
                ; read the user flag that was set by the service call
                ; 4 handler.
                lda #1
                ldx #0
                jsr osbyte

                stx language_entry_mode

                cpx #LANGUAGE_MODE_ZSAVE
                beq zsave

                cpx #LANGUAGE_MODE_ZRUN
                beq zrun
ret:
                rts

zsave:
                jsr saving_message
                jsr zsave_command
                jmp exit_and_OLD

zrun:
                jsr saving_message
                jsr zsave_command
                jmp exit_and_OLD_and_RUN

saving_message:
                lda #1
                sta editor_mode_id  ; 1=command mode, 2=edit mode
                
                jsr find_program_name
                bcc ret

                jsr print_next_string
                .text "Saving: ",255
                
                jsr print_program_name
                jmp osnewl

.pend
                
language_entry: .proc
                CMP     #1              ; normal language entry?
                BEQ     language_start
                RTS

language_start:
                .if ENABLE_DEBUG
                jsr reset_debug_values
                .endif
                
                JSR     init_brkv_and_oshwm
                JSR     clear_line_commands
                JSR     sub_B358
                LDX     #5
                STX     tab_value
                LDX     #$60 ; '`'
                STX     cursor_size
                LDX     #0
                STX     search_string_length
                INX
                STX     is_insert_mode  ; 0=overtype 1=insert
                STX     is_scroll_on   ; 1=scroll, 0=noscroll
                LDA     #$E4
                JSR     osbyte_with_y0
                JSR     clear_5B1_to_600
                ldx #$ff
                JSR     get_HIMEM_for_mode_X
                LDA     #0
                STA     background_colour
                sta case_insensitive_search
                LDA     #7
                STA     foreground_colour

                JSR     sub_8314
                JSR     find_program
                BCC     language_start_good_program
                JSR     clear_program
                JSR     clear_5B1_to_600

language_start_good_program:

                jsr init_language_entry_mode

                LDA     #$D2
                JSR     osbyte_with_x0_y0 ;suppress sound
                
                jsr print_next_string
                .byte 254       ;allow control chars
                .byte 3         ;printer off
                .byte 6         ;enable VDU drivers
                .byte 4         ;use text cursor
                .byte 26        ;restore default windows
                .byte 12        ;CLS
                .byte 15        ;disable paged mode
                .byte 20        ;reset VDU19 stuff
                .byte 17,7      ;COLOUR7
                .byte 17,128    ;COLOUR128
                .byte 255
                
command_prompt_loop:

                LDX     #$FF
                TXS
                
                JSR     initialise
                JSR     find_program
                BCS     loc_8147
                JSR     is_program_empty ; sets C if no program
                BCS     loc_8147
                LDA     current_line_no_msb
                STA     byte_2B
                LDA     current_line_no_lsb
                STA     byte_2C
                JSR     find_line_by_number ; finds a line, given a line number
                                        ;
                                        ; Entry:
                                        ; byte_2B: line number MSB
                                        ; byte_2C: line number LSB
                                        ;
                                        ; Exit:
                                        ; (byte_2B) points to most suitable line
                LDY     #1
                LDA     (byte_2B),Y
                BPL     loc_8144
                JSR     sub_AA77        ; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_8144:                               
                JSR     save_line_number ; saves line number from program.
                                        ;
                                        ; Entry:
                                        ; (byte_2b) points to current line
                                        ;
                                        ; Exit:
                                        ; current_line_no_msb, current_line_no_lsb = the line number

loc_8147:
                ; do a one-time check for SHIFT+ESCAPE - if entered
                ; due to SHIFT+ESCAPE, and the options byte says edit
                ; mode was the last one used, go to edit mode.
                lda language_entry_mode
                cmp #LANGUAGE_MODE_SHIFT_ESCAPE
                bne +           ;not SHIFT+ESCAPE, or we already
                                ;checked

                ; pretend it was entered with LANGUAGE_MODE_NORMAL
                lda #LANGUAGE_MODE_NORMAL
                sta language_entry_mode

                jsr get_options
                and #OPTION_EDIT_MODE
                beq +           ;taken if last mode wasn't edit mode

                jmp enter_edit_mode
                
+
                
                jsr clear_edit_mode_option
                JSR     print_command_prompt
                JSR     do_command_line

command_loop:
                LDA     editor_mode_id  ; 1=command mode, 2=edit mode
                CMP     #2              ; edit mode?
                BNE     command_prompt_loop ; branch taken if command mode already
                
                ; leave edit mode
                LDA     byte_15
                BEQ     loc_8163
                
                LDA     current_line_no_msb
                STA     byte_50
                LDA     current_line_no_lsb
                STA     byte_51
                
                JMP     command_prompt_loop

loc_8163:                               
                LDA     byte_6C1
                CMP     #-1
                BEQ     command_prompt_loop
                
                STA     byte_3A
                LDA     byte_6C0
                STA     byte_39
                LDY     #1
                LDA     (byte_39),Y
                STA     byte_50
                INY
                LDA     (byte_39),Y
                STA     byte_51
                
                JMP     command_prompt_loop
; End of function language_entry
                .pend

;-------------------------------------------------------------------------

init_brkv_and_oshwm: .proc

                CLI
                CLD
                LDA     #<brk_handler
                STA     $202            ; BRKV+0
                LDA     #>brk_handler
                STA     $203            ; BRKV+1
                LDA     #0
                STA     oshwm
                STA     unk_6AD
                LDA     #$83
                JSR     OSBYTE          ; Read OSHWM
                STY     oshwm+1         ; $18 = MSB
                LDA     #$82
                JSR     OSBYTE          ; Read machine higher order address
                STX     higher_order_address
                STY     higher_order_address+1
                LDA     #0
                STA     unk_6B8
                LDA     #$A
                STA     unk_6B9
                RTS
.pend
                
get_HIMEM_for_mode_X: .proc
                LDY     higher_order_address
                INY
                BNE     is_tube
                LDY     higher_order_address+1
                INY
                BEQ     is_not_tube

is_tube:
                lda #<LANG_BASE
                sta HIMEM+0
                lda #>LANG_BASE
                sta HIMEM+1                
                RTS

is_not_tube:
                lda #132        ;read HIMEM for current MODE
                cpx #$ff
                beq get_HIMEM
                LDA     #133    ;read HIMEM for given MODE
get_HIMEM:
                JSR     OSBYTE
                STX     HIMEM
                STY     HIMEM+1
                RTS
; End of function validate_mode


.pend
print_command_prompt: .proc
                bit should_cls_before_command_prompt
                bpl +
                lsr should_cls_before_command_prompt
                lda #12
                jsr oswrch
+


                LDA     byte_15
                BEQ     loc_82CB
                jsr display_error_message

loc_82CB:
                jsr print_bytes_free
                
                jsr print_next_string
                .text ' '

                .if ENABLE_DEBUG
                .text 'D'
                .endif
                
                .text '>',255
                
                LDA     is_insert_mode  ; 0=overtype 1=insert
                PHA
                LDA     cursor_size
                PHA
.if !ELECTRON
                LDA     #0
.else
                LDA     #1
.endif
                STA     is_insert_mode  ; 0=overtype 1=insert
                LDA     #$60 ; '`'
                STA     cursor_size
                JSR     reset_cursor_shape
                PLA
                STA     cursor_size
                PLA
                STA     is_insert_mode  ; 0=overtype 1=insert
                RTS
.pend

display_error_message: .proc

                JSR     OSNEWL

                LDX     #$4F ; 'O'
                LDY     #$28 ; '('

loc_82AE:                               
                LDA     $5D7,Y
                CMP     #$20 ; ' '
                BNE     loc_82BA
                DEY
                BNE     loc_82AE
                LDX     #$27 ; '''

loc_82BA:
                TXA
                LDX     #<unk_5B1
                LDY     #>unk_5B1
                JSR     print_n_chars
                
                JSR     OSNEWL
                JSR     OSNEWL
                JMP     beep
.pend

get_text_window_left_bottom:            
                                        
                LDX     #8
                LDA     #$A0
                JMP     OSBYTE
; End of function get_text_window_left_bottom




clear_program:                          
                                        
                LDY     #0
                LDA     #$D
                STA     (oshwm),Y
                INY
                LDA     #-1
                STA     (oshwm),Y
                JSR     find_program
                LDA     #0
                STA     current_line_no_msb
                LDA     #$A
                STA     current_line_no_lsb
                JSR     sub_B358
                JMP     clear_line_commands
; End of function clear_program




sub_8314:                               
                                        
                LDA     #0
                STA     current_line_no_msb
                STA     current_line_no_lsb
                STA     byte_50
                STA     byte_51
                RTS
; End of function sub_8314




find_program:                           
                                        
                LDA     #0
                STA     is_bad_program
                STA     byte_38
                STA     byte_C
                STA     byte_D
                PHA
                LDA     #$FF
                PHA
                PHA
                LDA     oshwm+1
                STA     byte_39

find_program_scan_line:                         
                LDY     #0
                LDA     (byte_38),Y     ; get first char in line
                CMP     #$D             ; is it the required 13?
                BEQ     line_start_ok

bad_program:                            
                PLA
                PLA
                PLA
                INC     is_bad_program ;?is_bad_program=1
                LDA     #1             ;"Bad program"
                JSR     get_error       ; A = error code
                SEC                     ; bad program
                RTS

line_start_ok:                          
                INY
                LDA     (byte_38),Y     ; line MSB
                BPL     scan_valid_line ; if +ve, not end
; reached end, so set TOP to just past the terminating $FF
                CLC
                LDA     byte_38
                ADC     #2
                STA     TOP
                LDA     #0
                ADC     byte_39
; gone past the relevant HIMEM?
                STA     TOP+1
                CMP     HIMEM+1
                BCC     TOP_in_bounds
                BNE     force_mode_7
                LDA     HIMEM
                CMP     TOP
                BCS     TOP_in_bounds

force_mode_7:
                ; Switch to mode 135, in an attempt to get as much
                ; room as possible. Worst case, you just get Mode 7.
                
                jsr print_next_string
                .text 254
                .text 22,135
                .text 255
                
                LDX     #$ff
                JSR     get_HIMEM_for_mode_X
                
                LDA     #3        ;"No room - Mode reset"
                JSR     get_error       ; A = error code

TOP_in_bounds:                          
                                        
                PLA
                PLA
                PLA
                BEQ     find_program_good_program
                JSR     sub_8495

find_program_good_program:
                CLC
                RTS
; (seems to be maintaining its own notion of line numbering - not sure what for - it never does anything particular if it encounters a discrepancy)

scan_valid_line:                        
                LDA     byte_C
                BMI     loc_8387
                CLC
                LDA     byte_D
                ADC     #10
                STA     byte_D
                BCC     loc_8387
                INC     byte_C

loc_8387:                               
                                        
                PLA
                BMI     loc_83A0
                CMP     (byte_38),Y
                BEQ     loc_8392
                BCC     loc_83A0
                BCS     loc_839A

loc_8392:                               
                INY
                PLA
                CMP     (byte_38),Y
                BCS     loc_839B
                BCC     loc_83A1

loc_839A:                               
                PLA

loc_839B:                               
                PLA
                LDA     #1
                PHA
                PHA

loc_83A0:                               
                                        
                PLA

loc_83A1:                               
                LDY     #2

loc_83A3:                               
                LDA     (byte_38),Y
                PHA
                DEY
                BNE     loc_83A3
                LDY     #3
                LDA     (byte_38),Y     ; get line length
                BMI     next_line       ; if >=128, it's fine
                CMP     #4
                BCC     bad_program     ; if <4, bad program

next_line:                              
                CLC
                ADC     byte_38
                STA     byte_38
                BCC     scan_next_line
                INC     byte_39

scan_next_line:                         
                JMP     find_program_scan_line
; End of function find_program




initialise:                             
                JSR     init_brkv_and_oshwm
                LDX     #$ff
                JSR     get_HIMEM_for_mode_X
                LDA     #3              ; select output streams (AUG p119)
                JSR     osbyte_with_x0_y0; default output streams
                LDA     #2              ; select input stream (AUG p118)
                JSR     osbyte_with_x0_y0; keyboard on, rs423 off
                LDA     #4              ; enable/disable cursor editing (AUG p120)
                JSR     osbyte_with_x0_y0; enable cursor editing

                ; This seems a bit pointless - especially after it got
                ; in the way of some event-driven debug stuff of mine!
                ; - but maybe there's a good reason for it that I'll
                ; rediscover the hard way.
                
;                 LDA     #13             ; Disable events (AUG p129)
;                 LDX     #9
;                 STX     byte_3A

; disable_all_events_loop:                
;                 LDX     byte_3A
;                 JSR     osbyte_with_y0
; ; X=0 now
;                 DEC     byte_3A
;                 BPL     disable_all_events_loop

                
                LDA     #200            ; set ESCAPE, BREAK effect (AUG p205)
                ldx #0
                LDY     #%11111110      ; normal ESCAPE action (bit 0 reset)
                JSR     OSBYTE
                LDA     #219            ; read/write TAB key char (AUG p222)
                JSR     osbyte_with_x0_y0 ; TAB key produces CHR$0
                LDX     #27             ; ESCAPE key produces CHR$27
                LDA     #220            ; read/write Escape char (AUG p223)
                JSR     osbyte_with_y0
                
                LDA     #225            ; read/write function key status (AUG p225)
                JSR     osbyte_with_x0_y0 ; ignore key
                
                LDA     #226            ; read/write SHIFT+function key status (AUG p225)
                JSR     osbyte_with_x0_y0  ; ignore key
                
                LDA     #227            ; read/write CTRL+function key status (AUG p225)
                JSR     osbyte_with_x0_y0 ; ignore key
                
                LDA     #229            ; read/write status of ESCAPE key (AUG p227)
                JSR     osbyte_with_x0_y0 ; ESCAPE has normal action
                
                LDA     #230            ; read/write flags determining ESCAPE effects (AUG p228)
                JSR     osbyte_with_x0_y0 ; ESCAPE has normal effects

                LDA     #1
                STA     editor_mode_id  ; 1=command mode, 2=edit mode
                LDA     #0
                STA     byte_6B3
                RTS
; End of function initialise


loc_8437:
; Set cursor keys and COPY to produce ASCII                 
                LDX     #2
                LDA     #4
                JSR     OSBYTE
; Set function keys to produce ASCII $A0...$A9
                LDX     #$A0
                LDA     #225
                JSR     osbyte_with_y0
; Set SHIFT+function keys (BBC) or FUNC+A-P (Electron) to produce ASCII $B0...$B9
                LDX     #$B0
                LDA     #226
                JSR     osbyte_with_y0
; Set Ctrl+function keys (BBC) or FUNC+Q-Z+punctuation (Electron) to produce ASCII $C0...$C9
                LDX     #$C0 ; '�'
                LDA     #227
                JMP     osbyte_with_y0

brk_handler: .proc
                JSR     clear_5B1_to_600
                LDY     higher_order_address
                INY
                BNE     loc_846C
                LDY     higher_order_address+1
                INY
                BNE     loc_846C
                LDA     $FE
                CMP     #1
                BEQ     loc_846C
                CMP     #$C0
                BCC     loc_848A

loc_846C:                               
                SEI
                INC     $FD
                BNE     loc_8473
                INC     $FE

loc_8473:                               
                LDY     #0

loc_8475:                               
                LDA     ($FD),Y
                CMP     #$20 ; ' '
                BCC     loc_8483
		STA	$5B1,Y
		INY
		CPY	#$4F ; 'O'
		BCC	loc_8475

loc_8483:				
		CLI
		LDA	#-1
		STA	byte_15
		BNE	loc_848F

loc_848A:				
		LDA	#2        ;"Unknown error"
		JSR	get_error	; A = error code

loc_848F:
                jsr maybe_verbose_exit_on_error
                JMP	language_entry.command_loop

.pend
                
sub_8492:				
		JSR	find_program
; End of function sub_8492




sub_8495:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2
		BNE	loc_849F
		JSR	make_cursor_invisible

loc_849F:				
		LDX	#10
		LDA	byte_C
		BPL	loc_84A7
		LDX	#3

loc_84A7:				
		STX	byte_3A
		LDA	oshwm
		STA	unk_33
		STA	byte_27
		LDA	oshwm+1
		STA	byte_28

loc_84B3:				
		LDY	#1
		LDA	(byte_27),Y
		BPL	loc_84BC
		JMP	loc_854F

loc_84BC:				
		LDY	#3
		LDA	(byte_27),Y
		STA	unk_37
		LDA	#0
		STA	byte_38
		INY
		STY	unk_34

loc_84C9:				
		LDY	unk_34
		CLC
		TYA
		ADC	#3
		BCS	loc_84D5
		CMP	unk_37
		BCC	loc_84D8

loc_84D5:				
		JMP	loc_853F

loc_84D8:				
		LDA	byte_38
		BEQ	loc_84DF

loc_84DC:				
		JMP	loc_852E

loc_84DF:				
		LDA	(byte_27),Y
		CMP	#$8D
		BNE	loc_84DC
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		JSR	sub_85AC

loc_84EB:				
		LDY	#1
		LDA	(byte_25),Y
		BPL	loc_8505
		LDX	#4
		STX	unk_33
		LDY	unk_34
		LDA	#$40 ; '@'

loc_84F9:				
		STA	(byte_27),Y
		INY
		DEX
		BNE	loc_84F9
		DEY

loc_8500:				
		STY	unk_34
		JMP	loc_852E

loc_8505:				
		CMP	byte_21
		BNE	loc_8529
		INY
		LDA	(byte_25),Y
		CMP	byte_22
		BNE	loc_8529
		LDX	byte_35
		LDY	byte_36
		JSR	sub_85D8
		STX	byte_36
		STY	byte_35
		LDY	unk_34
		LDX	#2

loc_851F:				
		INY
		STA	(byte_27),Y
		LDA	$34,X
		DEX
		BPL	loc_851F
		BMI	loc_8500

loc_8529:				
		JSR	sub_85BF
		BNE	loc_84EB

loc_852E:				
		LDA	(byte_27),Y
		CMP	#$22 ; '"'
		BNE	loc_853A
		LDA	byte_38
		EOR	#1
		STA	byte_38

loc_853A:				
		INC	unk_34
		JMP	loc_84C9

loc_853F:				
		LDY	#3
		CLC
		LDA	(byte_27),Y
		ADC	byte_27
		STA	byte_27
		BCC	loc_854C
		INC	byte_28

loc_854C:				
		JMP	loc_84B3

loc_854F:				
		JSR	sub_85AC

loc_8552:				
		LDY	#1
		LDA	(byte_25),Y
		BMI	loc_858A
		LDX	#$11

loc_855A:				
		LDY	#2
		LDA	$40,X
		CMP	(byte_25),Y
		BNE	loc_8575
		DEX
		DEY
		LDA	$40,X
		CMP	(byte_25),Y
		BNE	loc_8576
		LDA	byte_35
		ORA	#$80 ; '�'
		STA	$40,X
		INX
		LDA	byte_36
		STA	$40,X

loc_8575:				
		DEX

loc_8576:				
		DEX
		DEX
		BPL	loc_855A
		LDY	#1
		LDA	byte_35
		STA	(byte_25),Y
		INY
		LDA	byte_36
		STA	(byte_25),Y
		JSR	sub_85BF
		BNE	loc_8552

loc_858A:				
		LDX	#$10

loc_858C:				
		LDA	$40,X
		AND	#$7F ; ''
		STA	$40,X
		DEX
		DEX
		DEX
		BPL	loc_858C
		LDA	unk_33
		BEQ	locret_85BE
		LDA	#7      ;"Target not found"

loc_859D:				
					
		LDX	unk_6AD
		BEQ	loc_85A6
		STA	unk_6AD
		RTS

loc_85A6:				
		JSR	get_error	; A = error code
		JMP	language_entry.command_loop;???
; End of function sub_8495




sub_85AC:				
		LDA	oshwm
		STA	byte_25
		LDA	oshwm+1
		STA	byte_26
		LDA	unk_6B8
		STA	byte_35
		LDA	unk_6B9
		STA	byte_36

locret_85BE:				
		RTS
; End of function sub_85AC




sub_85BF:				
		LDY	#3
		CLC
		LDA	(byte_25),Y
		ADC	byte_25
		STA	byte_25
		BCC	loc_85CC
		INC	byte_26

loc_85CC:				
		CLC
		LDA	byte_3A
		ADC	byte_36
		STA	byte_36
		BCC	locret_85D7
		INC	byte_35

locret_85D7:				
		RTS
; End of function sub_85BF




sub_85D8:				
		STX	byte_C
		STY	byte_D
		LDX	#1
		STX	byte_E

loc_85E0:				
		LDA	$C,X
		ASL
		ROL	byte_E
		ASL
		ROL	byte_E
		SEC
		ROR
		LSR
		STA	$C,X
		DEX
		BPL	loc_85E0
		LDA	byte_E
		ASL
		ASL
		EOR	#$14
		LDX	byte_D
		LDY	byte_C
		RTS
; End of function sub_85D8
; 0

error_message: .macro text
                .text \text|$80
                .endm
                
error_messages_table:
                .error_message "Bad program" ;1
                .error_message "Unknown error" ;2
                .error_message "No room - Mode reset" ;3
                .error_message "Line too long" ;4
		.error_message "No room"   ;5
                .error_message "Missing line command" ;6
                .error_message "Target not found" ;7
                .error_message "String not found" ;8
                .error_message "Bad command" ;9
                .error_message "Bad argument" ;10
                .error_message "Bad number" ;11
                .error_message "Too many arguments" ;12
                .error_message "Bad mode" ;13
                .error_message	"No room for this mode" ;14
                .error_message "No references to labels were found" ;15
                .error_message "Unresolved labels - please check" ;16
                .error_message "Line too long to be numbered" ;17
                .error_message	"Line too long to contain label" ;18
                .error_message "No labels reinstated" ;19
                .error_message "Lines too long to be joined" ;20
                .error_message "Only [NRGYBMCW] are valid" ;21
                .error_message	"Bad line number" ;22
                .error_message "Replace string missing" ;23
                .error_message "Only two strings allowed" ;24
                .error_message "Start line/Increment too big" ;25
                .error_message "Too many line commands" ;26
                .error_message "Incompatible line commands" ;27
                .error_message "Bad delete command" ;28
                .error_message "Bad destination" ;29
                .error_message "Destination missing" ;30
                .error_message "Incomplete line command" ;31
                .error_message "Argument missing" ;32
                .error_message "Tab stop must be 0-80" ;33
                .error_message "No marked line" ;34
                .error_message "No search string set up" ;35
                .error_message "Line has been truncated" ;36
                .error_message "Updates would make line too long" ;37
                .error_message "Increment must be 1-255" ;38
                .error_message "No REM>"                                 
                .byte  $FF ;
                
empty_program_string:.byte  $1F	;
		.byte	 3 ;
		.byte	 0 ;
		.byte  $31 ; 1
		.byte  $30 ; 0
nur_dlo_string:	.byte	$D 
		.byte  $4E ; N
		.byte  $55 ; U
		.byte  $52 ; R
		.byte	$D ;
		.byte  $44 ; D
		.byte  $4C ; L
		.byte  $4F ; O
six_spaces_string:.byte	 $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
		.byte  $20 ;
.byte  $20 ;
CRTC_cursor_start_values:
                .byte 7, 7, 7, 7, 7, 7,	7, $12 
CRTC_cursor_end_values_overtype:
                .byte 7, 7, 7, 9, 7, 7,	9, $13 
CRTC_cursor_end_values_insert:
                .byte 7, 7, 7, 7, 7, 7,	7, $13 
colour_chars:
                .text "NRGYBMCW"

colour_names_table: .proc
base:
                .byte black-base,red-base,green-base,yellow-base,blue-base,magenta-base,cyan-base,white-base,end-base
black:
                .text "black"
red:
                .text "red"
green:
                .text "green"
yellow:
                .text "yellow"
blue:
                .text "blue"
magenta:
                .text "magenta"
cyan:
                .text "cyan"
white:
                .text "white"
end:
                .pend

aMarkedLine:
                .text "Marked line: "
aMarkedLineEnd:
                .text "None"
aMarkedLineNoneEnd:
                
aPendingCommands:
                .text "Pending commands: "
aPendingCommandsEnd:
                .text "None"
aPendingCommandsNoneEnd:
                
aLastSearch:
                .text "Last search : "
aLastSearchEnd:
                .text "None"
aLastSearchNoneEnd:
                
TENS:=(1,10,100,1000,10000)
tensL:
                .byte <TENS
tensH:
                .byte >TENS

;-------------------------------------------------------------------------

print_on_off: .proc
                ; prints "Off" if Z set, "On" if Z clear
                beq off

                jsr print_next_string
                .text "On",255
                
                rts

off:
                jsr print_next_string
                .text "Off",255
                
                rts
                
                .pend

;-------------------------------------------------------------------------

do_command_line .proc		
		JSR	clear_5B1_to_600
		LDA	#0
		STA	readline_ptr_lsb
		LDA	#7
		STA	readline_ptr_msb
		LDA	#100
		JSR	read_line
		BCC got_command_line
                
; ESCAPE was pressed at command line

                jsr poll_shift
                beq bye
                
		LDA	is_bad_program
		BNE do_command_line_done
		JMP	enter_edit_mode

got_command_line:			
		JSR	parse_command_line
		JMP	execute_command	; unk_6BD = command to run

do_command_line_done:					
                RTS

bye:
                lda #CMD_EXIT
                sta current_command_id
                jmp run_or_exit_command
                
                
; End of function do_command_line
                .pend

;-------------------------------------------------------------------------

command: .macro text,flags,id
                .text \text,0
                .byte \flags
                .byte \id
                .endm
                
command_table:
                .command "APPEND",9,CMD_APPEND
                .command "BACK",$21,CMD_BACK
                .command "CHANGE",$15,CMD_CHANGE
                .command "END",0,CMD_END
                .command "EDIT",5,CMD_EDIT
                .command "EXIT",0,CMD_EXIT 
                .command "FIND",5,CMD_FIND
                .command "FORE",$21,CMD_FORE
                .command "GOTO",0,CMD_GOTO
                .command "HELP",0,CMD_HELP
                .command "ICHANGE",$15,CMD_ICHANGE
                .command "IE",0,CMD_IE
                .command "IFIND",5,CMD_IFIND
                .command "INFO",0,CMD_INFO
                .command "INSERT",0,CMD_INSERT
                .command "IT",0,CMD_IT
                .command "LOAD",9,CMD_LOAD
                .command "LABEL",0,CMD_LABEL
                .command "MODE",3,CMD_MODE
                .command "NEW",0,CMD_NEW
                .command "NOSCROLL",0,CMD_NOSCROLL
                .command "NUMBER",0,CMD_NUMBER
                .command "OLD",0,CMD_OLD
                .command "OVERTYPE",0,CMD_OVERTYPE
                .command "QICHANGE",$15,CMD_QICHANGE
                .command "QCHANGE",$15,CMD_QCHANGE
                .command "RUN",0,CMD_RUN
                .command "RENUMBER",$45,CMD_RENUMBER
                .command "SAVE",9,CMD_SAVE
                .command "SCROLL",0,CMD_SCROLL
                .command "TOP",0,CMD_TOP
                .command "TAB",3,CMD_TAB
                .command "ZSAVE",0,CMD_ZSAVE
                .command "ZRUN",0,CMD_ZRUN

		.byte  $FF
byte_8C95:	.byte $A		
					
byte_8C96:	.byte 9			

;-------------------------------------------------------------------------

parse_command_line:			
		LDY	#0
		STY	current_command_id
		LDA	#0
		STA	byte_C
		LDA	#7
		STA	byte_D
; Skip spaces at the start of the command line

skip_initial_spaces_loop:		
		LDA	(byte_C),Y
		CMP	#32
		BNE	found_non_space
		INC	byte_C
		BNE	loc_8CB0
		INC	byte_D

loc_8CB0:				
		BNE	skip_initial_spaces_loop

found_non_space:			
		CMP	#$D
		BEQ	done2

try_star:				; is it	looking	like a * command?
		CMP	#'*'
		BNE	try_number	; branch taken if it's not a * command
		LDA	#CMD_star	; ok, it IS a *	command

store_current_command:			
					
		STA	current_command_id

done2:					
		RTS

try_number:				
		JSR	atoi		; entry: (unk_C) points	to text;
					; exit:	C set if error,	or (byte_3E,byte_3F) holds value
		BCS	try_command	; branch taken if it doesn't look like a number
		LDY	#0

skip_number_loop:			
		LDA	(byte_C),Y	; get number char
		CMP	#13
		BEQ	is_line_number	; branch taken if end of command line
		CMP	#32
		BEQ	skip_post_number_spaces_loop ; branch taken if end of number
		INY
		BNE	skip_number_loop

skip_post_number_spaces_loop:		
					
		INY
		LDA	(byte_C),Y	; get whitespace char
		CMP	#13		; end of command line?
		BEQ	is_line_number	; branch taken if end of command line
		CMP	#32            ; just a space?
		BEQ	skip_post_number_spaces_loop ; keep going if so
; any non-space chars after the line number are invalid.
		LDA	#$16		; "Invalid line	number"
		JMP	loc_859D

is_line_number:				
					
		LDA	#CMD_goto_line
		BNE	store_current_command ;	JMP, in	effect

try_command:				
		JSR	find_first_non_alpha_char
		LDA	#<command_table
		STA	byte_E
		LDA	#>command_table
		STA	byte_F

try_this_command:			
		LDY	#0
		LDA	(byte_E),Y	; get next char	from command table
		BMI	invalid_command	; invalid, if reached end of table
		JSR	compare_cmd_char_to_input_char ; entry:	(unk_C)	points to input	char, (unk_E) points to	command	table char
					; exit:	C set if matched
		BCS	char_matched
; advance to next command in table

find_end_of_command_name_loop:		
		LDA	(byte_E),Y
		BEQ	found_end_of_command_name
		INY
		BNE	find_end_of_command_name_loop

found_end_of_command_name:		
		INY			; skip terminating 0
		INY			; skip args byte
		INY			; skip command ID
; add Y to table pointer
		CLC
		TYA
		ADC	byte_E
		STA	byte_E
		BCC	loc_8D12
		INC	byte_F

loc_8D12:				
		BNE	try_this_command ; JMP,	in effect

invalid_command:			
		LDA	#9		; "Invalid command"
		JMP	loc_859D

char_matched:				
		STY	byte_3A

find_end_of_command_name_loop_2:	
		LDA	(byte_E),Y
		BEQ	found_end_of_command_name_2
		INY
		BNE	find_end_of_command_name_loop_2

found_end_of_command_name_2:		
		INY			; skip terminating 0
		STY	byte_39		; $39 =	Y pointing into	data
		LDA	($E),Y		; get first byte of command data
		STA	byte_49		; $49 =	first byte of command data
		LDY	byte_3A
		LDA	($C),Y		; get last matched input char
		LDX	#0
		CMP	#13		; end of line there?
		BEQ	loc_8D52
		CMP	#'.'            ; abbreviated input?
		BNE	skip_spaces	; branch taken if not abbreviated
		INY			; just skip the	'.'
; Skip spaces after command

skip_spaces:				
					
		LDA	(byte_C),Y
		CMP	#32
		BNE	spaces_skipped
		INY
		BNE	skip_spaces

spaces_skipped:				
		CMP	#13		; end of command line?
		BEQ	loc_8D52
		INX			; X=1
; Set (byte_3E) to point to remainder of command line
		CLC
		TYA
		ADC	byte_C
		STA	byte_3E
		LDA	byte_D
		ADC	#0
		STA	byte_3F

loc_8D52:				
					
		TXA			; get 0	(no args entered) or 1 (args entered)
		EOR	byte_49		; Set bit 0 if state differs from command's requirements
		AND	#1		; Extract bit 0
		BEQ	loc_8D69	; Branch taken if command wants	args and some were entered/it doesn't and there weren't
		LDA	byte_49
		AND	#4		; String arg?
		BNE	loc_8D69	; branch taken if string arg wanted but	one wasn't supplied
; "Invalid argument" if an unnecessary one was specified; "Argument missing" if a necessary one wasn't.
		LDA	#$A		; "Invalid argument"
		DEX
		BEQ	loc_8D66
		LDA	#$20 ; ' '      ; "Argument missing"

loc_8D66:				
		JMP	loc_859D

loc_8D69:				
					
		TXA			; get 0	(no args entered) or 1 (args entered)
		BEQ	no_args_entered	; branch taken if no args entered
		LDA	byte_49		; get args byte
		AND	#2		; test bit 1 (single numeric arg)
		BEQ	loc_8D94	; branch taken if command wants	something else
; command wants single numeric argument
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	skip_post_number_spaces
		LDA	#$B		; "Bad number"
		JMP	loc_859D

skip_post_number_spaces:		
					
		LDA	(byte_C),Y
		CMP	#32
		BNE	skipped_post_number_spaces
		INY
		BNE	skip_post_number_spaces

skipped_post_number_spaces:		
		CMP	#13		; end of command line after the	number?
		BEQ	loc_8D94	; branch taken if so
					;
					; (This	branch is wrong, I think, as 8D94...
					; keeps	scanning from (byte_3E), even
					; though that now contains the number.
					; It wants to go to got_command	instead.)
		LDA	#$C		; "Too many arguments"
		JMP	loc_859D

no_args_entered:			
		LDA	#$FF		; mark lack of args ($FF isn't the MSB of any valid number)
		STA	byte_3F
		BNE	got_command	; JMP, in effect

loc_8D94:				
					
		LDY	#0

find_end_of_command_line_loop:		
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	found_end_of_command_line
		INY
		BNE	find_end_of_command_line_loop

found_end_of_command_line:		
		DEY

find_end_of_last_argument_loop:		
		LDA	(byte_3E),Y
		CMP	#$20 ; ' '
		BNE	found_end_of_last_argument
		DEY
		JMP	find_end_of_last_argument_loop

found_end_of_last_argument:		
		INY
		STY	byte_6BE

got_command:				
		LDY	byte_39		; get index into table (currently pointing at args byte)
		INY
		LDA	($E),Y		; get command ID
		JMP	store_current_command
; End of function parse_command_line



; Gets string representation of	16-bit number.
;
; Entry:
; Y,X =	value
;
; Exit:
; unk_0	holds digit count
; unk_1... filled with string

itoa: .proc

                stx itoa_value
                sty itoa_value+1

                ldy #4          ;tens column index
                ldx #0          ;output digit index
                lda #'0'
                sta itoa_uninteresting
input_loop:
                jsr digit

                ; get digit in this column, and skip it if not
                ; interesting.
                lda 1,x                
                cmp itoa_uninteresting 
                beq next_digit

                ; move to next output digit.
                inx

                ; effectively, make all digits interesting. 
                dec itoa_uninteresting
next_digit:
                ; next tens column.
                dey             
                bpl input_loop

                ; if 0 digits produced, it was 0, so actually 1 digit.
                txa
                bne +
                inx
+
                
                ; save output digit count.
                stx 0           
                rts

digit: .proc
                lda #'0'
                sta 1,X
output_loop:
                ; subtract current tens value, but don't store it in
                ; memory, in case there's a borrow.
                sec
                lda itoa_value+0
                sbc tensL,Y
                pha
                lda itoa_value+1
                sbc tensH,Y

                ; if borrow, done.
                bcc borrow

                ; store new value in memory.
                sta itoa_value+1
                pla
                sta itoa_value+0

                ; increment digit count and repeat.
                inc 1,X
                bne output_loop
                
borrow:
                ; discard new value and done.
                pla
                rts
                .pend

                .pend



; entry: (unk_C) points	to input char, (unk_E) points to command table char
; exit:	C set if matched

compare_cmd_char_to_input_char:		
		LDY	#0

compare_cmd_char_to_input_char_loop:					
		LDA	(byte_C),Y	; input	char
		CMP	#$41 ; 'A'
		BCC	not_alpha
		CMP	#$5B ; '['
		BCS	not_alpha
		LDA	(byte_E),Y	; command table	char
		BEQ	didnt_match	; end of command?
		LDA	(byte_C),Y	; input	char
		CMP	#$2E ; '.'      ; abbreviated?
		BNE	loc_8E35

not_alpha:				
					
		CPY	#0		; non-alpha at start?
		BEQ	didnt_match	; if so, didn't match
		SEC			; otherwise, did match (e.g., "MO6" = "MO.6" = "MODE 6")
		RTS

loc_8E35:				
		CMP	(byte_E),Y
		BNE	didnt_match
		INY
		BNE	compare_cmd_char_to_input_char_loop		; input	char

didnt_match:				
					
		CLC
		RTS
; End of function compare_cmd_char_to_input_char




find_first_non_alpha_char:		
		LDY	#0

find_first_non_alpha_char_loop:					
		LDA	($C),Y
		CMP	#$41 ; 'A'
		BCC	locret_8E6B
		CMP	#$5B ; '['
		BCC	next_char
		CMP	#$61 ; 'a'
		BCC	locret_8E6B
		CMP	#$7B ; '{'
		BCS	locret_8E6B
		EOR	#$20 ; ' '
		STA	($C),Y

next_char:				
		INY
		BNE	find_first_non_alpha_char_loop		; don't think Y is ever supposed to get to 0 again...
; End of function find_first_non_alpha_char




toggle_case:				
		CMP	#$41 ; 'A'
		BCC	locret_8E6B
		CMP	#$5B ; '['
		BCC	loc_8E69
		CMP	#$61 ; 'a'
		BCC	locret_8E6B
		CMP	#$7B ; '{'
		BCS	locret_8E6B

loc_8E69:				
		EOR	#$20 ; ' '

locret_8E6B:				
					
		RTS
; End of function toggle_case



; Set memory to	value.
;
; ($C) points to memory	to clear.
; X holds number of pages to clear.
; Y holds number of bytes to clear in Xth page.
; A holds value	to write.

memset: .proc
					
		STA	byte_3A
		TYA
		PHA			; save old Y
		LDA	byte_3A
		LDY	#0
		CPX	#0
		BEQ	fill_last_page

fill_pages_loop:			
		STA	($C),Y		; write	byte
		INY			; next byte...
		BNE	fill_pages_loop	; do a whole page
		INC	byte_D		; next page
		DEX			; done all pages?
		BNE	fill_pages_loop	; taken	if not all pages done yet

fill_last_page:				
		TAY			; Y = value to store
		PLA			; get original Y back
		BEQ	memset_done		; if 0 bytes to	fill in	last page, done
		TAX			; X = #	bytes to fill in last page
		TYA			; A = value to store
		LDY	#0

fill_last_page_loop:			
		STA	($C),Y		; write	byte
		INY			; next byte...
		DEX			; done all bytes?
		BNE	fill_last_page_loop ; taken if not all bytes done yet

memset_done:					
                RTS
                .pend



osbyte_with_x0_y0:.proc
                ldx #0
                ; fall through
.pend
                
osbyte_with_y0:.proc
					
		LDY	#0
		JSR	OSBYTE
                RTS
.pend
; End of function osbyte_with_y0



; print_itoa_result.
;
; Suitable for use with	the result of itoa.
;
; Entry:
; unk_0	= digit	count
; unk_1... = digits

; print_itoa_result: .proc
					

;                 .pend

;-------------------------------------------------------------------------
; move (maybe overlapping) memory regions.
;
; Entry:
; (byte_C) points to src
; (byte_E) points to dest
; X is MSB of size
; Y is LSB of size


memmove_8bit:
                .if ENABLE_DEBUG
                cpx #0
                beq memmove

                ; This is fine, sort of, in that it will copy the
                ; right number of bytes. But it wants noting, because
                ; obviously I've got something wrong...
                stx debug_flag
                
                .endif
                
memmove: .block
                .if ENABLE_DEBUG
                
                jsr inc_debug_counter

                pla
                sta debug_ptr+1
                pla
                sta debug_ptr+0
                pha
                lda debug_ptr+1
                pha
                
                .endif
                
		LDA	byte_D		; get src MSB
		CMP	byte_F		; compare to dest MSB
		BCC	copy_down	; taken	if src<dest
		BEQ	copying_same_page ; taken if src MSB==dest MSB

copy_up:				
		TYA
		PHA			; save original	Y
		LDY	#0
		CPX	#0		; Any whole pages?
		BEQ	copy_up_last_page ; branch taken if no whole pages to copy

copy_up_pages_loop:			
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		INY
		BNE	copy_up_pages_loop ; branch taken if not copied	whole page yet
		INC	byte_D		; next src page
		INC	byte_F		; next dest page
		DEX			; one more page	done
		BNE	copy_up_pages_loop ; branch taken if not done all pages	yet

copy_up_last_page:			
		PLA
		TAX			; get original Y in X
		BNE	copy_up_last_page_loop ; branch	taken if any bytes to copy in last page
		RTS

copy_up_last_page_loop:			
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		INY
		DEX			; one more byte	done
		BNE	copy_up_last_page_loop ; branch	taken if not done all bytes yet
		RTS

copying_same_page:			
		LDA	byte_C		; get src LSB
		CMP	byte_E		; compare to dest LSB
		BCS	copy_up		; branch taken if src>=dest

copy_down:				
		TXA			; get page count
; Point src and dest at last page of each
		CLC
		ADC	byte_D
		STA	byte_D
		TXA
		CLC
		ADC	byte_F
		STA	byte_F
		CPY	#0		; any bytes to copy at the end?
		BEQ	copy_down_pages	; branch taken if no bytes to copy at the end

copy_down_last_page_loop:		
		DEY
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		CPY	#0		; was that the last byte just copied?
		BNE	copy_down_last_page_loop ; branch taken	if not on last byte

copy_down_pages:			
		CPX	#0		; any pages to copy?
		BEQ	memmove_done		; branch taken if no pages to copy

copy_down_pages_loop:			
		DEC	byte_D		; point	to last	whole page in src
		DEC	byte_F		; point	to last	whole page in dest

copy_down_page_loop:			
		DEY
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		CPY	#0		; was that the last byte just copied?
		BNE	copy_down_page_loop ; branch taken if not on last byte
		DEX			; one more page	done
		BNE	copy_down_pages_loop ; branch taken if more pages to copy

memmove_done:					
		RTS
                .bend

;-------------------------------------------------------------------------

gotoxy .proc					
					
		LDA	#31		; set cursor location
		JSR	OSWRCH
		TXA
		JSR	OSWRCH
		TYA
		JMP	OSWRCH
; End of function gotoxy



.pend

prepare_for_print_1_char: .proc
                jsr get_current_mode_in_x
                txa
                and #7
                cmp #7
                ror a
                sta print_1_char_teletext
                rts
                .pend

; print char in A.
print_1_char: .proc
                sta print_1_char_a
                sty print_1_char_y

                lda editor_mode_id
                beq done

                ldy #0
                cmp #1
                beq start
                ldy #' '
                
start:
                sty byte_3A

                lda print_1_char_a
                cmp #$7f
                beq print_space

                bit print_1_char_teletext
                bpl not_teletext

teletext:
                lda print_1_char_a
                cmp #141
                beq print_space

not_teletext:
                lda print_1_char_a
                cmp byte_3A
                bcs print_char

print_space:
                lda #' '

print_char:
                jsr oswrch
                
done:
                ldy print_1_char_y
                lda print_1_char_a
                rts
                
.pend

incz: .proc
                inc 0,x
                bne done
                inc 1,x
done:
                rts
.pend

print_next_string: .proc
                jsr prepare_for_print_1_char

                pla
                sta byte_C
                pla
                sta byte_D
                
                ldy #0
                ldx #byte_C
                jsr incz

                lda editor_mode_id
                pha

                ; If the first byte of the string is 254, temporarily
                ; replace editor_mode_id with 1,
                ; allowing printing of control chars.
                lda (0,x)
                cmp #254
                bne +

                lda #1
                sta editor_mode_id
                
                jsr incz
+
                
loop:
                lda (byte_C),Y
                jsr incz
                cmp #255
                beq done
                jsr print_1_char
                jmp loop

done:
                pla
                sta editor_mode_id
                
                jmp (byte_C)
                .pend

print_5_spaces: .proc                               
                                        
                LDA     #5

                ; fall through
.pend

print_n_spaces: .proc
					
                LDX     #<six_spaces_string
                LDY     #>six_spaces_string

                ; fall through
.pend

print_n_chars: .proc
                pha
                stx byte_C
                sty byte_D
                jsr prepare_for_print_1_char
                pla
                pha
                tax
                beq done


                ldy #0
loop:
                lda (byte_C),Y
                jsr print_1_char
                iny
                dex
                bne loop
done:
                pla
                rts
.pend


;-------------------------------------------------------------------------

; work out dimensions of line.
;
; Entry:
; X=line length
; Y=starting Y
;
; Exit:
; X=line length	MOD screen width
; Y=ending Y
get_line_dimensions .proc
					
		LDA	byte_39
		PHA
		LDA	byte_3A
		PHA
		STX	byte_39
		STY	byte_3A
		LDY	#0

loc_8F5A:				
		LDA	byte_3A		; get Y
		BNE	loc_8F65	; taken	if Y not zero
		LDA	byte_39		; get X
		CMP	code_area_width	; reached effective screen width?
		BCC	loc_8F74	; taken	if effective screen width not yet reached.

loc_8F65:				
		SEC
		LDA	byte_39		; get X
		SBC	code_area_width	; subtract effective screen width
		STA	byte_39		; save X
		BCS	loc_8F71	; taken	if no borrow
		DEC	byte_3A		; borrow occurred, so decrement	Y

loc_8F71:				
		INY
		BNE	loc_8F5A

loc_8F74:				
		LDX	byte_39
		PLA
		STA	byte_3A
		PLA
		STA	byte_39
                RTS
                .pend

;-------------------------------------------------------------------------


; entry: (byte_3E) points to command line;
;
; exit: C set if error, or (byte_3E,byte_3F) holds result and Y is
; index of terminating char.

atoi_from_command_line:	.proc		
					
		LDA	byte_3E
		STA	byte_C
		LDA	byte_3F
                STA	byte_D

                ; fall through
                .pend


; entry: (unk_C) points	to text;
; exit:	C set if error,	or (byte_3E,byte_3F) holds value

atoi: .proc
                ldy #0
                sty byte_3E
                sty byte_3F

                ; keep going until terminator, non-digit, or too many
                ; digits.
count_digits_loop:
                lda (byte_C),Y
                cmp #' '
                beq got_digits  ;taken if space
                cmp #13
                beq got_digits  ;taken if CR
                cmp #'0'
                bcc atoi_error  ;taken if not digit
                cmp #'9'+1
                bcs atoi_error  ;taken if not digit
                iny
                cpy #6
                bcc count_digits_loop
atoi_error:
                sec
                rts

got_digits:
                cpy #0
                beq atoi_error

                sty atoi_y      ;index of terminating char

                ldx #0          ;tens column counter
                dey             ;string offset

columns_loop:
                
                lda (byte_C),Y  ;get digit

add_column_loop:
                cmp #'0'        
                beq column_done
                
                pha

                clc
                lda byte_3E
                adc tensL,X
                sta byte_3E
                lda byte_3F
                adc tensH,X
                sta byte_3F

                asl a
                pla
                bcs atoi_error  ;taken if >32767

                ; C is clear here. Branch with BNE is OK; the
                ; accumulator holds an ASCII value so it'll never end
                ; up zero.
                sbc #0          
                bne add_column_loop
column_done:
                inx             ;next tens column
                dey
                bpl columns_loop
atoi_done:
                ldy atoi_y
                clc
		RTS
                .pend


; unk_6BD = command to run

execute_command:			
					
		LDA	#<command_jump_table
		STA	byte_39
		LDA	#>command_jump_table
		STA	byte_3A

loc_8FEF:				
		LDY	#0
		LDA	(byte_39),Y	; get control byte
		STA	byte_49		; ?unk_49 = control byte
		CMP	#$FF		; end of table?
		BNE	loc_8FFA	; branch taken if not end of table

execute_command_done:					
		RTS

loc_8FFA:				
		INY
		LDA	(byte_39),Y		; get command ID
		CMP	current_command_id ; is	it the desired command?
		BEQ	loc_9005	; branch taken if desired command found
		JMP	next_command
; Create thunk at unk_6B0: JMP <command routine>

loc_9005:				
		LDA	#$4C		; JMP absolute
		STA	unk_6B0
		STA	byte_6A7
		INY
		LDA	(byte_39),Y		; get command routine ptr LSB
		STA	unk_6B1		; store	JMP target LSB
		INY
		LDA	(byte_39),Y		; get command routine ptr MSB
		STA	unk_6B2		; store	JMP target MSB
		LDA	byte_49		; get control byte
		AND	#1		; extract bit 0
		STA	byte_6AB	; ?unk_6AB = unknown byte bit 1

check_bit_1:				; get control byte
		LDA	byte_49
		AND	#2		; extract bit 1
		BNE	check_bit_2	; branch taken if bit 1	reset
; bit 1 set
		LDA	is_bad_program
		BNE	execute_command_done

check_bit_2:				
		LDA	byte_49		; get control byte
		AND	#4		; extract bit 2
		BEQ	check_bit_3	; branch taken if bit 2	reset
; bit 2 set
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2		; edit mode?
		BEQ	check_bit_3	; branch taken if edit mode
; not in edit mode
		JSR	init_edit_mode
		LDA	byte_49		; get control byte
		AND	#$10		; extract bit 4
		BEQ	check_bit_6	; branch taken if bit 4	reset
; bit 4 set
		JSR	is_program_empty ; sets	C if no	program
		BCC	check_bit_6	; branch taken if program is present
		JMP	loc_9DA8

check_bit_3:				
					
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2		; edit mode?
		BNE	check_bit_6     ;taken if command mode
		LDA	byte_49         ;get control byte
		AND	#8              ;test bit 3
		BEQ	check_bit_4     ;taken if bit 3 reset
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCS	check_bit_4
		JSR	sub_A8C0

check_bit_4:				
					
		LDA	byte_49
		AND	#$10
		BEQ	check_bit_5
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	check_bit_5
		JMP	loc_9DA8

check_bit_5:				
					
		LDA	byte_49
		AND	#$20 ; ' '
		BEQ	check_bit_6
		STA	byte_6B3
		JSR	sub_A8C0

check_bit_6:				
					
		LDA	byte_49
		AND	#$40 ; '@'
		EOR	#$40 ; '@'
		STA	byte_6A7
		JMP	unk_6B0

next_command:				
		CLC
		LDA	byte_39		; ptr LSB
		ADC	#4		; add 4	(size of each entry)
		STA	byte_39
		BCC	command_ptr_ok
		INC	byte_3A

command_ptr_ok:				
		JMP	loc_8FEF
; End of function execute_command




clear_5B1_to_600: .proc

		LDA	#0
		STA	byte_15
                
                .if KEEP_CLEAR_5B1_TO_600_MEMSET
		LDA	#<unk_5B1
		STA	byte_C
		LDA	#>unk_5B1
		STA	byte_D
		LDX	#0
		LDY	#$4F
		LDA	#$20
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.
		.else
                ldx #$4e
                lda #0
loop:
                sta unk_5b1,x
                dex
                bpl loop
                .endif
                
                rts
                
                .pend
; End of function clear_5B1_to_600



; A = error code

get_error:				
					
		PHA
		LDA	byte_15		; already got an error?
		BEQ	copy_error	; taken	if no error yet
		PLA
		RTS

copy_error:				
		JSR	clear_5B1_to_600
		PLA
		STA	byte_15		; store	error code
		LDA	#<error_messages_table
		STA	byte_C
		LDA	#>error_messages_table
		STA	byte_D
		LDY	#0		; offset into errors table
		LDX	#0		; current error	index

find_error_loop:			
					
		LDA	($C),Y		; next byte from table
		BPL	loc_90C5	; taken	if still looking at the	current	error
; hit a negative char, so this means it's looking at the next error, so bump the error index.
		INX

loc_90C5:				
		CPX	byte_15		; reached the desired error?
		BEQ	found_error	; taken	if desired error reached
		INC	byte_C
		BNE	find_error_loop
		INC	byte_D
		BNE	find_error_loop

found_error:				
		LDX	#0

copy_error_loop:			
		AND	#$7F		; mask out top bit (in case)
		STA	unk_5B1,X	; store	in error message buffer
		INY			; next source byte...
		INX			; next dest byte...
		LDA	($C),Y		; load next byte from error table
                BPL	copy_error_loop	; taken	if haven't ended up in the next error
                jsr maybe_verbose_exit_on_error
		RTS
; End of function get_error

ifind_command:
                lda #$80        ;case-insensitive
                bne find_or_ifind_command
find_command:
                lda #$00        ;case-sensitive
                ; fall through
find_or_ifind_command:
                sta case_insensitive_search        
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	byte_50
		PHA
		LDA	byte_51
		PHA
		LDX	byte_3F		; get MSB of pointer to	arg
		INX			; X=0 if it was	FF before
		BNE	got_search_string ; branch taken if pointer to arg appears valid
		JSR	get_search_string ; gets search	string.
					;
					; Exit:
					; (byte_3E) points to result
					; byte_6BE is length of	input excluding	final CR.
					; C set	if nothing entered.
		BCS	loc_912C

got_search_string:			
		LDY	byte_6BE
		STY	search_string_length

copy_search_string_loop:		
		DEY
		LDA	(byte_3E),Y
		STA	unk_643,Y
		CPY	#0
		BNE	copy_search_string_loop
		LDA	#0
		STA	byte_6AF
; point (byte_2B) at OSHWM
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_910F:				
		LDA	#0
		STA	byte_3B		; reset	"found anything" flag

loc_9113:				
		LDY	#1		; index	of MSB of line number
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	(byte_2B),Y	; fetch	MSB of line number
		BPL	line_valid	; branch taken if line appears valid
; reached end of program
		LDA	byte_3B		; was anything found?
		BEQ	loc_9122	; branch taken if nothing was found
		JMP	loc_91A6

loc_9122:				
		LDA	byte_6AF
		BNE	loc_912C
		LDA	#8		; "String not found"
		JSR	get_error	; A = error code

loc_912C:				
					
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JMP	language_entry.command_loop

line_valid:				
		JSR	detokenize_one_line
		JSR	sub_9260
		BCC	loc_91A0
		LDY	byte_6AF
		BNE	loc_918A
		INY
		STY	byte_6AF
		JSR	init_edit_mode
		LDA	current_command_id
                CMP	#CMD_EDIT ;was this EDIT?
                BNE	loc_918A  ;taken if not EDIT (i.e., FIND)
                
loc_9163:
                ; command was EDIT.
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	cls_and_reset_6c0_to_6ff
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	sub_A069
		JSR	position_edit_mode_cursor
		JMP	edit_mode_loop

loc_918A:				

                ; command was FIND.
		LDA	byte_3B
		BNE	loc_9191
		JSR	cls_and_reset_6c0_to_6ff

loc_9191:				
		JSR	sub_9E5F
		BCC	loc_91A6
		JSR	sub_9E82
		CLC
		LDA	byte_3B
		ADC	byte_2D
		STA	byte_3B

loc_91A0:				
		JSR	advance_2b_to_next_line
		JMP	loc_9113

loc_91A6:				
					
		LDA	#0
		STA	byte_3B

loc_91AA:				
					
		LDX	#0
		LDY	byte_3B
		JSR	gotoxy
                JSR	find_mode_getch

		CMP	#$1B
		BNE	loc_91BB
		JMP	loc_912C

loc_91BB:				
		CMP	#$A7 ; -$59 ;	'�'
                beq edit_found_line
                cmp #13
                bne loc_91C5
edit_found_line:
		JSR	sub_9247
		JMP	loc_9DA8

loc_91C5:				
		CMP	#$AF ; -$51 ;	'�'
		BNE	loc_91E3
		LDA	byte_3B
		BNE	loc_91DE
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		TXA
		LSR
		STA	byte_3B
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_91DE:				
		DEC	byte_3B
		JMP	loc_91AA

loc_91E3:				
		CMP	#$AE
		BNE	loc_9203
		LDX	byte_3B
		INX
		CPX	screen_height
		BEQ	loc_91F5
		BCC	loc_91F5
		LDX	#0
		BEQ	loc_91FE

loc_91F5:				
					
		TXA
		ASL
		TAY
		LDA	$6C1,Y
		BNE	loc_91FE
		TAX

loc_91FE:				
					
		STX	byte_3B

loc_9200:				
		JMP	loc_91AA

loc_9203:				
		CMP	#$A5
		BNE	loc_920A
		JMP	loc_910F

loc_920A:				
		CMP	#$A2
		BNE	loc_9211
		JMP	top_edit_mode_command

loc_9211:				
		CMP	#$A3
		BNE	loc_9218
		JMP	end_edit_mode_command

loc_9218:				
		CMP	#$C1
		BNE	loc_922E
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	goto_edit_mode_command
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JMP	loc_91AA

loc_922E:				
		CMP	#$C0
		BNE	loc_9200
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_9247
		JSR	mark_edit_mode_command
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JMP	loc_91AA
; End of function find_command




sub_9247:				
					
		LDA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JMP	save_line_number ; saves line number from program.
; End of function sub_9247		;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number



advance_2b_to_next_line:		
					
		LDY	#3		; offset of line length
		CLC
		LDA	(byte_2B),Y		; get line length
		ADC	byte_2B
		STA	byte_2B
		BCC	advance_2b_to_next_line_done
		INC	byte_2C

advance_2b_to_next_line_done:					
		RTS
                ; End of function advance_2b_to_next_line
                
normalize_search_case .proc
                bit case_insensitive_search
                bpl done
                cmp #'a'
                bcc done
                cmp #1+'z'
                bcs done
                and #$df
done:
                rts
.pend
sub_9260 .proc			
					
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_926B
		BCC	loc_926B

loc_9269:				
		CLC

locret_926A:				
		RTS

loc_926B:				
		CLC
		ADC	byte_6BE
		BCC	loc_9275
		CMP	#$26 ; '&'
		BCS	loc_9269

loc_9275:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CLC
		ADC	#<byte_400
		STA	byte_C
                LDA	#0
                tax
                tay
		ADC	#>byte_400
		STA	byte_D

loc_9286:
                lda (byte_C,X)
                jsr normalize_search_case
                sta search_tmp

                lda (byte_3E),Y
                jsr normalize_search_case
                cmp search_tmp
                BNE	loc_929A
next_byte:
		INY
		INC	byte_C
		BNE	loc_9293
		INC	byte_D

loc_9293:				
		CPY	byte_6BE
		BCS	locret_926A
		BCC	loc_9286

loc_929A:				
		INC	cursor_offset	; offset of cursor in detokenized buffer
                BNE	sub_9260
.pend

qichange_or_ichange_command:
                lda #$80        ;case-insensitive
                bne change_or_qchange_or_ichange_or_qichange_command
                
change_or_qchange_command:
                lda #$00        ;case-sensitive
                ; fall through
change_or_qchange_or_ichange_or_qichange_command .block
                sta case_insensitive_search
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	byte_50
		PHA
		LDA	byte_51
		PHA
		LDX	byte_3F
		INX
		BEQ	loc_9308
		LDY	#0

loc_92B1:				
		LDA	(byte_3E),Y
		CMP	#$20 ; ' '
		BEQ	loc_92C3
		CMP	#$D
		BEQ	loc_92BE
		INY
		BNE	loc_92B1

loc_92BE:				
		LDA	#$17

loc_92C0:				
		JMP	loc_859D

loc_92C3:				
		STY	byte_6BE

loc_92C6:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_92BE
		CMP	#$20 ; ' '
		BNE	loc_92D3
		INY
		BNE	loc_92C6

loc_92D3:				
		CLC
		TYA
		ADC	byte_3E
		STA	unk_6BA
		LDA	byte_3F
		ADC	#0
		STA	unk_6BB
		LDX	#0

loc_92E3:				
		LDA	(byte_3E),Y
		CMP	#$20 ; ' '
		BEQ	loc_92F1
		CMP	#$D
		BEQ	loc_9302
		INX
		INY
		BNE	loc_92E3

loc_92F1:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_9302
		CMP	#$20 ; ' '
		BNE	loc_92FE
		INY
		BNE	loc_92F1

loc_92FE:				
		LDA	#$18
		BNE	loc_92C0

loc_9302:				
		STX	unk_6BC
		JMP	loc_932C

loc_9308:				
		JSR	get_search_string ; gets search	string.
					;
					; Exit:
					; (byte_3E) points to result
					; byte_6BE is length of	input excluding	final CR.
					; C set	if nothing entered.
		BCS	loc_9312
		JSR	get_replace_string
		BCC	loc_932C

loc_9312:				
					
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		RTS

loc_932C:				
		LDA	#0
		STA	byte_6AF
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9337:				
		LDY	#0
		STY	byte_6B3
		STY	cursor_offset_msb
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	(byte_2B),Y
		BMI	loc_9369
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line

loc_934B:				
					
		JSR	sub_9260
		BCS	loc_9359
		JSR	sub_93CF
		JSR	advance_2b_to_next_line
		JMP	loc_9337

loc_9359:				
		LDA	current_command_id
		STA	byte_6AF
		CMP	#CMD_QCHANGE
		BEQ	loc_937E ;taken if command was QCHANGE
                cmp #CMD_QICHANGE
                beq loc_937e    ;taken if command was QICHANGE
		JSR	sub_BDD3
		JMP	loc_934B

loc_9369:				
		LDA	byte_6AF
		BNE	loc_9312
		PLA
		PLA
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		LDA	#8        ;"String not found"
		JSR	get_error	; A = error code

loc_937B:				
		JMP	language_entry.command_loop
                
loc_937E:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2
		BEQ	loc_9388
		JSR	init_edit_mode

loc_9388:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	sub_A069
		JSR	position_edit_mode_cursor

loc_93A9:				
		JSR	find_mode_getch
		CMP	#$1B
		BEQ	loc_937B
		CMP	#$A7
		BNE	loc_93B7
		JMP	edit_mode_loop

loc_93B7:				
		AND	#$DF
		CMP	#'Y'
		BNE	loc_93C6
		JSR	sub_BDD3
		JSR	sub_93CF
		JMP	loc_934B

loc_93C6:				
		CMP	#'N'
		BNE	loc_93A9
		INC	cursor_offset	; offset of cursor in detokenized buffer
		JMP	loc_934B
; End of function sub_9260




sub_93CF:				
					
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_A8C0
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
                RTS
.bend
; End of function sub_93CF




load_command .proc				
		LDA	#$FF
		JSR	do_osfile_from_oshwm
		JSR	clear_line_commands
                JSR	sub_B358
                jmp sub_8314
.pend
                
append_command .proc
		JSR	is_program_empty ; sets	C if no	program
		BCS	load_command
		JSR	loc_946F
		LDA	#$FF
		JSR	do_osfile
		JSR	find_program
		BCC	locret_9424
		JSR	loc_946F
		STX	byte_C
		STY	byte_D
		LDY	#0
		LDA	#$D
		STA	($C),Y
		INY
		LDA	#$FF
		STA	($C),Y

locret_9424:				
                RTS
.pend

save_command
		LDA	TOP
		STA	byte_27		; save end address LSB
		LDA	TOP+1
		STA	byte_28		; save end address MSB
		LDA	#0		; OSFILE save memory block

do_osfile_from_oshwm:				
		LDX	oshwm
		LDY	oshwm+1
                jmp	do_osfile

do_osfile .proc
		PHA			; save OSFILE code
		LDA	byte_3E
		STA	readline_ptr_lsb ; filename ptr	LSB
		LDA	byte_3F
		STA	readline_ptr_msb ; filename ptr	MSB
		STX	unk_1B		; load address LSB
		STX	unk_1F		; exec address LSB
		STX	byte_23		; save start address LSB
		STY	unk_1C		; load address MSB
		STY	byte_20		; exec address MSB
		STY	byte_24		; save start address MSB
		LDA	higher_order_address
		STA	unk_1D		; load address bits 16...23
		STA	byte_21		; exec address bits 16...23
		STA	byte_25		; save start address bits 16...23
		STA	unk_29		; save end address bits	16...23
		LDA	higher_order_address+1
		STA	unk_1E		; load address bits 24...31
		STA	byte_22		; exec address bits 24...31
		STA	byte_26		; save start address bits 24...31
		STA	unk_2A		; save end address bits	24...31
		PLA			; get OSFILE code
		TAX			; OSFILE code in X
		INX			; 1 if load, 0 if save
		BNE call_osfile	; branch if not	save
		STX	unk_1F		; when loading - use load address provided, not	file's default

call_osfile				
		LDX	#$19
		LDY	#0
                JMP	OSFILE		; OSFILE
.pend
; End of function save_command


loc_946F .proc
		LDY	TOP+1
		SEC
		LDA	TOP
		SBC	#2
		TAX
		BCS	locret_947A
		DEY

locret_947A:				
                RTS
.pend

; entry: (byte_19) points to buffer
;
; exit:	C=0 if Return, C=1 if Escape
; A is line length+1

read_line .proc
					
		STA	unk_1B		; maximum line length
		LDA	#$20
		STA	unk_1C		; min acceptable char
		LDA	#$FF
		STA	unk_1D		; max acceptable char
		LDA	#0		; read input line
		LDX	#$19
		LDY	#0
		JSR	OSWORD
		PHP
		INY
		TYA
		PHA
		BCC	loc_9497
		JSR	OSNEWL

loc_9497:				
		JSR	clear_escape_condition
		PLA
		PLP
                RTS
.pend
; End of function read_line



; read <100 chars to $700; points (byte_3E) at result, sets byte_6BE to	length.

read_line_700:				
		LDA	#0
		STA	readline_ptr_lsb
		STA	byte_3E
		LDA	#7
		STA	readline_ptr_msb
		STA	byte_3F
		LDA	#$64 ; 'd'
		JSR	read_line
		STA	byte_6BE
		RTS
; End of function read_line_700




read_line_780:				
		LDA	#$80
		STA	readline_ptr_lsb
		STA	unk_6BA
		LDA	#7
		STA	readline_ptr_msb
		STA	unk_6BB
		LDA	#$64
		JSR	read_line
		STA	unk_6BC
		RTS
; End of function read_line_780



; gets search string.
;
; Exit:
; (byte_3E) points to result
; byte_6BE is length of	input excluding	final CR.
; C set	if nothing entered.

get_search_string:			

                jsr print_next_string
                .text "  Search string  : ",255
		JSR	read_line_700	; read <100 chars to $700; points (byte_3E) at result, sets byte_6BE to	length.
		BCS	locret_94DD
		DEC	byte_6BE	; ignore 13
		BNE	locret_94DD
		SEC			; set carry if empty

locret_94DD:				
					
		RTS
; End of function get_search_string




get_replace_string:
                jsr print_next_string
                .text "  Replace string : ",255
		JSR	read_line_780
		DEC	unk_6BC		; ignore 13
		RTS
; End of function get_replace_string




reset_keys_settings:			
					
		LDX	#0		; Enable cursor	editing	(default)
		LDA	#4		; Enable/disable cursor	editing	(AUG P120)
		JSR	OSBYTE
		LDX	#9
		LDA	#219		; set TAB key to 9
		JSR	osbyte_with_y0
		JSR	kbflush
		LDX	#1
		LDA	#225		; reset	F key status?
		JSR	osbyte_with_y0
.if !ELECTRON
		LDX	#128
		LDA	#226		; reset	Shift+F	key status?
		JSR	osbyte_with_y0
		LDA	#227
		JMP	osbyte_with_x0_y0
.else
		LDX #1
		LDA #226		; reset FUNC+A-P
		JSR osbyte_with_y0
		LDX #1
		LDA #227		; reset FUNC+Q-Z+punctuation
		JMP osbyte_with_y0
.endif
; End of function reset_keys_settings




run_star_command:			
		LDX	#7
		JSR	get_HIMEM_for_mode_X
		JSR	reset_keys_settings
		LDX	#0
		LDY	#7
		JSR	OSCLI
		JMP	clear_5B1_to_600
; End of function run_star_command




getch:					
					
		JSR	OSRDCH
; End of function getch




clear_escape_condition:			
		PHA
		LDA	#$7E ; '~'
		JSR	OSBYTE
		PLA
; End of function clear_escape_condition

		RTS

;-------------------------------------------------------------------------

escape_key_command: .proc
                jsr poll_shift
                bne language_entry.command_loop
                jmp do_command_line.bye
                .pend
                
;-------------------------------------------------------------------------
;
; command flag masks: (a work in progress...)
;
; $04 - enter edit mode
; $08 - if in edit mode, tokenize line before executing
; $10 - program must be non-empty

command_jump: .macro flags,id,addr
                .byte \flags
                .byte \id
                .word \addr
                .endm
                
command_jump_table:
                .command_jump $20,CMD_return_key,return_key_command
                .command_jump $24,CMD_IE,ie_cmd
                .command_jump $24,CMD_IT,it_cmd
                .command_jump 8,$1B,escape_key_command
                .command_jump 0,CMD_TOGGLE_INS_OVER,toggle_insert_overtype_command
                .command_jump $19,CMD_TOP_KEY,top_edit_mode_command
                .command_jump $19,CMD_END_KEY,end_edit_mode_command
                .command_jump $19,CMD_RENUMBER_KEY,renumber_edit_mode_command
                .command_jump $A,CMD_EXIT,run_or_exit_command
                .command_jump 2,CMD_NEW,new_command
                .command_jump 1,CMD_OLD,old_command
                .command_jump 0,CMD_UNDO,undo_edit_mode_command
                .command_jump 0,CMD_EXTEND_STMNT,extend_statement_edit_mode_command
                .command_jump 0,CMD_SWAP_CASE,swap_case_edit_mode_command
                .command_jump $19,CMD_TOP_SCREEN,top_of_screen_edit_mode_command
                .command_jump 0,CMD_EXECUTE,execute_edit_mode_command
                .command_jump 0,CMD_BACK_KEY,background_edit_mode_command
                .command_jump 0,CMD_FORE_KEY,foreground_edit_mode_command
                .command_jump 0,CMD_DELETE_EOL,delete_to_end_of_line_edit_mode_command
                .command_jump 1,CMD_delete_key,delete_key_command
                .command_jump 1,CMD_shift_delete_key,loc_AAC8
                .command_jump 1,CMD_DELETE_FWDS,loc_AAC8
                .command_jump 0,CMD_LEFT,cursor_left_edit_mode_command
                .command_jump 0,CMD_RIGHT,cursor_right_edit_mode_command
                .command_jump 0,CMD_DOWN,cursor_down_edit_mode_command
                .command_jump 0,CMD_UP,cursor_up_edit_mode_command
                .command_jump 0,CMD_LINE_START,shift_cursor_left_edit_mode_command
                .command_jump 0,CMD_LINE_END,shift_cursor_right_edit_mode_command
                .command_jump $18,CMD_SCREEN_DOWN,shift_cursor_down_edit_mode_command
                .command_jump $18,CMD_SCREEN_UP,shift_cursor_up_edit_mode_command
                .command_jump 0,CMD_PREV_STMNT,move_to_prev_stmt_edit_mode_command
                .command_jump 0,CMD_NEXT_STMNT,move_to_next_stmt_edit_mode_command
                .if ORIGINAL_CTRL_UP_DOWN
                .command_jump $10,CMD_SCREEN_BOTTOM,move_to_bottom_of_screen_edit_mode_command
                .command_jump $10,CMD_SCREEN_TOP,move_to_top_of_screen_edit_mode_command
                .else
                .command_jump $10,CMD_LINE_NEXT,move_to_next_line_edit_mode_command
                .command_jump $10,CMD_LINE_PREV,move_to_prev_line_edit_mode_command
                .endif
                .command_jump 2,CMD_LOAD,load_command
                .command_jump 0,CMD_APPEND,append_command
                .command_jump 0,CMD_SAVE,save_command
                .command_jump 0,CMD_FIND,find_command
                .command_jump $40,CMD_CHANGE,change_or_qchange_command
                .command_jump $40,CMD_QCHANGE,change_or_qchange_command
                .command_jump 2,CMD_star,run_star_command
                .command_jump 0,3,set_primary_line_command
                .command_jump 0,4,set_primary_line_command
                .command_jump 0,$D,set_primary_line_command
                .command_jump 1,1,loc_A245
                .command_jump 1,2,loc_A245
                .command_jump 1,5,loc_A245
                .command_jump 1,$14,loc_A245
                .command_jump 1,$12,loc_A258
                .command_jump 0,$63,loc_AD39
                .command_jump 0,$64,loc_AEB9
                .command_jump 0,$6D,loc_AD39
                .command_jump 0,CMD_DELETE_FWDS,copy_key_edit_mode_command
                .command_jump 0,CMD_tab_key,tab_key_command
                .command_jump 0,CMD_RUN,run_or_exit_command
                .command_jump 0,CMD_MODE,mode_command
                .command_jump 0,CMD_MARK,mark_edit_mode_command
                .command_jump $1D,CMD_GOTO_KEY,goto_edit_mode_command
                .command_jump $40,CMD_NUMBER,number_command
                .command_jump $40,CMD_LABEL,label_command
                .command_jump 0,CMD_SPLIT_STMNT,split_statement_edit_mode_command
                .command_jump 1,CMD_JOIN_STMNT,join_statements_edit_mode_command
                .command_jump $21,CMD_REPEAT,repeat_edit_mode_command
                .command_jump 0,CMD_SCROLL,scroll_command
                .command_jump 0,CMD_NOSCROLL,noscroll_command
                .command_jump 2,CMD_HELP,help_command
                .command_jump 0,CMD_FORE,fore_command
                .command_jump 0,CMD_BACK,back_command
                .command_jump 0,CMD_INSERT,insert_command
                .command_jump 0,CMD_OVERTYPE,overtype_command
                .command_jump 2,CMD_INFO,info_command
                .command_jump $49,CMD_LABEL_KEY,label_edit_mode_command
                .command_jump $49,CMD_NUMBER_KEY,number_edit_mode_command
                .command_jump $14,CMD_goto_line,goto_line_command
                .command_jump 0,CMD_RENUMBER,renumber_command
                .command_jump 0,CMD_TAB,tab_command
                .command_jump 0,CMD_GOTO,goto_command
                .command_jump 8,CMD_CONTINUE,continue_edit_mode_command
                .command_jump 0,CMD_EDIT,find_command
                .command_jump $14,CMD_TOP,top_command
                .command_jump $14,CMD_END,end_command
                .command_jump 0,CMD_shift_tab_key,loc_9783
                .command_jump 8,CMD_ZSAVE,zsave_command
                .command_jump 0,CMD_IFIND,ifind_command
                .command_jump 0,CMD_ICHANGE,qichange_or_ichange_command
                .command_jump 0,CMD_QICHANGE,qichange_or_ichange_command
                .command_jump 8,CMD_ZRUN,zrun_command
                .if ENABLE_DEBUG
                .command_jump 8,CMD_MODE_KEY,print_debug_stuff_edit_mode_command
                .endif
		.byte $FF

;-------------------------------------------------------------------------

loc_967A:				
		JSR	sub_9698
		BCS	loc_9695
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JMP	sub_9FD8

loc_9695:				
		JMP	loc_9DA8



sub_9698:				
		LDA	byte_6C0
		STA	byte_27
		LDA	byte_6C1
		STA	byte_28
		CMP	#-1
		BEQ	loc_96BB
		LDY	#1
		LDA	current_line_no_msb
		CMP	(byte_27),Y
		BCS	loc_96B0

loc_96AE:				
		SEC
		RTS

loc_96B0:				
		BNE	loc_96BD
		INY
		LDA	current_line_no_lsb
		CMP	(byte_27),Y
		BCC	loc_96AE
		BNE	loc_96BD

loc_96BB:				
		CLC
		RTS

loc_96BD:				
		LDX	#$3F ; '?'

loc_96BF:				
		LDA	$6C0,X
		STA	$700,X
		DEX
		BPL	loc_96BF
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	#0
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	sub_BA69
		TXA
		LSR
		CMP	screen_height
		BEQ	loc_96F7
		BCS	loc_96F8

loc_96F7:				
		CLC

loc_96F8:				
		PHP
		LDX	#$3F ; '?'

loc_96FB:				
		LDA	$700,X
		STA	$6C0,X
		DEX
		BPL	loc_96FB
		PLP
		RTS
; End of function sub_9698




sub_9706:				
		LDA	#0
		STA	byte_3B
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		RTS
; End of function sub_9706


tab_key_command:			
		LDA	tab_value
		STA	unk_6AA

loc_9720:				
		JSR	make_cursor_invisible
		LDA	byte_39
		PHA
		LDX	unk_6AA
		BEQ	loc_976D
		INX
		STX	byte_39
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		LDY	cursor_offset_msb
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		TXA
		BNE	loc_973C
		LDA	code_area_width
		TAX

loc_973C:				
		CMP	byte_39
		BCC	loc_9745
		SBC	unk_6AA
		BNE	loc_973C

loc_9745:				
		STA	byte_3A
		SEC
		LDA	byte_39
		SBC	byte_3A
		TAY
		STX	byte_3A
		CLC
		ADC	byte_3A
		CMP	code_area_width
		BEQ	loc_9762
		BCC	loc_9762
		LDA	code_area_width
		SBC	byte_3A
		CLC
		ADC	#1
		TAY

loc_9762:				
		STY	unk_6AA

loc_9765:				
		JSR	cursor_right_edit_mode_command
		DEC	unk_6AA
		BNE	loc_9765

loc_976D:				
		PLA
		STA	byte_39
		RTS

tab_command:				
		LDA	byte_3F
		BEQ	loc_977A

loc_9775:				
		LDA	#$21 ; '!'
		JMP	loc_859D

loc_977A:				
		LDA	byte_3E
		CMP	#$51 ; 'Q'
		BCS	loc_9775
		STA	tab_value
		RTS

loc_9783:				
		LDA	#$50 ; 'P'
		STA	unk_6AA
		JMP	loc_9720

continue_edit_mode_command:		
		LDA	search_string_length
		BNE	loc_9794
		LDA	#$23 ; '#'

loc_9791:				
		JMP	loc_859D

loc_9794:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_979D

loc_9799:				
		LDA	#8
		BNE	loc_9791

loc_979D:				
		LDA	#$43 ; 'C'
		STA	byte_3E
		LDA	#6
		STA	byte_3F
		LDA	search_string_length
		STA	byte_6BE
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_97B0
		INC	cursor_offset_msb

loc_97B0:				
		LDA	cursor_offset_msb
		BEQ	loc_97C4
		BNE	loc_97F0

loc_97B6:				
		LDY	#0
		STY	cursor_offset_msb
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	(byte_2B),Y
		BMI	loc_9799
		JSR	detokenize_one_line

loc_97C4:				
		JSR	sub_9260
		BCC	loc_97F0
		LDA	byte_2B
		CMP	byte_6C0
		BNE	loc_97ED
		LDA	byte_2C
		CMP	byte_6C1
		BNE	loc_97ED
		LDA	byte_6B3
		BEQ	loc_97EA
		JSR	sub_AA17
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	sub_A069

loc_97EA:				
		JMP	position_edit_mode_cursor

loc_97ED:				
		JMP	loc_9163

loc_97F0:				
		JSR	advance_2b_to_next_line
		JMP	loc_97B6

split_statement_edit_mode_command:	
		JSR	rstrip_detokenized_line
		CPY	#0
		BEQ	loc_9801
		LDA	cursor_offset_msb
		BEQ	loc_9804

loc_9801:				
		JMP	beep

loc_9804:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	#1
		BEQ	loc_9801
		CMP	byte_400
		BEQ	loc_9811
		BCS	loc_9801

loc_9811:				
		LDY	#0

loc_9813:				
		LDA	$400,Y
		STA	$700,Y
		DEY
		BNE	loc_9813
		JSR	sub_A8C0
		LDY	#0

loc_9821:				
		LDA	$700,Y
		STA	$400,Y
		DEY
		BNE	loc_9821
		JSR	sub_9968
		PHA
		CMP	#0
		BNE	loc_9835
		JMP	loc_98DB

loc_9835:				
		LDA	byte_400
		CMP	#-5 ; '�'
		BNE	loc_9840

loc_983C:				
		PLA
		JMP	renumber_edit_mode_command

loc_9840:				
		LDY	byte_400

loc_9843:				
		LDA	$400,Y
		CMP	#7
		BEQ	loc_983C
		DEY
		BNE	loc_9843
		LDY	byte_400

loc_9850:				
		LDA	$400,Y
		STA	$401,Y
		CPY	cursor_offset	; offset of cursor in detokenized buffer
		BEQ	loc_985D
		DEY
		BNE	loc_9850

loc_985D:				
		LDA	#7
		STA	$400,Y
		INC	byte_400
		LDA	#1
		STA	byte_6B3
		LDA	#0
		STA	byte_6A7
		JSR	sub_A8C0
		INC	byte_6A7
		LDA	#-1
		STA	unk_6AD
		JSR	sub_8492
		LDA	unk_6AD
		CMP	#-1
		BEQ	loc_9892
		JSR	sub_999A

loc_9887:				
		LDA	unk_6AD
		LDX	#0
		STX	unk_6AD
		JMP	loc_859D

loc_9892:				
		JSR	detokenize_one_line
		LDA	unk_6AD
		CMP	#-1
		BEQ	loc_98B5
		JSR	sub_999A
		LDA	#-1
		STA	unk_6AD
		JSR	detokenize_one_line
		LDA	unk_6AD
		CMP	#-1
		BNE	loc_9887
		INC	unk_6AD
		PLA
		JMP	loc_967A

loc_98B5:				
		INC	unk_6AD
		LDY	byte_400

loc_98BB:				
		LDA	$400,Y
		CMP	#7
		BEQ	loc_98C5
		DEY
		BNE	loc_98BB

loc_98C5:				
		STY	cursor_offset	; offset of cursor in detokenized buffer

loc_98C7:				
		LDA	$401,Y
		STA	$400,Y
		INY
		CPY	byte_400
		BNE	loc_98C7
		LDA	#$20 ; ' '
		STA	$400,Y
		DEC	byte_400

loc_98DB:				
		PLA
		STA	byte_36
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_C
		LDA	#4
		ADC	#0
		STA	byte_D
		LDA	#1
		STA	byte_E
		LDA	#7
		STA	byte_F
		SEC
		LDA	byte_400
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		TAY
		INY
		STY	unk_700
		LDX	#0
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		STX	byte_400
		LDA	#1
		STA	byte_6B3
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	byte_35
		LDA	#0
		STA	byte_C
		LDA	#7
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDY	unk_700
		INY
		LDX	#0
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_992F:				
		LDX	current_line_no_msb
		LDY	current_line_no_lsb
		INC	current_line_no_lsb
		BNE	loc_9939
		INC	current_line_no_msb

loc_9939:				
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		TXA
		PHA
		TYA
		PHA
		LDA	byte_36
		PHA
		LDX	byte_35
		JMP	loc_AFBB



repeat_edit_mode_command:		
		JSR	sub_995B
		STA	byte_36
		JSR	detokenize_one_line
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	byte_35
		JMP	loc_992F
; End of function repeat_edit_mode_command




sub_995B:				
		JSR	sub_9968
		PHA
		CMP	#0
		BEQ	loc_9966
		JSR	sub_8492

loc_9966:				
		PLA
		RTS
; End of function sub_995B




sub_9968:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_9997
		LDY	#3
		CLC
		LDA	(byte_2B),Y
		ADC	byte_2B
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDX	current_line_no_msb
		LDY	current_line_no_lsb
		INY
		BNE	loc_9986
		INX
		BMI	loc_9993

loc_9986:				
		TYA
		LDY	#2
		CMP	(byte_C),Y
		BNE	loc_9997
		DEY
		TXA
		CMP	(byte_C),Y
		BNE	loc_9997

loc_9993:				
		LDA	#1
		BNE	locret_9999

loc_9997:				
		LDA	#0

locret_9999:				
		RTS
; End of function sub_9968




sub_999A:				
		JSR	find_program
		LDY	#4

loc_999F:				
		LDA	(byte_2B),Y
		CMP	#7
		BEQ	loc_99A8
		INY
		BNE	loc_999F

loc_99A8:				
		TYA
		CLC
		ADC	byte_2B
		STA	byte_C
		STA	byte_E
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		STA	byte_F
		INC	byte_C
		BNE	loc_99BE
		INC	byte_D

loc_99BE:				
		SEC
		LDA	TOP
		SBC	byte_C
		TAY
		LDA	TOP+1
		SBC	byte_D
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#3
		LDA	(byte_2B),Y
		SEC
		SBC	#1
		STA	(byte_2B),Y
		RTS
; End of function sub_999A


renumber_command:			
		LDA	#$A
		STA	unk_6B9
		TAX
		LDA	#0
		STA	unk_6B8
		LDA	byte_3F
		BPL	loc_99E8
		JMP	loc_9A8B

loc_99E8:				
		LDY	#1

loc_99EA:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_99FD
		CMP	#$2C ; ','
		BNE	loc_99FA
		LDA	#$20 ; ' '
		STA	(byte_3E),Y
		BNE	loc_99FD

loc_99FA:				
		INY
		BNE	loc_99EA

loc_99FD:				
		LDA	byte_3E
		PHA
		LDA	byte_3F
		PHA
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	loc_9A0D
		LDA	#$B
		JMP	loc_859D

loc_9A0D:				
		LDA	byte_3F
		STA	unk_6B8
		LDA	byte_3E
		STA	unk_6B9
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
		LDY	#0

loc_9A1F:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_9A39
		CMP	#$20 ; ' '
		BEQ	loc_9A2C
		INY
		BNE	loc_9A1F

loc_9A2C:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_9A39
		CMP	#$20 ; ' '
		BNE	loc_9A3E
		INY
		BNE	loc_9A2C

loc_9A39:				
		LDX	#$A
		JMP	loc_9A99

loc_9A3E:				
		CLC
		TYA
		ADC	byte_3E
		STA	byte_3E
		PHA
		BCC	loc_9A49
		INC	byte_3F

loc_9A49:				
		LDA	byte_3F
		PHA
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	loc_9A56
		LDA	#$B
		JMP	loc_859D

loc_9A56:				
		LDA	byte_3F
		BEQ	loc_9A5F

loc_9A5A:				
		LDA	#$26 ; '&'
		JMP	loc_859D

loc_9A5F:				
		LDA	byte_3E
		BEQ	loc_9A5A
		TAX
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
		LDY	#0

loc_9A6C:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_9A99
		CMP	#$20 ; ' '
		BEQ	loc_9A79
		INY
		BNE	loc_9A6C

loc_9A79:				
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	loc_9A99
		CMP	#$20 ; ' '
		BNE	loc_9A86
		INY
		BNE	loc_9A79

loc_9A86:				
		LDA	#$C
		JMP	loc_859D

loc_9A8B:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	locret_9AD7
		JSR	sub_9AAD
		LDA	byte_39
		BPL	loc_9AAA
		LDX	#3

loc_9A99:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	locret_9AD7
		JSR	sub_9AAD
		LDA	byte_39
		BPL	loc_9AAA
		LDA	#$19
		JMP	loc_859D

loc_9AAA:				
		JMP	loc_84A7



sub_9AAD:				
		LDA	unk_6B8
		STA	byte_39
		LDA	unk_6B9
		STA	byte_3A
		LDA	oshwm
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9ABF:				
		JSR	advance_2b_to_next_line
		LDY	#1
		LDA	(byte_2B),Y
		BMI	locret_9AD7
		CLC
		TXA
		ADC	byte_3A
		STA	byte_3A
		BCC	loc_9AD4
		INC	byte_39
		BMI	locret_9AD7

loc_9AD4:				
		JMP	loc_9ABF

locret_9AD7:				
		RTS
; End of function sub_9AAD




edit_mode_loop:				
					
		LDX	#$FF
		TXS
		STX	byte_6A7
		LDA	byte_6AB
		BEQ	loc_9AE6
		JSR	kbflush

loc_9AE6:				
		LDX	#0
		LDY	#$FF
		LDA	#216		; read length of soft key string
		JSR	OSBYTE		; flush	pending	soft key expansion
		STX	byte_3A		; save old value (??)
		JSR	reset_cursor_shape
		JSR	getch

check_return_key:			; return?
		CMP	#13
		BNE	check_tab_key
		LDA	#CMD_return_key
		BNE	run_command

check_tab_key:				
		CMP	#9
		BNE	check_delete_key
		LDA	#CMD_tab_key
		BNE	run_command

check_delete_key:			
		CMP	#$7F ; ''
		bne run_command
                LDA	#CMD_delete_key

; check_copy_key:
;                 cmp #$ab
;                 bne run_command
;                 lda #CMD_shift_delete_key
                
run_command:				
					
		STA	current_command_id
		LDX	#0
		LDY	#$FF
		LDA	#216
		JSR	OSBYTE
		TXA
		ORA	byte_3A		; check	if both	soft key expansion states were 0
		BEQ	loc_9B2C	; branch taken if both were
		LDA	current_command_id
		CMP	#$20 ; ' '
		BCC	loc_9B28

loc_9B25:				
					
		JMP	dispatch_command

loc_9B28:				
		LDA	#$20 ; ' '
		BNE	set_command	; JMP, in effect

loc_9B2C:				
		LDX	#$FF		; query	keyboard buffer
		LDY	#$FF
		LDA	#128
		JSR	OSBYTE		; get ADVAL/buffer status (AUG p151)
		TXA
		BNE	loc_9B25	; branch taken if any keys in keyboard buffer
		LDA	current_command_id
		CMP	#CMD_return_key
		BNE	loc_9B4E
		LDX	#$9A
		JSR	poll_key	; poll state of	key.
					;
					; Entry:
					; X = -ve INKEY	value
					;
					; Exit:
					; X = 0	and Z set if key pressed
		BNE	loc_9B25
		LDA	#$D

set_command:				
					
		STA	current_command_id
		JMP	dispatch_command

loc_9B4E:				
		CMP	#CMD_tab_key
		BNE	loc_9B5D
		LDX	#$DA		; I key
		JSR	poll_key	; poll state of	key.
					;
					; Entry:
					; X = -ve INKEY	value
					;
					; Exit:
					; X = 0	and Z set if key pressed
		BNE	loc_9B5D	; branch taken if I not	pressed
		LDA	#9		; set command 9	(think this is some kind of fudge to stop Ctrl+I doing anything)
		BNE	set_command

loc_9B5D:				
					
		LDX	#0		; Don't change anything
		LDY	#$FF		; Read old value
		LDA	#202
		JSR	OSBYTE		; Read keyboard	status byte (AUG p207)
		STX	byte_38		; bit 3	- 1 if SHIFT pressed
					; bit 4	- 0 if CAPS LOCK engaged
					; bit 5	- 0 if SHIFT LOCK engaged
					; bit 6	- 1 if CTRL pressed
					; bit 7	- 1 if SHIFT is	to reverse CAPS	LOCK/SHIFT LOCK	status

check_shift_delete_key:
		LDA	current_command_id
		CMP	#CMD_delete_key
		BNE	check_shift_tab_key
		LDA	#8
		BIT	byte_38		; Check	SHIFT state
		BEQ	dispatch_command ; Branch taken	if SHIFT not pressed
		LDA	#CMD_shift_delete_key
		STA	current_command_id
		BNE	dispatch_command ; JMP,	in effect

check_shift_tab_key:			
		CMP	#CMD_tab_key
		BNE	dispatch_command
		LDA	#8
		BIT	byte_38		; Check	SHIFT state
		BEQ	dispatch_command ; Branch taken	if SHIFT not pressed
		LDA	#CMD_shift_tab_key
		STA	current_command_id

dispatch_command:			
					
		LDA	current_command_id
		CMP	#$20 ; ' '
		BCC	execute_non_key_command
		CMP	#$A0
		BCS	execute_non_key_command
		JSR	execute_key_command ; treats command ID	as ASCII char and puts that char into the current line as appropriate.
		JMP	edit_mode_loop

execute_non_key_command:		
					
		JSR	execute_command	; unk_6BD = command to run
		JMP	edit_mode_loop
; End of function edit_mode_loop

;-------------------------------------------------------------------------
;
; poll SHIFT state.
;
; *this routine is also used by the service code*
;
; Exit:
; X = 0	and Z set if SHIFT pressed
poll_shift:
                ldx #$ff        ;must be position-independent
                ; fall through
                
;-------------------------------------------------------------------------
;
; poll state of	key.
;
; *this routine is also used by the service code*
; 
; Entry:
; X = -ve INKEY	value
;
; Exit:
; X = 0	and Z set if key pressed

poll_key:                       ;must be position-independent
		LDY	#$FF    ;must be position-independent
		LDA	#129    ;must be position-independent
		JSR	OSBYTE  ;must be position-independent
		INX             ;must be position-independent
		RTS             ;must be position-independent

;-------------------------------------------------------------------------

make_cursor_invisible:			

.if !ELECTRON

		LDX	#10
		LDY	#32
; End of function make_cursor_invisible


; X = CRTC register
; Y = value

write_crtc:				
					
		PHA			; save A
		TYA
		PHA			; save Y
		TXA
		TAY			; value	to write = original X
		LDX	#0		; $FE00	(CRTC register select)
		LDA	#151		; write	SHEILA
		JSR	OSBYTE
		PLA
		TAY			; value	to write = original Y
		LDX	#1		; $FE01	(CRTC register value)
		LDA	#151		; write	SHEILA
		JSR	OSBYTE
		PLA
		RTS
; End of function write_crtc

.else

		LDY #0
; End of function make_cursor_invisible


; Y = VDU 23,1,Y,0;0;0;0;

set_cursor_state:

		PHA			; save A
		TYA
		PHA			; save Y
		LDA #23
		JSR OSWRCH
		LDA #1
		JSR OSWRCH
		TYA
		JSR OSWRCH
		LDY #8
		LDA #0
set_cursor_shape_8zeros:
		JSR OSWRCH
		DEY
		BNE set_cursor_shape_8zeros
		PLA
		TAY
		PLA
		RTS

.endif


reset_cursor_shape:			

.if !ELECTRON

		JSR	get_current_mode_in_x
		LDA	#0
		LDY	is_insert_mode	; 0=overtype 1=insert
		BNE	loc_9BD2
		LDA	CRTC_cursor_start_values,X

loc_9BD2:				
		ORA	cursor_size
		TAY
		LDX	#10
		JSR	write_crtc
		JSR	get_current_mode_in_x
		LDA	is_insert_mode	; 0=overtype 1=insert
		BNE	loc_9BE6
		LDY	CRTC_cursor_end_values_overtype,X
		BNE	loc_9BE9

loc_9BE6:				
		LDY	CRTC_cursor_end_values_insert,X

loc_9BE9:				
		LDX	#11
		JMP	write_crtc

.else

		LDY #1	; show cursor
		JSR set_cursor_state

		LDA is_insert_mode ; 0=overtype 1=insert
		ORA #2 ; to give 2=steady 3=flashing
		TAY
		JMP set_cursor_state

.endif


; End of function reset_cursor_shape

;-------------------------------------------------------------------------

get_current_mode_in_x: .proc
                lda #160        ;read VDU variables (AUG 179)
                ldx #$55        ;current MODE (AUG 277)
                jmp osbyte
                .pend

;-------------------------------------------------------------------------

kbflush:				
					
		LDX	#0		; Flush	keyboard buffer
		STX	byte_6AB
		LDA	#21		; Flush	specific buffer	(AUG p138)
		JSR	OSBYTE
		LDA	#216		; Read/write length of soft key	string
		JSR	osbyte_with_y0	; Cancel any current soft key expansion
		JMP	clear_escape_condition
; End of function kbflush


;-------------------------------------------------------------------------

detokenize_one_line: .proc

                .if !KEEP_DETOKENIZE_ONE_LINE_MEMSET

                ldx #1
                lda #$20
loop400:
                sta byte_400,x
                inx
                bne loop400
loop500:
                sta unk_500,x
                inx
                cpx #$25
                bne loop500

                .endif

                .if KEEP_DETOKENIZE_ONE_LINE_MEMSET
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
                .endif
                
		LDX	#0
		STX	byte_400
		STX	byte_6A8

                .if KEEP_DETOKENIZE_ONE_LINE_MEMSET
		INX			; X=1
		LDY	#$24 ; '$'
		LDA	#$20 ; ' '
		JSR	memset		; Clear	$401 - $525
                .endif
                
		LDX	byte_2C		; get MSB of address
		INX
		BNE	loc_9C26	; branch taken if MSB of address wasn't $FF

locret_9C25:				
		RTS

loc_9C26:				
		JSR	detokenize_line	; detokenize line and store result.
					;
					; Entry:
					; (byte_2B) points to line
					;
					; Exit:
					; $400 = line length
					; $401... = line text
					; unk_6A8 incremented if line too long
		LDA	byte_6A8	; line too long?
		BEQ	locret_9C25	; branch taken if line not too long
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	#4		; "Line	too long"
		JMP	loc_859D
                .pend

;-------------------------------------------------------------------------

; detokenize line and store result.
;
; Entry:
; (byte_2B) points to line
;
; Exit:
; $400 = line length
; $401... = line text
; unk_6A8 incremented if line too long

detokenize_line: .proc
					
		CLC
; Point (unk_27) at start of data of current line
		LDA	byte_2B
		ADC	#4		; +4 - skip 13,	line MSB, line LSB, line length.
		STA	byte_27
		LDA	byte_2C
		STA	byte_28
		BCC	loc_9C45
		INC	byte_28

loc_9C45:				
		LDA	#0
		STA	byte_400
		STA	byte_23		; index	in body	of line
		STA	byte_25		; not inside quotes
		LDY	#3		; index	of line	length
		LDA	(byte_2B),Y	; get total line length
		SEC
		SBC	#4		; subtract 4 as	the metadata is	already	considered
		STA	byte_24		; ?unk_24 = length of body of line
		BEQ	detokenize_line_done		; branch taken if line is empty

loc_9C59:				
		LDA	#4
		STA	byte_F
		CLC
		LDA	#1
		ADC	byte_400
		STA	byte_E
		BCC	loc_9C69
		INC	byte_F

loc_9C69:				
		LDX	byte_24		; get line length
		DEX			; -1 to	get index of last byte
		CPX	byte_23		; compare to current index
		BCS	loc_9C71	; branch taken if there's still more data to go

detokenize_line_done:					
		RTS

loc_9C71:				
		LDA	byte_25		; in string?
		BEQ	copy_tokenized	; branch taken if not in string
; point (byte_C) at byte in program

not_token:				
					
		LDA	byte_28
		STA	byte_D
		LDA	byte_23
		CLC
		ADC	byte_27
		STA	byte_C
		BCC	copy_whilst_checking_for_quotes
		INC	byte_D

copy_whilst_checking_for_quotes:	
		LDY	byte_23
		LDA	(byte_27),Y	; get next byte
		CMP	#34            ; quotes?
		BNE	read_byte
; toggle 'in quotes' flag
		LDA	byte_25
		EOR	#1
		STA	byte_25

read_byte:				
		LDY	#1
		BNE	advance

copy_tokenized:				
		LDY	byte_23
		LDA	(byte_27),Y	; get next byte	from line
		BPL	not_token	; if positive, not a taken
		CMP	#$8D		; is this a line number?
		BNE	token		; branch taken if not a	line number
		TYA
		CLC
		ADC	#3		; +3 - skip line number	data
		BCS	not_token	; if carry set,	assume end of line
		CMP	byte_24		; past end of line?
		BCS	not_token	; branch taken if past end of line
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		LDX	byte_22
		LDY	byte_21
		JSR	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string
		LDA	#<unk_1
		STA	byte_C
		LDA	#>unk_1
		STA	byte_D
; Skip 3 bytes (line number data)
		INC	byte_23
		INC	byte_23
		INC	byte_23
		LDY	byte_0
		BNE	advance		; JMP, in effect, I think...

token:					
		STA	byte_26		; ?byte_26 = token being searched for
		LDA	#<token_table
		STA	byte_C
		LDA	#>token_table
		STA	byte_D

loc_9CD0:				
		LDY	#0

find_token_value_loop:			
		LDA	(byte_C),Y	; get next byte	from token table
		BMI	found_token_value ; branch taken if it's a token value
		INY
		BNE	find_token_value_loop

found_token_value:			
		CMP	byte_26		; is it	the desired token?
		BEQ	advance		; branch taken if token	found
		CMP	#$D3		; HIMEM, statement version?
		BEQ	not_token	; ??? -	branch taken if	so
		INY			; skip token ID
		INY			; skip other byte
; advance (byte_C) to next entry in token table
		TYA
		CLC
		ADC	byte_C
		STA	byte_C
		BCC	loc_9CED
		INC	byte_D

loc_9CED:				
		BNE	loc_9CD0

advance:				
					
		TYA			; get length of	token
		CLC
		ADC	byte_400	; add to current length
		BCS	overflow	; branch taken if line too long...
		CMP	#LINE_LENGTH_LIMIT
		BCS	overflow	; branch taken if line too long...
		STA	byte_400	; store	new current length
		DEY			; Y = index of last char of token
		JSR	copy_detokenized_text ;	copy text whilst detokenizing.
					;
					; Entry:
					; (byte_C) points to source text
					; (byte_E) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		INC	byte_23		; next byte in line
		JMP	loc_9C59

overflow:				
					
		INC	byte_6A8
		RTS

copy_detokenized_text:			
					
		LDA	(byte_C),Y	; copy text whilst detokenizing.
					;
					; Entry:
					; (byte_C) points to source text
					; (byte_E) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		STA	(byte_E),Y
		DEY
		BPL	copy_detokenized_text ;	copy text whilst detokenizing.
					;
					; Entry:
					; (byte_C) points to source text
					; (byte_E) points to space in dest buffer
					; Y is index of	last byte in each case (bytes are copied until Y<0)
		RTS
                .pend

;-------------------------------------------------------------------------

; decode line number from program.
;
; Entry:
; (unk_27),Y points to 8D token
;
; Exit:
; unk_21.w is line number.

decode_line_number: .proc		
					
		INY
		LDA	(byte_27),Y	; get first line number	byte
		PHA			; store
		LDX	#1

decode_line_number_loop:					
		PLA			; get last byte
		ROL
		ROL			; <<2
		PHA			; save
		AND	#%11000000
		INY
		EOR	(byte_27),Y
		STA	byte_21,X
		DEX
		BPL	decode_line_number_loop
		PLA
		RTS
                .pend

;-------------------------------------------------------------------------

init_edit_mode: .proc
					
		LDA	#1
		STA	byte_6AB

loc_9D2D:
		JSR	find_program
		BCC	loc_9D3F
		JMP	language_entry.command_loop;ok

loc_9D3F:				
		JSR	set_palette
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
                lda #$80
                sta should_cls_before_command_prompt
		LDA	#13
		JSR	OSWRCH
		LDX	#9		; VDU variable 9 - text	window coordinates, bottom (X) + right (Y) (AUG	p275)
		LDA	#160		; read VDU variable value (AUG p179)
		JSR	OSBYTE
		STX	screen_height	; store	screen height
		TYA			; get screen width in A
		SEC
		SBC	#6		; subtract 6 to	account	for line number	display
		STA	code_area_width	; store	usable screen width
		LDX	#9		; set TAB key to produce CHR$9
		LDA	#219		; Read/write character value returned by pressing TAB key (AUG p222)
		JSR	osbyte_with_y0
		JMP	loc_8437
                .pend

;-------------------------------------------------------------------------

set_edit_mode_option:
                jsr get_options
                ora #OPTION_EDIT_MODE
                bne set_options

clear_edit_mode_option:
                jsr get_options
                and #(~OPTION_EDIT_MODE)&$ff
                ; fall through
set_options:
                tax
                ; fall through
do_options_osbyte:                    ;must be position-independent
                lda #OPTIONS_OSBYTE   ;must be position-independent
                jsr osbyte            ;must be position-independent
                txa                   ;must be position-independent
                rts                   ;must be position-independent
get_options:                          ;must be position-independent
                ldx #$ff              ;must be position-independent
                bne do_options_osbyte ;must be position-independent
                
;-------------------------------------------------------------------------

enter_edit_mode:
		JSR	init_edit_mode
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_9DA8
		LDA	byte_50
		STA	byte_2B
		LDA	byte_51
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
                ; end of program?
		LDY	#1
		LDA	(byte_2B),Y
		BMI	loc_9DA8
                
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JSR	sub_9698
		BCS	loc_9DA8
                
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		JSR	sub_9706
		JSR	cls_and_reset_6c0_to_6ff
		CLC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JMP	loc_9DE4

loc_9DA8:				
					
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_9DC9
		JSR	clear_program
		JSR	cls_and_reset_6c0_to_6ff
		LDX	#<empty_program_string
		LDY	#>empty_program_string
		LDA	#5
		JSR	print_n_chars
		LDX	#$FF
		STX	byte_6C0
		STX	byte_6C1
		STX	byte_2C
		JMP	loc_9DE4

loc_9DC9:				
		LDA	current_line_no_lsb
		STA	byte_2C
		LDA	current_line_no_msb
		STA	byte_2B
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number

loc_9DE4:				
		JSR	sub_9FD8
                jsr set_edit_mode_option
		JMP	edit_mode_loop

;-------------------------------------------------------------------------

sub_9DEA: .proc
					
		PHP
		JSR	make_cursor_invisible
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

loc_9DF1:				
		LDY	#1
		LDA	(byte_2B),Y
		BMI	loc_9E19
		JSR	detokenize_one_line
		JSR	sub_9E5F
		BCC	loc_9E19
		PLP
		PHP
		BCC	loc_9E09
		JSR	sub_9F00
		JMP	loc_9E0C

loc_9E09:				
		JSR	sub_9E82

loc_9E0C:				
		CLC
		LDA	byte_3B
		ADC	byte_2D
		STA	byte_3B
		JSR	advance_2b_to_next_line
		JMP	loc_9DF1

loc_9E19:				
		PLP
		PHP
		BCC	loc_9E5D

loc_9e1d:

                .if KEEP_9E1D_MEMSET
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
		LDX	#0
		LDY	#$4F ; 'O'
		LDA	#$20 ; ' '
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.
                .else
                lda #$20
                ldx #$4f
loc_9e1d_fill_401_loop:
                sta $400,x
                dex
                bne loc_9e1d_fill_401_loop
                .endif
                
loc_9E2E:				
		LDA	byte_3B
		CMP	screen_height
		BEQ	loc_9E37
		BCS	loc_9E5D

loc_9E37:				
		ASL
		TAY
		LDA	$6C1,Y
		BEQ	loc_9E5D
		LDX	#0
		TXA
		STA	$6C0,Y
		STA	$6C1,Y
		LDY	byte_3B
		JSR	gotoxy
		CLC
		LDA	code_area_width
		ADC	#6
		LDX	#<unk_401
		LDY	#>unk_401
		JSR	print_n_chars
		INC	byte_3B
		BNE	loc_9E2E

loc_9E5D:				
		PLA
		RTS
                .pend



sub_9E5F:				
					
		JSR	calculate_screen_chars_in_line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	screen_height
		SEC
		SBC	byte_3B
		CLC
		ADC	#1
		CMP	byte_2D
		BCC	locret_9E81
		LDA	byte_3B
		ASL
		TAY
		LDA	byte_2B
		STA	$6C0,Y
		LDA	byte_2C
		STA	$6C1,Y
		SEC

locret_9E81:				
		RTS
; End of function sub_9E5F




sub_9E82:				
					
		LDA	#1
		LDX	byte_400
		LDY	#0
		JSR	sub_A0B1
		JMP	redraw_line_number
; End of function sub_9E82


;-------------------------------------------------------------------------

; finds	a line,	given a	line number
;
; Entry:
; byte_2B: line	number MSB
; byte_2C: line	number LSB
;
; Exit:
; (byte_2B) points to most suitable line

find_line_by_number: .proc
					
		LDA	byte_2B
		STA	byte_39
		LDA	byte_2C
		STA	byte_3A
		LDA	oshwm
		STA	unk_30
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9EA1:				
		LDY	#1
		LDA	(byte_2B),Y	; get line MSB
		BMI	find_line_by_number_done		; -ve =	done
		CMP	byte_39
		BCC	loc_9EB4	; MSB<?39 -> 9eb4
		BNE	find_line_by_number_done
		INY			; offset of line LSB
		LDA	(byte_2B),Y	; get line LSB
		CMP	byte_3A
		BCS	find_line_by_number_done
; MSB<?39 && LSB<=?3A

loc_9EB4:				
		LDA	byte_2B
		STA	unk_2F
		LDA	byte_2C
		STA	unk_30
		JSR	advance_2b_to_next_line
		JMP	loc_9EA1

find_line_by_number_done:					
					
		RTS
                .pend

;-------------------------------------------------------------------------

; get height of	current	line
;
; Entry:
; ?byte_400 = line length
;
; Exit:
; X = line height

get_line_height: .proc
					
		LDY	#0
		LDX	byte_400	; get line length
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		TXA			; get width
		BEQ	loc_9ECF	; taken	if it fits exactly
		INY			; add an extra line, because it	needs it

loc_9ECF:				
		TYA
		TAX			; X = line height
		BNE	locret_9ED4
		INX			; set height to	1 if line is empty

locret_9ED4:				
		RTS
                .pend
                
;-------------------------------------------------------------------------

fg_table:
                ;    0 1 2 3 4 5 6 7
                .byte 1,3,7,1,1,3,1,0

set_palette:				
					
		LDX	#0		; set colour 0
		LDY	background_colour ; get	BACK colour
                JSR	set_palette_entry ; X=logical colour, Y=physical colour
                
		LDA	#$87		; get MODE in Y
                JSR	OSBYTE		; get MODE in Y
                tya
                and #7          ;the M128 only ever returns 0-7, but I
                                ;don't know what other systems do.
                tay
                ldx fg_table,Y
		LDY	foreground_colour ; get	FORE colour

set_palette_entry:			
		LDA	#19		; X=logical colour, Y=physical colour
		JSR	OSWRCH
		TXA
		JSR	OSWRCH
		TYA
                JSR	OSWRCH
                jsr print_next_string
                .byte 0,0,0,255
set_palette_done:
		RTS
; End of function set_palette




sub_9F00:				
		JSR	make_cursor_invisible
		LDA	#1
		LDX	screen_chars_in_line+0
		LDY	screen_chars_in_line+1
		JSR	sub_A0B1
		LDX	#0
		STX	byte_36

loc_9F10:				
		LDX	#0
		CLC
		LDA	byte_36
		BEQ	loc_9F26
		ADC	byte_3B
		TAY
                JSR	gotoxy
                lda #6
                jsr print_n_spaces

loc_9F26:				
		INC	byte_36
		LDA	byte_36
		CMP	byte_2D
		BNE	loc_9F10
		JMP	redraw_line_number
; End of function sub_9F00



; treats command ID as ASCII char and puts that	char into the current line as appropriate.

execute_key_command: .proc
		LDA	cursor_offset_msb
		BNE	beep
		JSR	sub_AB1E
		LDX	byte_400	; X = line length
		LDA	is_insert_mode	; 0=overtype 1=insert
		BEQ	loc_9F5C	; branch taken if overtype mode
		LDA	cursor_offset	; get cursor offset (?)
		CMP	byte_400	; compare to line length
		BEQ	loc_9F48
		BCS	loc_9F58	; branch taken if cursor offset	> line length

loc_9F48:				
		LDY	byte_400	; get line length
		BEQ	loc_9F55
		DEY
		LDA	$401,Y
		CMP	#$20 ; ' '
		BEQ	sub_9F6F

loc_9F55:				
		INX
		BNE	loc_9F65

loc_9F58:				
					
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_9F65

loc_9F5C:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	sub_9F6F
		BCS	loc_9F58

loc_9F65:				
					
		CPX	#LINE_LENGTH_LIMIT
		BCC	sub_9F6F
                ; fall through
                .pend

beep: .block
					
		LDA	#7
		JMP	OSWRCH
                .bend
; End of function beep




sub_9F6F:				
					
		TXA
		PHA
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		PHA
		PHA
		LDA	is_insert_mode	; 0=overtype 1=insert
		BEQ	store_char	; branch taken if overtype
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	insert		; branch taken if at end of line
		BCS	store_char	; branch taken if past end of line

insert:					
		PLA
		TXA
		PHA
		LDX	#$FF
		STX	byte_C
		INX
		STX	byte_E
		INX
		TXA
		JSR	sub_9FB2

store_char:				
		LDA	current_command_id ; get char to write
		LDY	cursor_offset	; offset of cursor in detokenized buffer
		DEY			; make relative	to tex
		STA	$401,Y		; store
		LDA	#1
		STA	byte_6B3
		PLA
		TAX
		PLA
		TAY
		PLA
		STA	byte_400
		TYA
		LDY	#0
		INC	cursor_offset	; advance to next char
		JSR	sub_A0B1
		JMP	position_edit_mode_cursor
; End of function sub_9F6F




sub_9FB2:				
		PHA
		LDX	#2
		JSR	adjust_pointer
		LDX	#0
		JSR	adjust_pointer
; X=0
		PLA
		CLC
		ADC	byte_400	; add line length
		SEC
		SBC	cursor_offset	; subtract cursor offset
		TAY			; LSB of size
		JMP	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

adjust_pointer:				
		CLC
		LDA	byte_C,X	; get pointer LSB
		ADC	#1		; increment
		CLC
		ADC	cursor_offset	; +?byte_10
		STA	byte_C,X	; store
		LDA	#4
		STA	byte_D,X	; copying in page 4.
		RTS
; End of function sub_9FB2




sub_9FD8:				
		JSR	sub_A069
		LDX	#1
		STX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		STX	cursor_offset_msb
		LDX	#6
		LDY	byte_3B
		JMP	gotoxy
; End of function sub_9FD8



; sets C if no program

is_program_empty: .proc
					
		CLC
		LDY	#1
		LDA	(oshwm),Y
		BPL	locret_9FF1
		SEC

locret_9FF1:				
		RTS
                .pend

;-------------------------------------------------------------------------

; check if there's room to store (byte_27) bytes past TOP. Causes a
; 'No room' error if not.
check_for_room: .proc
		CLC
		LDA	TOP     ;get TOP LSB
		ADC	byte_27 ;add size of update LSB
		TAX             ;save new TOP LSB
		LDA	TOP+1   ;get TOP MSB
		ADC	byte_28 ;add size of update MSB
		CMP	HIMEM+1 ;has new TOP MSB gone past HIMEM MSB?
		BCC	locret_A00D ;taken if definitely not
		BEQ	loc_A007    ;taken if it's equal

                ; No room...
no_room:				
		LDA	#5      ;No room
		JMP	loc_859D

loc_A007:				
		CPX	HIMEM   ;compare new TOP LSB to HIMEM LSB
		BEQ	locret_A00D ;taken if equal
		BCS	no_room     ;taken if greater

locret_A00D:				
		RTS
                .pend




cls_and_reset_6c0_to_6ff:		
					
		LDA	#12     ;cls_and_reset_6c0_to_6ff
		JSR	OSWRCH
		LDA	#0
		LDY	#$3F

loc_A017:				
		STA	byte_6C0,Y
		DEY
		BPL	loc_A017
		RTS
; End of function cls_and_reset_6c0_to_6ff


;-------------------------------------------------------------------------

; entry:
; detokenized line in byte_400
;
; exit:
; screen_chars_in_line.w = count
                
calculate_screen_chars_in_line: .proc
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height

loc_A021:				
		STX	byte_2D
		LDA	#0
		STA	screen_chars_in_line+0
		STA	screen_chars_in_line+1

                ; screen_chars_in_line = code_area_width * X
                
loc_A029:				
		LDA	code_area_width
		CLC
		ADC	screen_chars_in_line+0
		STA	screen_chars_in_line+0
		BCC	loc_A035
		INC	screen_chars_in_line+1

loc_A035:				
		DEX
		BNE	loc_A029
		RTS
                .pend

;-------------------------------------------------------------------------

; saves	line number from program.
;
; Entry:
; (byte_2b) points to current line
;
; Exit:
; current_line_no_msb, current_line_no_lsb = the line number

save_line_number:			
					
		LDY	#1
		LDA	(byte_2B),Y
		STA	current_line_no_msb
		INY
		LDA	(byte_2B),Y
		STA	current_line_no_lsb
		RTS
; End of function save_line_number

;-------------------------------------------------------------------------

; gets pointer to line visible on screen.
;
; Entry:
; X = screen line number * 2 + 1
;
; Exit:
; (byte_2B) points to BASIC line
; X decremented

get_line_ptr: .proc
					
		LDA	$6C0,X
		STA	byte_2C
		DEX
		LDA	$6C0,X
		STA	byte_2B
		RTS
                .pend

;-------------------------------------------------------------------------

; determines whether current line is empty.
;
; Entry:
; detokenized line at $400...
;
; Exit:
; C set	if line	empty.

is_line_empty: .proc
					
		JSR	is_program_empty ; sets	C if no	program
		BCC	is_not_empty
		LDY	byte_400
		BEQ	is_empty

loc_A05B:				
		LDA	$400,Y
		CMP	#$20 ; ' '
		BNE	is_not_empty
		DEY
		BNE	loc_A05B

is_empty:				
		SEC
		RTS

is_not_empty:				
					
		CLC
		RTS
                .pend


;-------------------------------------------------------------------------

sub_A069: .proc
					
		LDX	#0		; first	line on	screen

loc_A06B:				
		TXA
		LSR			; A = true screen line index
		CMP	screen_height	; check	against	height of screen

                ; end loop if A>screen_height
		BEQ	+
		BCS	loc_A093
+
                
		JSR	get_line_ptr2	; gets pointer to line visible
                                        ; on screen.
					;
					; Entry:
					; X = screen line number * 2
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X=screen line number*2+1

                ; 
		LDY	byte_6C0,X
		BEQ	loc_A093 ;taken if entry is $00
		INY
		BEQ	loc_A09B ;taken if entry is $ff
                
		LDY	#1
		LDA	(byte_2B),Y         ;program line # MSB
		CMP	current_line_no_msb
		BCC	loc_A090            ;taken if program
                                            ;line<current line
		BNE	loc_A095            ;taken if program
                                            ;line>current line
		INY
                
		LDA	(byte_2B),Y ;program line # LSB
		CMP	current_line_no_lsb
		BCS	loc_A095 ;taken if program line>=current line

loc_A090:				
		INX              ;X+=2 in total
		BNE	loc_A06B ;JMP, in effect

loc_A093:				
		LDX	#1

loc_A095:				
		JSR	get_line_ptr_retainingX
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number

loc_A09B:				
		TXA             
		LSR             ;A = true screen line index
		STA	byte_3B ;save screen line
		JSR	detokenize_one_line
		LDX	#0
		STX	byte_6B3
		JSR	calculate_screen_chars_in_line
		RTS
                .pend

;-------------------------------------------------------------------------

; gets pointer to line visible on screen.
;
; Entry:
; X = screen line number * 2
;
; Exit:
; (byte_2B) points to BASIC line
; X=screen line number*2+1
;

get_line_ptr2:				
		INX			; bump X because get_line_ptr
                                        ; is wierd
                                        
                ; fall through

get_line_ptr_retainingX:		
		JSR	get_line_ptr	; gets pointer to line visible
                                        ; on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
                                        
		INX			; restore original X
		RTS
; End of function get_line_ptr_retainingX




sub_A0B1:				
		CPX	#0
		BNE	loc_A0B6
		RTS

loc_A0B6:				
		STA	byte_28
		DEC	byte_28
		STY	byte_27
		DEX
		STX	byte_26
		JSR	make_cursor_invisible
		LDA	#$FF
		STA	byte_24
		STA	byte_23
		LDA	#0
		SEC
		SBC	code_area_width
		STA	byte_25

loc_A0D0:				
		CLC
		LDA	byte_25
		ADC	code_area_width
		STA	byte_25
		CLC
		LDA	byte_23
		ADC	code_area_width
		STA	byte_23
		BCC	loc_A0E4
		INC	byte_24

loc_A0E4:				
		LDA	#1
		STA	byte_20
		LDA	#4
		STA	byte_21
; (byte_20) points at detokenized line
		LDA	byte_24
		BNE	loc_A0F8
		LDA	byte_28
		CMP	byte_23
		BEQ	loc_A0F8
		BCS	loc_A0D0

loc_A0F8:				
		LDA	byte_28
		CMP	byte_25
		BCS	loc_A100
		LDA	byte_25

loc_A100:				
		STA	byte_22
		CLC
		ADC	byte_20
		STA	byte_20
		BCC	loc_A10B
		INC	byte_21

loc_A10B:				
		LDA	byte_27
		BNE	loc_A115
		LDA	byte_26
		CMP	byte_25
		BCC	locret_A16C

loc_A115:				
		LDX	#0
		LDA	byte_27
		CMP	byte_24
		BEQ	loc_A121
		BCS	loc_A129
		BCC	loc_A127

loc_A121:				
		LDA	byte_26
		CMP	byte_23
		BCS	loc_A129

loc_A127:				
		LDX	#3

loc_A129:				
		SEC
		LDA	byte_23,X
		SBC	byte_22
		CLC
		ADC	#1
		PHA
		LDX	byte_22
		LDY	#0
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		CLC
		TXA			; get X	coordinate
		ADC	#6		; offset by line numbers width
		TAX			; back in X
		CLC
		TYA			; get Y	coordinate
		ADC	byte_3B		; add base Y
		TAY			; back in Y
		JSR	gotoxy		; positino cursor
		LDA	byte_3B		; get screen Y
		ASL
		TAX
		LDA	$6C0,X
		PHA
		LDA	$6C1,X
		PHA
		TYA
		ASL
		TAX
		PLA
		STA	$6C1,X
		PLA
		STA	$6C0,X
		PLA
		LDX	byte_20
		LDY	byte_21
		JSR	print_n_chars
		LDA	byte_24
		BNE	locret_A16C
		JMP	loc_A0D0

locret_A16C:				
		RTS
; End of function sub_A0B1




redraw_line_number:			
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		BEQ	locret_A1D8
		JSR	make_cursor_invisible
		JSR	goto_start_of_line ; Entry:
					; byte_3B is Y coordinate.
		LDA	#0
		STA	readline_ptr_msb
; Line command slot 0
		TAX
		JSR	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
; Line command slot 3
		LDX	#3
		JSR	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
; Line command slot 6
		LDX	#6
		JSR	print_line_command_chars ; prints line command chars for the current line, if any.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; readline_ptr_msb bumped by number of chars printed.
		LDA	readline_ptr_msb
		BNE	print_post_line_command_padding	; branch taken if any line command chars printed
		LDX	current_line_no_lsb
		LDY	current_line_no_msb
		JSR	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string
		SEC
		LDA	#5
		SBC	byte_0
; Right-justify number
		JSR	print_n_spaces	; prints N spaces.
					;
					; Entry:
					; A = number of	spaces to print	(max 6)
                jsr print_itoa_result
                
print_space_or_marker:			
		LDX	#12
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		LDA	#$20 ; ' '
		BCC	redraw_line_number_print_char
		LDA	#$2E ; '.'

redraw_line_number_print_char:				
		JMP	OSWRCH
; End of function redraw_line_number



; Entry:
; byte_3B is Y coordinate.

goto_start_of_line:			
		LDX	#0
		LDY	byte_3B
		JMP	gotoxy
; End of function goto_start_of_line



; prints line command chars for	the current line, if any.
;
; Entry:
; current_line_no_msb,
; current_line_no_lsb =	current	line
; X = line command slot	ID
;
; Exit:
; readline_ptr_msb bumped by number of chars printed.

print_line_command_chars:		
					
		LDA	$40,X		; fetch	control	byte
		CMP	#$20 ; ' '
		BEQ	locret_A1D8	; branch taken if no line command here
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCC	locret_A1D8	; branch taken if no command here
; If char stored is lower-case, print it in upper case, but twice.
		CMP	#$60 ; '`'
		BCC	loc_A1D3
		SEC
		SBC	#$20 ; ' '
		JSR	OSWRCH
		INC	readline_ptr_msb

loc_A1D3:				
		JSR	OSWRCH
		INC	readline_ptr_msb

locret_A1D8:				
					
		RTS
; End of function print_line_command_chars


print_post_line_command_padding:	
		SEC
		LDA	#5
		SBC	readline_ptr_msb
		JSR	print_n_spaces	; prints N spaces.
					;
					; Entry:
					; A = number of	spaces to print	(max 6)
		JMP	print_space_or_marker



clear_line_commands:			
					
		LDA	#$20 ; ' '
		STA	byte_40
		STA	byte_43
		STA	byte_46
		RTS
; End of function clear_line_commands




set_primary_line_command:		
		LDX	#0
		JSR	is_line_command_slot_free ; check availability of line command slot.
					;
					; Entry:
					; X = slot ID
					;
					; Exit:
					; C set	if slot	is free.
		BCS	use_slot
		LDX	#3
		JSR	is_line_command_slot_free ; check availability of line command slot.
					;
					; Entry:
					; X = slot ID
					;
					; Exit:
					; C set	if slot	is free.

use_slot:				
		LDA	current_command_id
		CLC
		ADC	#$40		; make letter from command ID -- 'C', 'D' or 'M'
		LDY	$40,X		; get old command
		CPY	#$20 ; ' '      ; no command?
		BEQ	set_line_command ; branch taken	if no command.
					; just set command if taken.
		CMP	$40,X		; is this the command that's there already?
		BNE	set_line_command ; branch taken	if not same command.
					; overwrite old	command	with new one if	taken.
		CLC
		ADC	#$20 ; ' '      ; +$20 to indicate doubling of command

set_line_command:			
					
		STA	$40,X		; store	command
		LDA	current_line_no_msb
		STA	$41,X		; store	line no	LSB
		LDA	current_line_no_lsb
		STA	$42,X		; store	line no	MSB

loc_A216:				
		JSR	redraw_line_number ; update line number	with new commands
		JMP	position_edit_mode_cursor
; End of function set_primary_line_command



; checks if the	given line command is set on the current line.
;
; Entry:
; current_line_no_msb,
; current_line_no_lsb =	current	line
; X = line command slot	ID
;
; Exit:
; C set	if command is on current line.

is_current_line:			
					
		PHA
		LDA	current_line_no_msb
		CMP	$41,X
		BNE	loc_A22C
		LDA	current_line_no_lsb
		CMP	$42,X
		BNE	loc_A22C
		SEC
		BCS	loc_A22D

loc_A22C:				
					
		CLC

loc_A22D:				
		PLA

locret_A22E:				
					
		RTS
; End of function is_current_line



; check	availability of	line command slot.
;
; Entry:
; X = slot ID
;
; Exit:
; C set	if slot	is free.

is_line_command_slot_free:		
					
		LDA	$40,X		; get line command flag
		CMP	#$20 ; ' '      ; is it free?
		BEQ	locret_A22E	; branch taken if slot free.
					; return with C	set if taken.
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCS	locret_A22E	; branch taken if this slot is on the current line.
					; return with C	set if taken. (can change commands on current line.)
; slot is not free.
		CPX	#0		; was it slot ID 0 being checked?
		CLC			; clear	carry to indicate it isn't free
		BEQ	locret_A22E	; if it	was slot ID 0, just return with	carry clear
		JSR	beep		; otherwise, beep
		JMP	edit_mode_loop
; End of function is_line_command_slot_free


loc_A245:				
		CLC
		LDA	current_command_id
		ADC	#$40 ; '@'
		STA	byte_46
		LDA	current_line_no_msb
		STA	byte_47
		LDA	current_line_no_lsb
		STA	byte_48
		JMP	loc_AC08

loc_A258:				
		LDX	#0
		STX	readline_ptr_msb
		JSR	sub_A280
		LDX	#3
		JSR	sub_A280
		LDX	#6
		JSR	sub_A280
		LDX	#$C
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCC	loc_A276
		JSR	sub_B358
		JMP	loc_A216

loc_A276:				
		LDA	readline_ptr_msb
		BNE	loc_A216
		JSR	clear_line_commands
		JMP	loc_AC08



sub_A280:				
		LDA	$40,X
		CMP	#$20 ; ' '
		BEQ	locret_A2A0
		JSR	is_current_line	; checks if the	given line command is set on the current line.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	current	line
					; X = line command slot	ID
					;
					; Exit:
					; C set	if command is on current line.
		BCC	locret_A2A0
		CPX	#0
		BNE	loc_A29A
		LDX	#3

loc_A291:				
		LDA	$42,X
		STA	$3F,X
		DEX
		BNE	loc_A291
		LDX	#3

loc_A29A:				
		LDA	#$20 ; ' '
		STA	$40,X
		INC	readline_ptr_msb

locret_A2A0:				
		RTS
; End of function sub_A280




sub_A2A1:				
					
		LDA	byte_46
		CMP	#$54 ; 'T'
		BNE	loc_A2B1
		LDY	#1
		LDA	(oshwm),Y
		TAX
		INY
		LDA	(oshwm),Y
		TAY
		RTS

loc_A2B1:				
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	(unk_2F),Y
		TAX
		INY
		LDA	(unk_2F),Y
		TAY
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		RTS
; End of function sub_A2A1

; flags bits:
;
; bit 0 set when valid as the prefix of a variable name (BGET, BPUT,
; CLEAR, CLG, CLOSE, CLS, COUNT, END, ENDPROC, EOF, ERL, ERR, EXT,
; FALSE, HIMEM, LOMEM, NEW, OLD, PAGE, PI, POS, PTR, REPORT, RETURN,
; RND, RUN, STOP, TIME, TRUE, VPOS)
;
; bit 1 set when this keyword should set the RHS flag when tokenizing
; (BPUT, CALL, CHAIN, CLOSE, COLOUR, DIM, DRAW, ENVELOPE, FOR, GCOL,
; GOSUB, GOTO, HIMEM, IF, INPUT, LOAD, LOCAL, LOMEM, MODE, MOVE, NEXT,
; ON, OSCLI, PAGE, PLOT, PRINT, PROC, PTR, READ, RESTORE, SAVE, SOUND,
; TIME, TRACE, UNTIL, VDU, WIDTH)
;
; bit 2 set when this keyword should clear the LHS flag [ELSE, ERROR,
; LET, THEN]
;
; bit 3 set when this keyword must be followed by a valid symbol [FN,
; PROC]
;
; bit 4 set when byte_24 should be set [AUTO, DELETE, ELSE, GOSUB,
; GOTO, LIST, RENUMBER, RESTORE, THEN, TRACE]
;
; bit 5 set if tokenizing should stop [DATA, REM]

basic_token: .macro text,token,flags
                .text \text
                .byte \token
                .byte \flags
                .endm

token_table:	.basic_token "AND",$80,0 
		.basic_token "ABS",$94,0 
		.basic_token "ACS",$95,0 
		.basic_token "ADVAL",$96,0 
		.basic_token "ASC",$97,0 
		.basic_token "ASN",$98,0 
		.basic_token "ATN",$99,0 
		.basic_token "AUTO",$C6,$10 
		.basic_token "BGET",$9A,1 
		.basic_token "BPUT",$D5,3 
                .basic_token "COLOUR",$FB,2 
		.basic_token "COLOR",$FB,2 
		.basic_token "CALL",$D6,2 
		.basic_token "CHAIN",$D7,2 
		.basic_token "CHR$",$BD,0 
		.basic_token "CLEAR",$D8,1 
		.basic_token "CLOSE",$D9,3 
		.basic_token "CLG",$DA,1 
		.basic_token "CLS",$DB,1 
		.basic_token "COS",$9B,0 
		.basic_token "COUNT",$9C,1 
		.basic_token "DATA",$DC,$20 
		.basic_token "DEG",$9D,0 
		.basic_token "DEF",$DD,0 
                .basic_token "DELETE",$C7,$10 
		.basic_token "DIV",$81,0 
		.basic_token "DIM",$DE,2 
		.basic_token "DRAW",$DF,2 
                .basic_token "ENDPROC",$E1,1 
		.basic_token "END",$E0,1 
                .basic_token "ENVELOPE",$E2,2 
		.basic_token "ELSE",$8B,$14 
		.basic_token "EVAL",$A0,0 
		.basic_token "ERL",$9E,1 
		.basic_token "ERROR",$85,4 
		.basic_token "EOF",$C5,1 
		.basic_token "EOR",$82,0 
		.basic_token "ERR",$9F,1 
		.basic_token "EXP",$A1,0 
		.basic_token "EXT",$A2,1 
		.basic_token "FOR",$E3,2 
		.basic_token "FALSE",$A3,1 
		.basic_token "FN",$A4,8 
                .basic_token "GOTO",$E5,$12 
		.basic_token "GET$",$BE,0 
		.basic_token "GET",$A5,0 
		.basic_token "GOSUB",$E4,$12 
		.basic_token "GCOL",$E6,2 
                .basic_token "HIMEM",$93,$43 
		.basic_token "INPUT",$E8,2 
		.basic_token "IF",$E7,2 
                .basic_token "INKEY$",$BF,0 
		.basic_token "INKEY",$A6,0 
		.basic_token "INT",$A8,0 
		.basic_token "INSTR(",$A7,0 
		.basic_token "LIST",$C9,$10 
		.basic_token "LINE",$86,0 
                .basic_token "LOAD",$C8,2 
                .basic_token "LOMEM",$92,$43 
		.basic_token "LOCAL",$EA,2 
		.basic_token "LEFT$(",$C0,0 
		.basic_token "LEN",$A9,0 
		.basic_token "LET",$E9,4 
		.basic_token "LOG",$AB,0 
		.basic_token "LN",$AA,0 
		.basic_token "MID$(",$C1,0 
                .basic_token "MODE",$EB,2 
		.basic_token "MOD",$83,0 
		.basic_token "MOVE",$EC,2 
		.basic_token "NEXT",$ED,2 
		.basic_token "NEW",$CA,1 
		.basic_token "NOT",$AC,0 
		.basic_token "OLD",$CB,1 
		.basic_token "ON",$EE,2 
		.basic_token "OFF",$87,0 
		.basic_token "OR",$84,0 
                .basic_token "OPENIN",$8E,0 
                .basic_token "OPENOUT",$AE,0 
                .basic_token "OPENUP",$AD,0 
		.basic_token "OSCLI",$FF,2 
		.basic_token "PRINT",$F1,2 
                .basic_token "PAGE",$90,$43 
		.basic_token "PTR",$8F,$43 
		.basic_token "PI",$AF,1 
		.basic_token "PLOT",$F0,2 
		.basic_token "POINT(",$B0,0 
		.basic_token "PROC",$F2,$A 
		.basic_token "POS",$B1,1 
                .basic_token "RETURN",$F8,1 
                .basic_token "REPEAT",$F5,0 
                .basic_token "REPORT",$F6,1 
		.basic_token "READ",$F3,2 
		.basic_token "REM",$F4,$20 
		.basic_token "RUN",$F9,1 
		.basic_token "RAD",$B2,0 
                .basic_token "RESTORE",$F7,$12 
		.basic_token "RIGHT$(",$C2,0 
		.basic_token "RND",$B3,1 
                .basic_token "RENUMBER",$CC,$10 
		.basic_token "STEP",$88,0 
                .basic_token "SAVE",$CD,2 
		.basic_token "SGN",$B4,0 
		.basic_token "SIN",$B5,0 
		.basic_token "SQR",$B6,0 
		.basic_token "SPC",$89,0 
		.basic_token "STR$",$C3,0 
                .basic_token "STRING$(",$C4,0 
		.basic_token "SOUND",$D4,2 
		.basic_token "STOP",$FA,1 
		.basic_token "TAN",$B7,0 
		.basic_token "THEN",$8C,$14 
		.basic_token "TO",$B8,0 
		.basic_token "TAB(",$8A,0 
		.basic_token "TRACE",$FC,$12 
                .basic_token "TIME",$91,$43 
		.basic_token "TRUE",$B9,1 
		.basic_token "UNTIL",$FD,2 
		.basic_token "USR",$BA,0 
		.basic_token "VDU",$EF,2 
		.basic_token "VAL",$BB,0 
		.basic_token "VPOS",$BC,1 
		.basic_token "WIDTH",$FE,2 
                
		.basic_token "PAGE",$D0,0 
		.basic_token "PTR",$CF,0 
		.basic_token "TIME",$D1,0 
		.basic_token "LOMEM",$D2,0 
		.basic_token "HIMEM",$D3,0 

toggle_insert_overtype_command:		
		LDX	#0
		LDA	is_insert_mode	; 0=overtype 1=insert
		BNE	loc_A5D9
		LDX	#1

loc_A5D9:				
		STX	is_insert_mode	; 0=overtype 1=insert
		RTS
; End of function toggle_insert_overtype_command




scroll_command:				
		LDX	#1

loc_A5DE:				
		STX	is_scroll_on	; 1=scroll, 0=noscroll
		RTS
; End of function scroll_command


noscroll_command:			
		LDX	#0
		BEQ	loc_A5DE

background_edit_mode_command:		
		LDY	#0
		BEQ	loc_A5EB

foreground_edit_mode_command:		
		LDY	#1

loc_A5EB:				
		LDA	$A,Y
		CLC
		ADC	#1
		CMP	#8
		BCC	loc_A5F7
		LDA	#0

loc_A5F7:				
		STA	$A,Y
		JSR	set_palette
		RTS

run_or_exit_command: .proc
.if !ELECTRON
		LDA	#0
.else
		LDA #1
.endif
		STA	is_insert_mode	; 0=overtype 1=insert
		LDA	#$60 ; '`'
		STA	cursor_size
                JSR	reset_cursor_shape
                jsr print_next_string
                .byte 254       ; allow control chars
                .byte 26        ; reset text and graphics windows
                .byte 12        ; CLS (run_or_exit_command)
                .byte 255
		JSR	reset_keys_settings
		LDA	#228
		JSR	osbyte_with_x0_y0
		LDA	is_bad_program
                BNE	loc_A64D
run_or_exit_without_shutdown:
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_A64D
		LDX	#4		; ending position is by	default	after "OLD|M" part
		LDA	current_command_id
		CMP	#CMD_RUN	; is the command RUN?
		BNE	type_commands	; if not, just typing "OLD|M" is fine
		LDX	#0		; if RUN, type "OLD|MRUN|M"

type_commands:				
		LDA	#8
                STA	byte_3A		; position in "OLD|MRUN|M" string
                
		STX	byte_39		; ending position in string

type_commands_loop:			
		LDX	byte_3A
		DEX
		LDA	nur_dlo_string,X ; get next character
		TAY			; put char into	Y for OSBYTE
		LDX	#0		; 0 = keyboard buffer
		LDA	#138		; insert into keyboard buffer
		JSR	OSBYTE
		DEC	byte_3A		; next char in string
		LDA	byte_3A
		CMP	byte_39		; reached the end?
		BNE	type_commands_loop

loc_A64D:				
		LDX	#0
		LDY	#255
		LDA	#187		; get ROM containing BASIC
		JSR	OSBYTE
		LDA	#142		; enter	language ROM
                JSR	OSBYTE

.pend

exit_and_OLD: .proc
                ldx #4          ;"OLD|M"
                jmp run_or_exit_command.type_commands
.pend

exit_and_OLD_and_RUN: .proc
                ldx #0          ;"OLD|MRUN|M"
                jmp run_or_exit_command.type_commands
.pend

top_edit_mode_command:			
					
		LDA	#0
		STA	byte_2B
		STA	byte_2C

loc_A661:				
		LDA	#0
		STA	byte_3B
		SEC
		JSR	sub_9DEA
		JSR	sub_8314
		JSR	sub_9FD8
		JMP	edit_mode_loop

top_command:				
		JSR	sub_8314
		JMP	loc_9DA8

end_command:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		BEQ	loc_A681

end_edit_mode_command:			
					
		LDA	#1

loc_A681:				
		PHA
		LDA	#$FF
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		PLA
		TAX
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		TXA
		PHA
		JSR	sub_AA47
		LDA	#0
		STA	byte_3B
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		PLP
		JSR	sub_9DEA
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JSR	sub_9FD8
		JMP	edit_mode_loop

new_command:				
		JSR	clear_program

loc_A6BE:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#1
		BEQ	locret_A6C8
		JMP	loc_9DA8

locret_A6C8:				
		RTS

old_command .proc				
		JSR	is_program_empty ; sets	C if no	program
		BCC good_program
		LDY	#1
		LDA	#0
		STA	(oshwm),Y
		JSR	find_program
		BCC good_program
		JMP	language_entry.command_loop;ok

good_program:				
					
                JSR	sub_8314
                JMP	loc_A6BE
.pend
; End of function old_command


extend_statement_edit_mode_command .proc	
		LDX	screen_chars_in_line+1
		DEX
		BNE	loc_A6F4
		JMP	beep

loc_A6F4:				
		JSR	loc_AB3C
		JMP	position_edit_mode_cursor
.pend
                
swap_case_edit_mode_command: .proc
		LDX	cursor_offset_msb
		DEX
		BEQ	loc_A715
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		LDA	$400,X
		JSR	toggle_case
		STA	$400,X
		LDA	#1
		STA	byte_6B3
		TXA
		LDY	#0
		JSR	sub_A0B1

loc_A715:				
		JMP	cursor_right_edit_mode_command
.pend
                
renumber_edit_mode_command:		
					
		JSR	sub_8492
		JMP	loc_967A

undo_edit_mode_command:			
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_A726
		JMP	loc_9DA8

loc_A726:				
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		JSR	sub_AA17
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JSR	sub_9FD8
		JMP	position_edit_mode_cursor

copy_key_edit_mode_command:		
		LDX	#0
		LDA	cursor_size
		BNE	loc_A745
		LDX	#$40 ; '@'
		BNE	loc_A74B

loc_A745:				
		CMP	#$60 ; '`'
		BEQ	loc_A74B
		LDX	#$60 ; '`'

loc_A74B:				
		STX	cursor_size
		RTS

top_of_screen_edit_mode_command:	
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		JMP	loc_A661



cursor_left_edit_mode_command: .proc
		JSR	move_cursor_left
		BCC	loc_A768
		LDA	screen_chars_in_line+1
		STA	cursor_offset_msb
		LDA	screen_chars_in_line+0
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BNE	start_of_line.position_cursor

loc_A768:				
		SEC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		SBC	#1
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BCS	start_of_line.position_cursor
		DEC	cursor_offset_msb
                BEQ     start_of_line.position_cursor
                ; fall through?
                .pend

; returns C=0 if moved within line, or C=1 if potentially moved
; outside line.
move_cursor_left: .block
					
		CLC
		LDX	cursor_offset ;get cursor offset
		DEX                   ;
		BNE	locret_A783   ;taken if index >0 - can move
                                      ;left within line
		LDA	cursor_offset_msb ;
		BNE	locret_A783   ;taken if index >=256 - can move
                                      ;left within line
		JSR	move_cursor_to_previous_line      ;
		SEC

locret_A783:				
                RTS
                .bend

;-------------------------------------------------------------------------

cursor_right_edit_mode_command: .proc
		LDA	cursor_offset ; offset of cursor in detokenized buffer
		CMP	screen_chars_in_line+0
		BNE	move_cursor_right_within_line

		LDA	cursor_offset_msb   ;
		CMP	screen_chars_in_line+1
		BNE	move_cursor_right_within_line
		JSR	sub_B7A1
                ; fall through
                .pend

;-------------------------------------------------------------------------

start_of_line: .block
                jsr move_cursor_to_start_of_line
position_cursor:
                jmp position_edit_mode_cursor
                .bend

;-------------------------------------------------------------------------

move_cursor_to_start_of_line: .block
                ldx #0
                stx cursor_offset_msb
                inx
                stx cursor_offset
                rts
                .bend

;-------------------------------------------------------------------------

move_cursor_right_within_line: .proc
					
		INC	cursor_offset
		BNE	+
		INC	cursor_offset_msb
+					
		JMP	position_edit_mode_cursor
                .pend

;-------------------------------------------------------------------------

shift_cursor_left_edit_mode_command: .proc
                JMP start_of_line
                .pend

;-------------------------------------------------------------------------

extend_line_if_necessary: .proc
                ; If line is more than 256 chars on screen, no need to
                ; extend, because no line can be that long.
                lda screen_chars_in_line+1
                bne done

                lda cursor_offset
                cmp screen_chars_in_line+0
                bcc done
                beq done

                jsr loc_ab3c
                
done:
                rts
                
                .pend

;-------------------------------------------------------------------------

set_8bit_cursor_offset: .proc
                stx cursor_offset

                lda #0
                sta cursor_offset_msb

                jsr extend_line_if_necessary

                jmp position_edit_mode_cursor
                .pend
                
;-------------------------------------------------------------------------
                
shift_cursor_right_edit_mode_command: .proc
                ; Put the cursor one byte past the end of the line. No
                ; problem if this is past the limit.
                ldx byte_400
                inx
                jmp set_8bit_cursor_offset
                .pend

;-------------------------------------------------------------------------

move_to_prev_line_edit_mode_command: .proc
                jsr move_cursor_to_start_of_line
                jsr move_cursor_left
                jmp start_of_line
                .pend

;-------------------------------------------------------------------------

move_to_next_line_edit_mode_command: .proc	
					
		JSR	sub_B7A1
		JMP	start_of_line
                .pend

;-------------------------------------------------------------------------

move_cursor_down_on_screen: .proc
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	code_area_width
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BCC	locret_A7C9
		INC	cursor_offset_msb

locret_A7C9:				
		RTS
                .pend


cursor_down_edit_mode_command:

                ; Save old offset.
		LDA	cursor_offset
		PHA
		LDA	cursor_offset_msb
		PHA
                
		JSR	move_cursor_down_on_screen

                ; cursor_offset -= screen_chars_in_line
		SEC
		LDA	cursor_offset
		SBC	screen_chars_in_line+0
		STA	cursor_offset
		LDA	cursor_offset_msb
		SBC	screen_chars_in_line+1
		STA	cursor_offset_msb

                ; If cursor_offset>0, the movement took it off the end
                ; of the line, so sort that out.
		JSR	is_cursor_offset_negative_or_zero
		BCC	loc_A7EA ;taken if cursor_offset>0

                ; Cursor should remain on the same line, though it's
                ; now in the wrong place, so fix that up.
		PLA
		PLA
		JMP	offset_cursor_by_screen_chars_in_line

loc_A7EA:				
		PLA             ;
		TAX             ;cursor offset MSB
		PLA             ;
		TAY             ;cursor offset LSB
		LDA	cursor_offset 
		PHA
		LDA	cursor_offset_msb
		PHA
		STX	cursor_offset_msb
		STY	cursor_offset
                
		JSR	sub_B7A1
                
		PLA
		STA	cursor_offset_msb
		PLA
		STA	cursor_offset	; offset of cursor in detokenized buffer
		JMP	position_edit_mode_cursor



; returns C=1 if negative
is_cursor_offset_negative_or_zero: .proc
		SEC
		LDA	cursor_offset_msb
		BMI	locret_A812 ;taken if offset<0 - is negative
		BEQ	loc_A80D ;taken if (offset&0xff00)==0 - may be zero
		BNE	loc_A811    ;taken if offset>0 - not negative

loc_A80D:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		BEQ	locret_A812     ;taken if zero - is zero

loc_A811:				
		CLC

locret_A812:				
		RTS
                .pend


move_cursor_up_on_screen: .proc
		SEC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		SBC	code_area_width
		STA	cursor_offset	; offset of cursor in detokenized buffer
		BCS	locret_A81F
		DEC	cursor_offset_msb

locret_A81F:				
		RTS
                .pend


cursor_up_edit_mode_command: .proc
		JSR	move_cursor_up_on_screen

loc_A823:
		JSR	is_cursor_offset_negative_or_zero
		BCS	loc_A82B ;taken if offset is negative or zero
		JMP	position_edit_mode_cursor

loc_A82B:				
		JSR	move_cursor_down_on_screen ;undo the movement
		JSR	move_cursor_to_previous_line ;

                ; move cursor up again, then offset it by the area of
                ; the line on screen, so it ends up at the right place
                ; on the last row of the line.
		JSR	move_cursor_up_on_screen
                .pend

offset_cursor_by_screen_chars_in_line: .block
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	screen_chars_in_line+0
		STA	cursor_offset	; offset of cursor in detokenized buffer
		LDA	cursor_offset_msb
		ADC	screen_chars_in_line+1
		STA	cursor_offset_msb
		JMP	position_edit_mode_cursor
                .bend

;-------------------------------------------------------------------------
;
; Return some indication of how far the cursor is from the end of
; line.
;
; (len: $b)
; Line:   PRINT"FRED"
; Offset: 123456789abcdef
; Result: 000000000012333 (etc.)
;
; 0 = within line
; 1 = on last char
; 2 = one past last char
; 3 = outside line
;
; When A<3, cursor_offset_msb is 0.
;
; exit: A = distance as above
;       Z = set as per value of A
get_distance_from_eol: .proc
                lda cursor_offset_msb
                bne much_past_end

                lda cursor_offset
                sec
                sbc byte_400
                bcc within_line
                beq at_end
                cmp #1
                beq past_end
                
much_past_end:
                lda #3
                rts

past_end:
                lda #2
                rts
                
at_end:
                lda #1
                rts
                
within_line:
                lda #0
                rts


                .pend

;-------------------------------------------------------------------------

                .if ENABLE_DEBUG
print_debug_stuff_value: .proc
                pha             ;save value
                
                tya
                pha             ;save Y coordinate

                lda #160        ;read VDU variable value (AUG 179)
                ldx #$0a        ;right hand column (AUG 275)
                jsr osbyte

                ; make space for max 3 digits
                dex
                dex
                dex

                pla
                tay             ;Y coordinate
                jsr gotoxy

                lda #32
                jsr oswrch_x3
                lda #8
                jsr oswrch_x3

                pla
                tax
                ldy #0
                jsr itoa
                jmp print_itoa_result
                
oswrch_x3:
                jsr oswrch
                jsr oswrch
                jmp oswrch
                .pend
                .endif
                
                .if ENABLE_DEBUG
print_debug_stuff_edit_mode_command: .proc

                ; print distance from EOL
                jsr get_distance_from_eol
                ldy #0
                jsr print_debug_stuff_value

                ; print cursor offset
                lda cursor_offset
                ldy #1
                jsr print_debug_stuff_value

                ; print line length
                lda byte_400
                ldy #2
                jsr print_debug_stuff_value

                jmp position_edit_mode_cursor

                .pend
                .endif
                
;-------------------------------------------------------------------------

move_to_prev_stmt_edit_mode_command: .proc
                jsr get_distance_from_eol

                ; If past end of line, go to end of line.
                cmp #3
                beq move_to_next_stmt_edit_mode_command.go_to_eol

                ; If at start of line, go to end of previous line.
                ldx cursor_offset
                cpx #2
                bcc go_to_previous_eol

                ; Otherwise, look for previous ':' and pop the cursor
                ; after it.
                dex
loop:
                dex
                beq go_to_bol
                lda byte_400,x
                cmp #":"
                beq move_to_next_stmt_edit_mode_command.found_stmt
                bne loop        ;(jmp)
go_to_bol:
                jmp shift_cursor_left_edit_mode_command

go_to_previous_eol:
                jsr move_cursor_to_start_of_line
                jsr move_cursor_left
                jmp shift_cursor_right_edit_mode_command
                .pend

;-------------------------------------------------------------------------

move_to_next_stmt_edit_mode_command: .proc
                jsr get_distance_from_eol

                ; If at or past end of line, go to next line.
                cmp #2
                bcs go_to_next_line

                ; If right at end of line, go to end of line.
                cmp #1
                beq go_to_eol
                
                ldx cursor_offset
loop:
                lda byte_400,x
                cmp #":"
                beq found_stmt
                inx
                cpx byte_400
                bne loop
go_to_eol:
                jmp shift_cursor_right_edit_mode_command

go_to_next_line:
                jmp move_to_next_line_edit_mode_command

found_stmt:
                inx             ;skip the ':' itself
                jmp set_8bit_cursor_offset
                .pend
                
;-------------------------------------------------------------------------

move_to_top_of_screen_edit_mode_command: .proc
		JSR	sub_AA06
		LDA	byte_6C0
		STA	byte_2B
		LDA	byte_6C1
		STA	byte_2C
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	sub_A069
		JMP	start_of_line
                .pend

;-------------------------------------------------------------------------

move_to_bottom_of_screen_edit_mode_command: .proc
		JSR	sub_AA06
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		LDA	$6BF,X
		STA	byte_2C
		LDA	$6BE,X
		STA	byte_2B
		JSR	sub_BA69
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JMP	sub_9FD8
                .pend

;-------------------------------------------------------------------------

shift_cursor_up_edit_mode_command: .proc
		LDX	byte_6C0
		LDY	byte_6C1
		CPX	#0
		BNE	loc_A88E
		CPY	oshwm+1
		BNE	loc_A88E
		JMP	top_edit_mode_command

loc_A88E:				
		STX	byte_2B
		STY	byte_2C
		JMP	loc_AA41
                .pend

;-------------------------------------------------------------------------

shift_cursor_down_edit_mode_command:	
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		DEX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JMP	loc_9DA8

;-------------------------------------------------------------------------

position_edit_mode_cursor: .proc
					
		LDY	cursor_offset_msb
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_A8AF
		DEY

loc_A8AF:				
		DEX
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		TXA
		CLC
		ADC	#6
		TAX
		TYA
		CLC
		ADC	byte_3B
		TAY
		JMP	gotoxy
                .pend

;-------------------------------------------------------------------------

sub_A8C0: .proc ;happens when tokenizing an altered line?
					
		LDA	byte_6B3
		BNE	loc_A8C6
		RTS

loc_A8C6:				
		LDA	#0
		STA	byte_6A8 ;line isn't too long
		PHA              ;

loc_A8CC:				
		JSR	rstrip_and_cr_terminate_line
		CLC
		TXA             ;$401,X = CR
		ADC	#4      ;
		STA	unk_503
		LDA	#$D
		STA	unk_500 ;??
		LDA	current_line_no_msb
		STA	unk_501
		LDA	current_line_no_lsb
		STA	unk_502

                .if KEEP_A8C0_MEMMOVE

                ; copy from $401
		LDA	#<unk_401
		STA	byte_C
		LDA	#>unk_401
		STA	byte_D

                ; copy to $504 (unk_503+1, presumably??)
		LDA	#4
		STA	byte_E
		LDA	#5
		STA	byte_F

                ; copy 252 bytes - TODO fix
		LDX	#0
		LDY	#LINE_LENGTH_LIMIT
		JSR	memmove;constant; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

                .else

                ldx #0
copy_loop:
                lda unk_401,x
                sta unk_503+1,x
                inx
                cpx #LINE_LENGTH_LIMIT
                bne copy_loop

                .endif
                                        
		JMP	loc_A905

loc_A8FF:				
		LDA	#0
		STA	byte_6A8 ;line isn't too long
		PHA

loc_A905:				
		LDA	#<unk_500
		STA	byte_2B
		LDA	#>unk_500
		STA	byte_2C
		JSR	detokenize_line	; detokenize line and store result.
					;
					; Entry:
					; (byte_2B) points to line
					;
					; Exit:
					; $400 = line length
					; $401... = line text
					; unk_6A8 incremented if line too long
		LDA	byte_6A8        ;was there an overflow?
		BEQ	loc_A928        ;taken if not
		LDA	byte_6A7        ;erm...
		BNE	loc_A91F        ;erm...
		LDA	#$25    ; "Updates would make line too long"
		JMP	loc_859D

loc_A91F:				
		PLA
		BNE	loc_A929
		LDA	#1
		PHA
		JMP	loc_A8CC

loc_A928:				
		PLA

loc_A929:				
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

                                        
		LDY	#1
		LDA	(byte_2B),Y             ;get line # LSB
		CMP	current_line_no_msb ;is it the current line?
		BNE	loc_A943            ;no - going to have to
                                            ;insert
		INY                         ;
		LDA	(byte_2B),Y             ;get line # MSB
		CMP	current_line_no_lsb ;is it the current line?
		BEQ	loc_A947            ;yes, update in place

loc_A943:				
		LDX	#-1
		STX	byte_2C

loc_A947:				
		LDX	byte_2C
		INX
		STX	byte_25
		LDA	unk_503
		CPX	#0
		BEQ	loc_A958
		SEC
		LDY	#3
		SBC	(byte_2B),Y

loc_A958:				
		STA	byte_27
		LDA	#0
		SBC	#0
		STA	byte_28
		JSR	find_program
		JSR	check_for_room
		LDX	current_line_no_lsb
		LDY	current_line_no_msb
		INX
		BNE	loc_A96E
		INY

loc_A96E:				
		STX	byte_2C
		STY	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line

                ; source = line
		LDA	byte_2C
		STA	byte_D
		LDA	byte_2B
		STA	byte_C

                ; dest = 
		CLC
		ADC	byte_27
		STA	byte_E
		LDA	byte_2C
		ADC	byte_28
		STA	byte_F
		SEC
		LDA	TOP
		SBC	byte_C
		TAY
		LDA	TOP+1
		SBC	byte_D
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	#0
		STA	byte_C
		LDA	#5
		STA	byte_D
		LDY	#4
		LDX	byte_25
		BNE	loc_A9A6
		LDY	#0

loc_A9A6:				
		LDA	$2B,Y
		STA	byte_E
		LDA	$2C,Y
		STA	byte_F
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#1
		BEQ	loc_A9F3
		LDX	byte_2D
		LDA	byte_3B
		ASL
		TAY

loc_A9BD:				
		LDA	byte_E
		STA	byte_2B
		STA	$6C0,Y
		INY
		LDA	byte_F
		STA	byte_2C
		STA	$6C0,Y
		INY
		DEX
		BNE	loc_A9BD

loc_A9D0:				
		TYA
		LSR
		CMP	screen_height
		BEQ	loc_A9D9
		BCS	loc_A9F3

loc_A9D9:				
		LDA	$6C1,Y
		BEQ	loc_A9F3
		CLC
		LDA	$6C0,Y
		ADC	byte_27
		STA	$6C0,Y
		INY
		LDA	$6C0,Y
		ADC	byte_28
		STA	$6C0,Y
		INY
		BNE	loc_A9D0

loc_A9F3:				
					
		LDX	#0
		LDY	unk_503
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	byte_6A8
		BEQ	locret_AA05
		LDA	#$24 ; '$'
		JMP	loc_859D

locret_AA05:				
		RTS
                .pend

;-------------------------------------------------------------------------

sub_AA06:				
		LDA	byte_6B3
		PHA
		JSR	sub_A8C0
		PLA
		BNE	sub_AA17
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		CPX	byte_2D
		BEQ	locret_AA40
; End of function sub_AA06




sub_AA17:				
		LDA	screen_chars_in_line+0
		PHA
		LDA	screen_chars_in_line+1
		PHA
		JSR	sub_A069
		PLA
		TAX
		PLA
		CPX	screen_chars_in_line+1
		BNE	loc_AA2E
		CMP	screen_chars_in_line+0
		BNE	loc_AA2E
		JMP	sub_9F00

loc_AA2E:				
		LDA	byte_3B
		PHA
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B

locret_AA40:				
		RTS
; End of function sub_AA17


loc_AA41:				
		JSR	sub_AA47
		JMP	loc_9DA8



sub_AA47:				
		LDA	#$FF
		STA	unk_2E

loc_AA4B:				
		JSR	detokenize_one_line
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA			; A = line height
		CLC
		ADC	unk_2E		; Add to current coordinate
		CMP	screen_height	; Reached height of screen?
		BEQ	loc_AA5C	; taken	if reached screen height exactly
		BCS	loc_AA71	; taken	if gone	past screen height

loc_AA5C:				
		STA	unk_2E		; store	coordinate
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		BNE	loc_AA4B

loc_AA71:				
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JMP	save_line_number ; saves line number from program.
; End of function sub_AA47		;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number


; swap byte_2B with unk_2F, swap byte_2C with unk_30

sub_AA77:				
					
		LDX	byte_2B
		LDY	unk_2F
		STX	unk_2F
		STY	byte_2B
		LDX	byte_2C
		LDY	unk_30
		STX	unk_30
		STY	byte_2C
		RTS
; End of function sub_AA77


delete_key_command:			
		LDA	cursor_offset_msb
		BNE	loc_AA97
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		BEQ	locret_AACC
		DEX
		CPX	byte_400
		BCC	loc_AA9A

loc_AA97:				
		JMP	cursor_left_edit_mode_command

loc_AA9A:				
		LDX	#-1
		STX	byte_C
		DEX
		STX	byte_E
		LDA	#1
		JSR	sub_9FB2

loc_AAA6:				
		LDA	byte_400
		PHA
		DEC	byte_400
		LDY	byte_400
		LDA	#$20 ; ' '
		STA	$401,Y
		DEC	cursor_offset	; offset of cursor in detokenized buffer

loc_AAB7:				
		LDA	#1
		STA	byte_6B3
		PLA
		TAX
		LDY	#0
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		JSR	sub_A0B1
		JMP	position_edit_mode_cursor

loc_AAC8:				
					
		LDA	cursor_offset_msb
		BEQ	loc_AACD

locret_AACC:				
		RTS

loc_AACD:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_AAD8
		BCS	locret_AACC
		BCC	loc_AADC

loc_AAD8:				
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_AAA6

loc_AADC:				
		LDX	#0
		STX	byte_C
		TXA
		DEX
		STX	byte_E
		JSR	sub_9FB2
		INC	cursor_offset	; offset of cursor in detokenized buffer
		BNE	loc_AAA6

delete_to_end_of_line_edit_mode_command: .proc
		LDA	cursor_offset_msb
		BNE	locret_AACC
                
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_AAC8
		BCS	locret_AACC

                .if KEEP_DELETE_LINE_MEMSET
                
		CLC
		LDA	#1
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_C
		DEC	byte_C
		LDA	#4
		STA	byte_D
		SEC
		LDA	byte_400
		PHA
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		TAY
		INY
		LDX	#0

                lda byte_C
                sta del_C
                lda byte_D
                sta del_D
                lda byte_400
                sta del_400
                stx del_X
                sty del_Y
                
		LDA	#$20 ; ' '
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.

                .else

                lda byte_400
                pha

                ldx cursor_offset
                lda #$20
delete_loop:
                sta $400,X
                inx
                cpx byte_400
                bcc delete_loop
                beq delete_loop

                .endif
                                        
		LDX	cursor_offset	; offset of cursor in detokenized buffer
		DEX
		STX	byte_400
		JMP	loc_AAB7

                .pend

sub_AB1E:				
		LDA	screen_chars_in_line+1
		BNE	locret_AB2D
		LDA	screen_chars_in_line+0
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BEQ	loc_AB3C
		CMP	byte_400
		BEQ	loc_AB2E

locret_AB2D:				
		RTS

loc_AB2E:				
		LDA	is_insert_mode	; 0=overtype 1=insert
		BEQ	locret_AB2D
		LDX	byte_400
		LDA	$400,X
		CMP	#$20 ; ' '
		BEQ	locret_AB2D

loc_AB3C: ;nuts and bolts of the Extend Statement command??
		LDA	#4
		STA	byte_D
		LDA	#7
		STA	byte_F
		JSR	sub_ABDB
		LDA	screen_chars_in_line+0
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	screen_height
		ASL
		TAX
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_AB6A
		LDA	$6C1,X
		CMP	byte_2C
		BNE	loc_AB6A
		LDA	#1
		STA	unk_37
		JSR	sub_B8BD

loc_AB6A:				
		CLC
		LDA	byte_3B
		PHA
		ADC	byte_2D
		PHA
		TAY
		LDX	#0
		JSR	gotoxy
                LDA	#6
                jsr print_n_spaces
		CLC
		LDA	screen_chars_in_line+0
		ADC	code_area_width
		TAX
		LDA	#0
		ADC	#0
		TAY
		CLC
		LDA	screen_chars_in_line+0
		ADC	#1
		JSR	sub_A0B1
		PLA
		CMP	screen_height
		BEQ	loc_ABB0
		STA	byte_3B
		INC	byte_3B
		LDY	current_line_no_msb
		LDX	current_line_no_lsb
		INX
		BNE	loc_ABA8
		INY
		BMI	loc_ABB0

loc_ABA8:				
		STX	byte_2C
		STY	byte_2B
		SEC
		JSR	sub_9DEA

loc_ABB0:				
		PLA
		STA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		CLC
		PLA
		ADC	code_area_width
		STA	screen_chars_in_line+0
		TAX
		LDA	#0
		ADC	#0
		STA	screen_chars_in_line+1
		TAY
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		STY	byte_2D
		LDA	#7
		STA	byte_D
		LDA	#4
		STA	byte_F
; End of function sub_AB1E




sub_ABDB:				
		LDY	#0
		STY	byte_C
		STY	byte_E
		LDX	#1
		JMP	memmove		; move (maybe overlapping) memory regions.
; End of function sub_ABDB		;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size



rstrip_and_cr_terminate_line:  .proc
		LDX	byte_400	; check	line length
		BEQ	at_end		; taken	if line	empty

find_last_non_space_loop:		
		LDA	$400,X
		CMP	#$20 ; ' '
		BNE	at_end
		DEX
		BNE	find_last_non_space_loop

at_end:					
					
		LDA	#$D		; CR
		STA	$401,X		; store	at end of text
		JSR	setjmp
		LDX	#$FF

find_cr:				
		INX
		LDA	$401,X
		CMP	#$D
		BNE	find_cr
		RTS
                .pend


loc_AC08:				
		JSR	make_cursor_invisible
		LDA	byte_3B
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDX	#-1
		STX	byte_3B
		INX
		STX	byte_2B
		STX	byte_2C

loc_AC1D:				
		INC	byte_3B
		LDA	byte_3B
		CMP	screen_height
		BEQ	loc_AC28
		BCS	loc_AC5D

loc_AC28:				
		ASL
		TAX
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_AC38
		LDA	$6C1,X
		CMP	byte_2C
		BEQ	loc_AC1D

loc_AC38:				
		LDA	$6C0,X
		STA	byte_2B
		LDY	$6C1,X
		STY	byte_2C
		BEQ	loc_AC5D
		INY
		BNE	loc_AC54
		PLA
		TAX
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		PHA
		TXA
		PHA
		JMP	loc_AC57

loc_AC54:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number

loc_AC57:				
		JSR	redraw_line_number
		JMP	loc_AC1D

loc_AC5D:				
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		PLA
		STA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JMP	position_edit_mode_cursor



execute_edit_mode_command:		
		LDA	#$20 ; ' '
		CMP	byte_40		; slot ID 0 empty?
		BNE	loc_AC7E	; taken	if slot	not empty
		CMP	byte_46		; slot id 6 empty?
		BEQ	locret_AC7D	; taken	if slot	empty
		LDA	#6		; "Missing line	command"
		BNE	execute_edit_mode_command_error

locret_AC7D:				
		RTS

loc_AC7E:				
		STA	byte_6B3	; ?byte_6B3=$20
		JSR	sub_A8C0
		LDA	byte_40
		CMP	#$60 ; '`'
		BCS	loc_ACA7
		LDA	byte_43
		CMP	#$20 ; ' '
		BEQ	loc_AC94
		LDA	#$1A
		BNE	execute_edit_mode_command_error

loc_AC94:				
		LDA	byte_41
		STA	byte_44
		LDA	byte_42
		STA	byte_45
		LDA	#$20 ; ' '

loc_AC9E:				
		CLC
		ADC	byte_40
		STA	current_command_id
		JMP	execute_command	; unk_6BD = command to run

loc_ACA7:				
		CMP	byte_43
		BEQ	loc_ACD7
		LDY	byte_43
		CPY	#$20 ; ' '
		BNE	loc_ACC7
		CMP	#$64 ; 'd'
		BEQ	loc_ACB9
		LDA	#$1F		; "Incomplete line command"
		BNE	execute_edit_mode_command_error

loc_ACB9:				
		LDA	byte_46
		CMP	#$54 ; 'T'
		BEQ	loc_ACCC
		CMP	#$45 ; 'E'
		BEQ	loc_ACCC
		LDA	#$1C		; "Invalid delete command"
		BNE	execute_edit_mode_command_error

loc_ACC7:				
		LDA	#$1B		; "Incompatible	line commands"

execute_edit_mode_command_error:					
					
		JMP	loc_859D

loc_ACCC:				
					
		JSR	sub_A2A1
		STX	byte_44
		STY	byte_45
		LDA	#$20 ; ' '
		STA	byte_46

loc_ACD7:				
		JSR	sub_AD1A
		LDA	byte_46
		CMP	#$20 ; ' '
		BEQ	loc_AD09
		CMP	#$54 ; 'T'
		BEQ	loc_AD09
		CMP	#$45 ; 'E'
		BEQ	loc_AD09
		LDY	byte_48
		LDX	byte_47
		CMP	#$42 ; 'B'
		BEQ	loc_ACF4
		INY
		BNE	loc_ACF4
		INX

loc_ACF4:				
					
		TXA
		PHA
		LDX	#0
		JSR	sub_AD0E
		PLA
		BCC	loc_AD09
		LDX	#3
		JSR	sub_AD0E
		BCS	loc_AD09
		LDA	#$1D
		BNE	execute_edit_mode_command_error

loc_AD09:				
					
		LDA	#0
		JMP	loc_AC9E
; End of function execute_edit_mode_command




sub_AD0E:				
					
		CMP	$41,X
		BEQ	loc_AD13
		RTS

loc_AD13:				
		TYA
		CMP	$42,X
		BNE	locret_AD19
		CLC

locret_AD19:				
		RTS
; End of function sub_AD0E




sub_AD1A:				
					
		LDX	byte_41
		CPX	byte_44
		BCC	locret_AD38
		BEQ	loc_AD24
		BCS	loc_AD2A

loc_AD24:				
		LDY	byte_42
		CPY	byte_45
		BCC	locret_AD38

loc_AD2A:				
		LDY	byte_44
		STX	byte_44
		STY	byte_41
		LDX	byte_42
		LDY	byte_45
		STX	byte_45
		STY	byte_42

locret_AD38:				
		RTS
; End of function sub_AD1A


loc_AD39:				
		LDA	byte_46
		CMP	#$20 ; ' '
		BNE	loc_AD44
		LDA	#$1E
		JMP	loc_859D

loc_AD44:				
		LDA	byte_46
		PHA
		LDA	byte_47
		PHA
		LDA	byte_48
		PHA
		JSR	sub_AE78
		LDA	byte_6C0
		STA	byte_39
		LDA	byte_6C1
		STA	byte_3A
		LDA	current_command_id
		CMP	#$6D ; 'm'
		BNE	loc_AD74
		LDY	#1
		LDA	(byte_39),Y
		CMP	byte_41
		BEQ	loc_AD6D
		BCS	loc_AD87
		BCC	loc_AD74

loc_AD6D:				
		INY
		LDA	(byte_39),Y
		CMP	byte_42
		BCS	loc_AD87

loc_AD74:				
		LDY	#1
		LDA	(byte_39),Y
		CMP	byte_47
		BNE	loc_AD87
		INY
		LDA	(byte_39),Y
		CMP	byte_48
		BNE	loc_AD87
		LDA	byte_46
		CMP	#$42 ; 'B'

loc_AD87:				
		PHP
		JSR	find_program
		LDX	#3
		JSR	sub_AE93
		LDY	#3
		LDA	(byte_2B),Y
		LDX	#2
		JSR	sub_AE9E
		LDX	#0
		JSR	sub_AE93
		LDA	#0
		TAX
		JSR	sub_AE9E
		SEC
		LDA	unk_37
		SBC	byte_35
		STA	byte_27
		LDA	byte_38
		SBC	byte_36
		STA	byte_28
		PLA
		TAY
		PLA
		STA	byte_48
		PLA
		STA	byte_47
		PLA
		STA	byte_46
		TYA
		PHA
		JSR	check_for_room
		STA	unk_34
		STX	unk_33
		JSR	sub_AE78
		LDX	#6
		JSR	sub_AE93
		LDA	byte_46
		CMP	#$42 ; 'B'
		BNE	loc_ADDA
		JSR	sub_AEAA
		LDA	#0
		BEQ	loc_ADE3

loc_ADDA:				
		STA	unk_32
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDY	#3
		LDA	(byte_2B),Y

loc_ADE3:				
		LDX	#4
		JSR	sub_AE9E
		LDA	byte_3A
		CMP	byte_36
		BEQ	loc_ADF2
		BCS	loc_AE0D
		BCC	loc_ADFA

loc_ADF2:				
		LDA	byte_39
		CMP	byte_35
		BEQ	loc_ADFA
		BCS	loc_AE0D

loc_ADFA:				
		LDX	#2

loc_ADFC:				
		CLC
		LDA	byte_27
		ADC	$35,X
		STA	$35,X
		LDA	byte_28
		ADC	$36,X
		STA	$36,X
		DEX
		DEX
		BPL	loc_ADFC

loc_AE0D:				
		CLC
		LDA	byte_39
		STA	byte_C
		ADC	byte_27
		STA	byte_E
		LDA	byte_3A
		STA	byte_D
		ADC	byte_28
		STA	byte_F
		SEC
		LDA	TOP
		SBC	byte_39
		TAY
		LDA	TOP+1
		SBC	byte_3A
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	byte_35
		STA	byte_C
		LDA	byte_36
		STA	byte_D
		LDA	byte_39
		STA	byte_E
		LDA	byte_3A
		STA	byte_F
		LDX	byte_28
		LDY	byte_27
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	current_command_id
		CMP	#$6D ; 'm'
		BNE	loc_AE68
		LDA	unk_37
		STA	byte_C
		LDA	byte_38
		STA	byte_D
		LDA	byte_35
		STA	byte_E
		LDA	byte_36
		STA	byte_F
		SEC
		LDA	unk_33
		SBC	unk_37
		TAY
		LDA	unk_34
		SBC	byte_38
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_AE68:				
		JSR	clear_line_commands
		JSR	sub_8492
		LDA	unk_32
		BNE	loc_AE75
		JSR	sub_8314

loc_AE75:				
		JMP	loc_AF48



sub_AE78:				
		LDX	#$42 ; 'B'
		LDA	byte_46
		CMP	#$54 ; 'T'
		BEQ	loc_AE86
		CMP	#$45 ; 'E'
		BNE	locret_AE92
		LDX	#$41 ; 'A'

loc_AE86:				
		TXA
		PHA
		JSR	sub_A2A1
		STX	byte_47
		STY	byte_48
		PLA
		STA	byte_46

locret_AE92:				
		RTS
; End of function sub_AE78




sub_AE93:				
		LDY	$41,X
		STY	byte_2B
		LDY	$42,X
		STY	byte_2C
		JMP	find_line_by_number ; finds a line, given a line number
; End of function sub_AE93		;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line



sub_AE9E:				
		CLC
		ADC	byte_2B
		STA	$35,X
		LDA	#0
		ADC	byte_2C
		STA	$36,X

locret_AEA9:				
		RTS
; End of function sub_AE9E




sub_AEAA:				
		LDA	unk_30
		STA	unk_32
		BEQ	locret_AEA9
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JMP	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
; End of function sub_AEAA


loc_AEB9:				
		LDA	byte_46
		CMP	#$20 ; ' '
		BEQ	loc_AEC4
		LDA	#$1C
		JMP	loc_859D

loc_AEC4:				
		LDA	marked_line_no_msb
		CMP	byte_41
		BCC	loc_AEE3
		LDA	marked_line_no_lsb
		CMP	byte_42
		BCC	loc_AEE3
		LDA	marked_line_no_msb
		CMP	byte_44
		BCC	loc_AEE0
		BNE	loc_AEE3
		LDA	marked_line_no_lsb
		CMP	byte_45
		BEQ	loc_AEE0
		BCS	loc_AEE3

loc_AEE0:				
		JSR	sub_B358

loc_AEE3:				
		LDA	byte_6C0
		STA	byte_39
		LDA	byte_6C1
		STA	byte_3A
		LDY	#1
		LDA	(byte_39),Y
		CMP	byte_41
		BEQ	loc_AEF8
		JMP	loc_AEFD

loc_AEF8:				
		INY
		LDA	(byte_39),Y
		CMP	byte_42

loc_AEFD:				
		PHP
		JSR	find_program
		LDX	#3
		JSR	sub_AE93
		LDY	#3
		LDA	(byte_2B),Y
		LDX	#2
		JSR	sub_AE9E
		LDX	#0
		JSR	sub_AE93
		JSR	sub_AEAA
		LDA	unk_37
		STA	byte_C
		LDA	byte_38
		STA	byte_D
		LDA	byte_2B
		STA	byte_E
		LDA	byte_2C
		STA	byte_F
		SEC
		LDA	TOP
		SBC	unk_37
		TAY
		LDA	TOP+1
		SBC	byte_38
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_AF3D
		JMP	loc_9DA8

loc_AF3D:				
		JSR	clear_line_commands
		LDA	unk_32
		BNE	loc_AF48
		PLA
		JMP	top_edit_mode_command

loc_AF48:				
		PLP
		BCC	loc_AF4E
		JMP	loc_9DA8

loc_AF4E:				
		JMP	loc_967A

return_key_command:			
		LDA	#0
		PHA

loc_AF54:				
		LDA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented

loc_AF5C:				
		JSR	advance_2b_to_next_line
		LDY	#2
		LDA	(byte_2B),Y
		STA	byte_38
		DEY
		LDA	(byte_2B),Y
		STA	unk_37
		BPL	loc_AF70
		LDA	#$A
		BNE	loc_AF72

loc_AF70:				
		LDA	#1

loc_AF72:				
		TAY
		CLC
		ADC	current_line_no_lsb
		STA	byte_3A
		LDA	#0
		ADC	current_line_no_msb
		STA	byte_39
		BPL	loc_AF8C
		DEY
		BNE	loc_AF70

loc_AF83:				
		JSR	sub_8492
		PLA
		LDA	#1
		PHA
		BNE	loc_AF54

loc_AF8C:				
		LDX	byte_39
		LDY	byte_3A
		CPX	unk_37
		BNE	loc_AF9A
		CPY	byte_38
		BNE	loc_AF9A
		BEQ	loc_AF83

loc_AF9A:				
		PLA
		STA	byte_36
		TXA
		PHA
		TYA
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	byte_36
		PHA
		STX	current_line_no_msb
		STY	current_line_no_lsb
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		LDA	#1
		STA	byte_400
		LDA	#$20 ; ' '
		STA	unk_401

loc_AFBB:				
		STX	byte_36
		LDA	byte_6B3
		PHA
		LDA	#1
		STA	byte_6B3
		LDA	#-1
		STA	byte_2C
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	sub_A8C0
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_6B3
		PLA
		BEQ	loc_AFE9
		CMP	#1
		BEQ	loc_B03B
		CMP	#3
		BNE	loc_B01B
		JMP	end_edit_mode_command

loc_AFE9:				
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA
		CLC
		ADC	byte_3B
		ADC	byte_36
		SEC
		SBC	#1
		CMP	screen_height
		BEQ	loc_B025
		BCC	loc_B025
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		PLA
		PLA
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line

loc_B00D:				
		LDA	is_scroll_on	; 1=scroll, 0=noscroll
		PHA
		LDA	#1
		STA	is_scroll_on	; 1=scroll, 0=noscroll
		JSR	move_to_next_line_edit_mode_command
		PLA
		STA	is_scroll_on	; 1=scroll, 0=noscroll
		RTS

loc_B01B:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		STA	byte_3B
		CLC
		BCC	loc_B026

loc_B025:				
		SEC

loc_B026:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	sub_9DEA
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JSR	sub_9FD8
		JMP	edit_mode_loop

loc_B03B:				
		PLA
		PLA
		PLA
		TAX
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		PHA
		TXA
		PHA
		JSR	sub_9698
		BCS	loc_B05C

loc_B04C:				
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		JMP	sub_9FD8

loc_B05C:				
		JSR	sub_AA47
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JMP	loc_B04C

it_cmd:					
		JSR	sub_B0A3
		LDY	#1
		LDA	(oshwm),Y
		BNE	loc_B07F
		INY
		LDA	(oshwm),Y
		CMP	#2
		BCS	loc_B07F
		JSR	sub_8492

loc_B07F:				
		LDA	#2
		PHA
		LDX	#0
		LDY	#1
		STX	current_line_no_msb
		STY	current_line_no_lsb
		JMP	loc_AF9A

ie_cmd:					
		JSR	sub_B0A3
		LDA	#3
		PHA
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JMP	loc_AF5C



sub_B0A3:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_B0A9
		RTS

loc_B0A9:				
		JMP	loc_9DA8
; End of function sub_B0A3




; TODO - misnamed - this looks actually more like it's the entry point
; for sub_B196.
setjmp: .proc
		TSX
		STX	old_stack_ptr
		LDA	#<unk_401
		STA	byte_27
		LDA	#>unk_401
		STA	byte_28
		JMP	sub_B196
                .pend



; Remove bytes from current line and replace them with a new value.
;
; A = replacement byte.
; Y = number of bytes to remove - 1
; (byte_27) points to where to remove them from.
                
sub_B0BB: .proc
					
		PHA             ;save original A

                ; (byte_25) is source pointer: (byte_27)+Y
		CLC            
		TYA             
		ADC	byte_27 
		STA	byte_25 
		LDY	#0      
		TYA             
		ADC	byte_28
		STA	byte_26
		PLA
                
                ; store original A in program
		STA	(byte_27),Y

                ; keep moving bytes from source to dest until eol.
loc_B0CC:				
		INY
		LDA	(byte_25),Y
		STA	(byte_27),Y
		CMP	#$D
		BNE	loc_B0CC
                
		RTS
                .pend




sub_B0D6: .proc
		AND	#$F     ;turn ASCII digit into its value
		STA	byte_21 ;save in LSB
		STY	byte_22 ;Y=0 on entry here... it's only called
                                ;from one place

loc_B0DC:				
		INY                 ;next byte
		LDA	(byte_27),Y ;get next byte from input
		CMP	#'9'+1      ;is it a digit?
		BCS	loc_B119    ;taken if not a digit
		CMP	#'0'        ;is it a digit?
		BCC	loc_B119    ;taken if not a digit
		AND	#$F         ;turn it ints its digit value
		PHA                 ;save
		LDX	byte_22     ;
                
                ; shift value left 2, bailing out if negative.
		LDA	byte_21     
		ASL                 
		ROL	byte_22     
		BMI	loc_B114    
		ASL                 
		ROL	byte_22     
		BMI	loc_B114
                
                ; add original value, giving value*5. 
		ADC	byte_21 ;carry clear at this point...
		STA	byte_21     
		TXA
		ADC	byte_22

                ; shift value left 1, giving value*10, bailing out if
                ; negative or carry.
		ASL	byte_21
		ROL
		BMI	loc_B114
		BCS	loc_B114
		STA	byte_22

                ; add new digit in.
		PLA            
		ADC	byte_21 ;carry clear at this point...
		STA	byte_21
		BCC	loc_B0DC
		INC	byte_22
		BPL	loc_B0DC
		PHA

loc_B114:				
		PLA
		LDY	#0      ;restore Y value
		SEC             ;
		RTS
                .pend

loc_B119:				
		JSR	ensure_4_bytes_spare
		DEY
		LDA	#LINE_NUMBER_TOKEN
		JSR	sub_B0BB
		LDA	byte_27
		ADC	#2
		STA	byte_25
		LDA	byte_28
		ADC	#0
		STA	byte_26

loc_B12E:				
		LDA	(byte_27),Y
		STA	(byte_25),Y
		DEY
		BNE	loc_B12E
		LDY	#3
		LDA	byte_22
		ORA	#$40 ; '@'
		STA	(byte_27),Y
		DEY
		LDA	byte_21
		AND	#$3F ; '?'
		ORA	#$40 ; '@'
		STA	(byte_27),Y
		DEY
		LDA	byte_21
		AND	#-$40 ;	'�'
		STA	byte_21
		LDA	byte_22
		AND	#-$40 ;	'�'
		LSR
		LSR
		ORA	byte_21
		LSR
		LSR
		EOR	#$54 ; 'T'
		STA	(byte_27),Y
		JSR	increment_27
		JSR	increment_27
		JSR	increment_27
		LDY	#0

clc_then_rts:				
		CLC
		RTS
; End of function sub_B0D6



; sets C if:
;
; A>='a'&&A<='z'
; A=='_'
; A==GBP
; A>='A'&&A<='Z'
; A>='0'&&A<='9'

issymchar: .proc
		CMP	#'z'+1
		BCS	clc_then_rts
                CMP	#'_' ;cover '_' (0x5f), GBP (0x60) and lower-case
                             ;letters (0x61...)
		BCS	isdigit.done
		CMP	#'Z'+1
		BCS	clc_then_rts
		CMP	#'A'
		BCS	isdigit.done
                ; fall through
                .pend



; sets C if A is a digit char

isdigit:.proc			
		CMP	#'9'+1
		BCS	clc_then_rts
		CMP	#'0'

done:
		RTS
                .pend
; End of function isdigit



; sets C if A is a number char (0-9 or '.')

isnumchar:				
		CMP	#'.'
		BNE	isdigit		; sets C if A is a digit char
		RTS
; End of function isnumchar

		.byte  $B1 ; �
		.byte  $27 ; '



increment_27:				
		JSR	ensure_1_byte_spare
		INC	byte_27
		BNE	isdigit.done
		INC	byte_28
		RTS
; End of function increment_27




fetch_next_byte:			
		JSR	increment_27
		LDA	(byte_27),Y
		RTS
; End of function fetch_next_byte




; (byte_27) always points to unk_401 - the input buffer.
sub_B196: .proc
		LDY	#0
		STY	byte_23
		STY	byte_24

sub_B196_scan_line:				
		LDA	(byte_27),Y   ;get byte from input
		CMP	#$D           ;end of line?
		BEQ	isdigit.done   ;taken if end of line
		CMP	#' '          ;
		BNE	check_for_hex ;taken if not space

next_input_byte:				
		JSR	increment_27       ;next byte in input
		BNE	sub_B196_scan_line ;JMP, in effect

check_for_hex:				
		CMP	#'&'             ;hex value?
		BNE	check_for_string ;taken if not a hex value
                ; handle hex value
check_hex_value:			
		JSR	fetch_next_byte ;get byte from input
		JSR	isdigit		;sets C if A is a digit char
		BCS	check_hex_value ;taken if digit - i.e., good
                                        ;hex char
		CMP	#'A'            ;
		BCC	sub_B196_scan_line ;taken if A<'A' - i.e., bad
                                           ;hex char
		CMP	#'F'+1             ;
		BCC	check_hex_value ;taken if A>='A' && A<='F' -
                                        ;i.e., good hex char
		BCS	sub_B196_scan_line ;taken if bad hex char

check_for_string:			
		CMP	#'"'
		BNE	check_for_colon ;taken if not string
                ; handle string
loc_B1C5:				
		JSR	fetch_next_byte ;get byte from input
		CMP	#'"'            ;
		BEQ	next_input_byte       ;taken if end of string
		CMP	#$D             ;end of line?
		BNE	loc_B1C5        ;taken if not end of line
		RTS                     ;...

check_for_colon:			
		CMP	#':'
		BNE	check_for_comma ;taken if not colon
                ; handle colon
		STY	byte_23         ;reset
		STY	byte_24         ;reset
		BEQ	next_input_byte       ;JMP, in effect

check_for_comma:			
		CMP	#','      ;
		BEQ	next_input_byte ;taken if comma
		CMP	#'*'      ;
		BNE	check_for_dot ;taken if not *
                ; handle * operator or * command
		LDA	byte_23
		BNE	loc_B228 ;taken if the * was on the RHS - so
                                 ;it's the * operator, not a * command

                ; stop tokenizing on * command.
		RTS

check_for_dot:				
		CMP	#'.'
		BEQ	got_dot  ;taken if dot
		JSR	isdigit  ;sets C if A is a digit char
		BCC	check_for_token ;taken if not digit char
                ; handle digit char
		LDX	byte_24  ;
		BEQ	got_dot  ;taken if at start of statement
		JSR	sub_B0D6 ;
		BCC	loc_B22E ;but sub_B0D6 always leaves with
                                 ;carry set...?

got_dot:				
		LDA	(byte_27),Y
		JSR	isnumchar	;sets C if A is a number char (0-9 or '.')
		BCC	loc_B207        ;taken if not number char
		JSR	increment_27    ;next input byte
		JMP	got_dot         ;loop

loc_B207:				
		LDX	#255
		STX	byte_23 ;now on RHS
		STY	byte_24 ;not start of statement
		JMP	sub_B196_scan_line

loc_B210:				
		JSR	issymchar	; sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	�)
		BCC	loc_B228        ;taken if not valid symbol char

loc_B215:				
		LDY	#0

loc_B217:
                ; find next non-symbol char
		LDA	(byte_27),Y
		JSR	issymchar	;sets C if A is a valid symbol	char (A-Z, a-z,	0-9, _,	�)
		BCC	loc_B207        ;taken if not valid symbol char
		JSR	increment_27    ;next input char
		JMP	loc_B217        ;

check_for_token:				
		CMP	#'A'
		BCS	check_for_token_2

loc_B228:				
		LDX	#255
		STX	byte_23
		STY	byte_24

loc_B22E:				
		JMP	next_input_byte

check_for_token_2:
		CMP	#'X'
		BCS	loc_B210 ; bail if >=X, since no tokens start
                                 ; with X, Y or Z
		LDX	#<token_table
		STX	byte_25
		LDX	#>token_table
		STX	byte_26

loc_B23D:				
		CMP	(byte_25),Y	; compare first char to char
                                        ; in table
		BCC	loc_B217	; taken if A<char in table -
                                        ; the tokens are sorted at
                                        ; least by first char, so if
                                        ; it wasn't found by now, it
                                        ; won't be
		BNE	find_token_byte	; taken if first char is
                                        ; otherwise different

compare_chars_loop:
		INY			; next char
		LDA	(byte_25),Y	; get next char	from table
		BMI	found_token	; taken	if token value found
		CMP	(byte_27),Y	; compare to byte in input
		BEQ	compare_chars_loop

                ; input differs - is it abbreviated?
		LDA	(byte_27),Y	; get byte from	input
		CMP	#'.'            ; is it an abbreviation?
		BEQ	skip_dot	; taken	if abbreviated

find_token_byte:			
		INY
		LDA	(byte_25),Y
		BPL	find_token_byte

                ; after token $FE come the LHS tokens for PAGE, PTR,
                ; TIME, LOMEM and HIMEM.
		CMP	#$FE		; reached WIDTH	in the table?
		BNE	next_token_in_table ; taken if not WIDTH
		BCS	loc_B215	; taken if WIDTH... though why
                                        ; not BEQ?

skip_dot:				
		INY

find_token_end:				
		LDA	(byte_25),Y
		BMI	found_token ;found the token number
                ; add 1 to address
		INC	byte_25
		BNE	find_token_end
		INC	byte_26
		BNE	find_token_end

next_token_in_table:
                ; add Y+2 to (byte_25) - skip token byte and flags
                ; byte.
		SEC             
		INY             
		TYA
		ADC	byte_25
		STA	byte_25
		BCC	loc_B275
		INC	byte_26

loc_B275:		
		LDY	#0          ;reset Y
		LDA	(byte_27),Y ;restore input byte
		JMP	loc_B23D    ;back to the tokenization
                                    ;process...

found_token:				
		TAX                 ;store token number
		INY                 ;next table byte
		LDA	(byte_25),Y ;get flags
		STA	byte_21     ;
		DEY                 ;restore Y
		LSR                 ;get bit 0
		BCC	is_token    ;taken if flags bit 0 clear - this
                                    ;is definitely a token

                ; check if this is actually a variable name
		LDA	(byte_27),Y ;get input byte
		JSR	issymchar ; sets C if A is a valid symbol char
                                  ; (A-Z, a-z, 0-9, _, �)
		BCS	loc_B215  ;taken if valid symbol char - this
                                  ;is the prefix of a variable name,
                                  ;not a token

is_token:				
		TXA              ;get token value
		BIT	byte_21  ;test flags byte
		BVC	loc_B299 ;taken if flags byte bit 6 clear

                ; swap from RHS to LHS token for PAGE, PTR, TIME,
                ; LOMEM or HIMEM.
		LDX	byte_23  ;test expression side
		BNE	loc_B299 ;taken if on RHS
		CLC              ;
		ADC	#$40     ;swap token

loc_B299:				
		DEY              ;count of chars to replace
		JSR	sub_B0BB ;replace chars with the token
		LDY	#0       ;
		LDX	#255     ;
		LDA	byte_21  ;get flags byte
		LSR              ;C = flags bit 0
		LSR              ;C = flags bit 1
		BCC	loc_B2AB ;taken if bit 1 clear
                ; set tokenizing flags
		STX	byte_23  ;set the RHS flag
		STY	byte_24

loc_B2AB:				
		LSR              ;C = flags bit 2
		BCC	loc_B2B2 ;taken if bit 2 clear
                ; reset tokenizing flags
		STY	byte_23
		STY	byte_24

loc_B2B2:				
		LSR              ;C=flags bit 3
		BCC	loc_B2C6 ;taken if bit 3 clear
                ; scan PROC/FN name
		PHA              ;save remaining bits
		INY              ;Y=1

PROC_or_FN_name:				
		LDA	(byte_27),Y ;get next input byte
		JSR	issymchar ; sets C if A is a valid symbol char
                                  ; (A-Z, a-z, 0-9, _, �)
		BCC	PROC_or_FN_name_done  ;taken if not a valid symbol char
		JSR	increment_27 ;next input byte
		JMP	PROC_or_FN_name     ;keep going

PROC_or_FN_name_done:				
		DEY             ;ignore the terminating char
		PLA             ;get flags back again...

loc_B2C6:				
		LSR              ;C=flags bit 4
		BCC	loc_B2CB ;taken if bit 4 clear
		STX	byte_24

loc_B2CB:				
		LSR                 ;C=flags bit 5
		BCS	stop_tokenizing ;taken if bit 5 set
		JMP	next_input_byte

stop_tokenizing:				
		RTS
                .pend




ensure_1_byte_spare:			
		PHP
		PHA
		LDA	#1
		BNE	loc_B2DC	; JMP, in effect
; End of function ensure_1_byte_spare




ensure_4_bytes_spare:			
		PHP
		PHA
		LDA	#4

loc_B2DC:				
		CLC
		ADC	byte_27
		BCS	longjmp ;taken if carry - which means
                                ;definitely no space
		CMP	#256-4
		BEQ	loc_B2E7 ;taken if it just fits
		BCS	longjmp  ;taken if it doesn't fit

loc_B2E7:				
		PLA
		PLP
		RTS

longjmp:				
					
		LDY	#0
		LDA	#$D
		STA	(byte_27),Y
		STA	byte_6A8
		LDX	old_stack_ptr
		TXS
		RTS
; End of function ensure_4_bytes_spare




mode_command:				
                ldy byte_3E
                cpy #$ff
                beq loc_B2FF
                ldy byte_3F
		BEQ	loc_B304

loc_B2FF:				
                ; TODO: can get rid of this bit???
					
		LDA	#$D		; "Only	modes 0,1,3,4,6,7 are valid"
		JMP	loc_859D

loc_B304:				
		LDX	byte_3E
		JSR	get_HIMEM_for_mode_X
		JSR	find_program
		LDX	byte_15
		BEQ	locret_B329
		JSR	clear_5B1_to_600
		LDA	#$E		; "No room for this mode"
		JMP	loc_859D

locret_B329:
                lda #22
                jsr oswrch
                lda byte_3E
                jsr oswrch
		RTS
; End of function mode_command


; mode_edit_mode_command:			
;                 LDY	screen_mode
                

; loc_B32C:				
; 		DEY
; 		CPY	#2
; 		BEQ	loc_B32C
; 		CPY	#5
; 		BEQ	loc_B32C
; 		CPY	#-1
; 		BNE	loc_B33B
; 		LDY	#7

; loc_B33B:				
; 		STY	screen_mode
; 		JSR	validate_mode
; 		JSR	find_program
; 		LDA	byte_15
; 		BEQ	loc_B34A
; 		JMP	language_entry.loc_814D

; loc_B34A:				
; 		JSR	loc_9D2D
; 		JSR	is_program_empty ; sets	C if no	program
; 		BCS	loc_B355
; 		JMP	loc_967A

; loc_B355:				
; 		JMP	loc_9DA8



sub_B358:				
					
		LDA	#$FF
		STA	marked_line_no_msb
		RTS
; End of function sub_B358




mark_edit_mode_command:			
					
		LDA	current_line_no_msb
		STA	marked_line_no_msb
		LDA	current_line_no_lsb
		STA	marked_line_no_lsb
		JMP	loc_AC08
; End of function mark_edit_mode_command




goto_edit_mode_command:			
					
		JSR	sub_B37B
		BEQ	loc_B370
		JMP	beep

loc_B370:				
					
		LDA	marked_line_no_msb
		STA	current_line_no_msb
		LDA	marked_line_no_lsb
		STA	current_line_no_lsb
		JMP	loc_9DA8
; End of function goto_edit_mode_command




sub_B37B:				
					
		LDA	marked_line_no_msb
		CMP	#-1
		BNE	loc_B384
		LDA	#1
		RTS

loc_B384:				
		STA	byte_2B
		LDA	marked_line_no_lsb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	(byte_2B),Y
		CMP	marked_line_no_msb
		BNE	locret_B39A
		INY
		LDA	(byte_2B),Y
		CMP	marked_line_no_lsb

locret_B39A:				
		RTS
; End of function sub_B37B


goto_command:				
		JSR	sub_B37B
		BNE	loc_B3A6
		JSR	init_edit_mode
		JMP	loc_B370

loc_B3A6:				
		LDA	#$22 ; '"'
		JMP	loc_859D

number_command:				
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	#0
		STA	unk_1E
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_B3BB:				
		LDY	#1
		LDA	(byte_2B),Y
		BPL	loc_B3DB
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		LDA	unk_1E
		AND	#1
		BEQ	loc_B3D2
		LDA	#$10

loc_B3CF:				
		JMP	loc_859D

loc_B3D2:				
		LDA	unk_1E
		BNE	locret_B3DA
		LDA	#$F     ;"No references to labels were found"?
		BNE	loc_B3CF

locret_B3DA:				
		RTS

loc_B3DB:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#5
		STA	byte_F
		LDX	#0
		LDY	#3
		LDA	(byte_2B),Y
		TAY
		INY
		BNE	loc_B3F9
		INX

loc_B3F9:				
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	#0
		STX	cursor_offset_msb
		STX	unk_37
		STX	byte_36
		STX	byte_6B3
		INX
		STX	cursor_offset	; offset of cursor in detokenized buffer
		LDA	#4
		STA	unk_1F
		LDA	#5
		STA	byte_20

loc_B412:				
		SEC
		LDA	unk_503
		SBC	#4
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BCC	loc_B476
		LDY	#0
		LDA	(unk_1F),Y
		CMP	#$20 ; ' '
		BEQ	loc_B461
		CMP	#$22 ; '"'
		BNE	loc_B430
		STA	byte_36
		LDA	unk_37
		EOR	#1
		STA	unk_37

loc_B430:				
		LDA	unk_37
		BNE	loc_B461
		LDA	(unk_1F),Y
		CMP	#$f4 ;-$C ; '�' REM
		BEQ	loc_B476
		CMP	#$DC ; -$24 ;	'�' DATA
		BEQ	loc_B476
		CMP	#$2A ; '*'
		BNE	loc_B446
		LDX	byte_36
		BEQ	loc_B476

loc_B446:				
		CMP	#$3A ; ':'
		BNE	loc_B44E
		STY	byte_36
		BEQ	loc_B461

loc_B44E:				
		LDX	#1
		STX	byte_36
		CMP	#$8D ; -$73 ;	'�' line number
		BNE	loc_B45A
		LDX	#4
		BNE	loc_B463

loc_B45A:				
		CMP	#$40 ; '@'
		BNE	loc_B461
		JMP	loc_B4B7

loc_B461:				
		LDX	#1

loc_B463:				
		CLC
		TXA
		ADC	unk_1F
		STA	unk_1F
		BCC	loc_B46D
		INC	byte_20

loc_B46D:				
		CLC
		TXA
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		JMP	loc_B412

loc_B476:				
		LDA	byte_6B3
		BEQ	loc_B47E
		JSR	sub_B4A7

loc_B47E:				
		JSR	advance_2b_to_next_line
		JMP	loc_B3BB



sub_B484:				
		CMP	#'0'
		BCC	loc_B49C
		CMP	#':'
		BCC	loc_B49E
		CMP	#'A'
		BCC	loc_B49C
		CMP	#'['
		BCC	loc_B49E
		CMP	#'_'
		BCC	loc_B49C
		CMP	#'{'
		BCC	loc_B49E

loc_B49C:				
		CLC
		RTS

loc_B49E:				
		SEC
		RTS
; End of function sub_B484




sub_B4A0:				
		LDY	#1
		LDA	($C),Y
		JMP	sub_B484
; End of function sub_B4A0


;-------------------------------------------------------------------------

sub_B4A7: .block
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_a8c0.loc_A8FF
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		RTS
                .bend

;-------------------------------------------------------------------------

loc_B4B7: .proc
		LDA	unk_1F
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		JSR	sub_B4A0
		BCS	loc_B4C7

loc_B4C4:				
		JMP	loc_B461

loc_B4C7:				
		LDA	#0
		STA	unk_33
		LDA	oshwm+1
		STA	unk_34

loc_B4CF:				
		LDY	#1
		LDA	(unk_33),Y
		BPL	loc_B4DD
		LDA	unk_1E
		ORA	#1
		STA	unk_1E
		BNE	loc_B4C4

loc_B4DD:				
		LDA	unk_33
		PHA
		LDA	unk_34
		PHA
		LDY	#4

loc_B4E5:				
		LDA	(unk_33),Y
		CMP	#$20 ; ' '
		BNE	loc_B4EF
		INY
		JMP	loc_B4E5

loc_B4EF:				
		CMP	#$F4 ; -$C ; '�'
		BNE	loc_B52F
		INY

loc_B4F4:				
		LDA	(unk_33),Y
		CMP	#$20 ; ' '
		BNE	loc_B4FE
		INY
		JMP	loc_B4F4

loc_B4FE:				
		CLC
		TYA
		ADC	unk_33
		STA	unk_33
		BCC	loc_B508
		INC	unk_34

loc_B508:				
		LDY	#0
		LDA	(unk_33),Y
		CMP	#$40 ; '@'
		BEQ	loc_B512
		BNE	loc_B52F

loc_B512:				
		INY

loc_B513:				
		LDA	(unk_33),Y
		CMP	(unk_1F),Y
		BNE	loc_B521
		JSR	sub_B484
		BCC	loc_B532
		INY
		BNE	loc_B513

loc_B521:				
		JSR	sub_B484
		BCS	loc_B52F
		LDA	(unk_1F),Y
		JSR	sub_B484
		BCS	loc_B52F
		BCC	loc_B532

loc_B52F:				
		CLC
		BCC	loc_B533

loc_B532:				
		SEC

loc_B533:				
		PLA
		STA	unk_34
		PLA
		STA	unk_33
		BCS	loc_B53E
		JMP	loc_B5A3

loc_B53E:				
		STY	byte_35
		LDA	unk_503
		SEC
		SBC	byte_35
		CLC
		ADC	#4
		BCS	loc_B59E
		STA	unk_503
		CLC
		LDA	unk_1F
		ADC	byte_35
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		STA	byte_F
		CLC
		LDA	unk_1F
		ADC	#4
		STA	byte_E
		SEC
		LDA	unk_503
		SBC	cursor_offset	
		SEC
		SBC	#6
		TAY
		LDX	#0
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#1
		LDA	(unk_33),Y
		TAX
		INY
		LDA	(unk_33),Y
		TAY
		JSR	sub_85D8
		PHA
		TYA
		LDY	#3
		STA	(unk_1F),Y
		DEY
		TXA
		STA	(unk_1F),Y
		DEY
		PLA
		STA	(unk_1F),Y
		DEY
		LDA	#$8d ; -$73 ;	'�'
		STA	(unk_1F),Y
		STA	byte_6B3
		LDA	unk_1E
		ORA	#2
		STA	unk_1E
		LDX	#4
		JMP	loc_B463

loc_B59E:				
		LDA	#$11
		JMP	loc_859D

loc_B5A3:				
		LDY	#3
		CLC
		LDA	(unk_33),Y
		ADC	unk_33
		STA	unk_33
		BCC	loc_B5B0
		INC	unk_34

loc_B5B0:				
		JMP	loc_B4CF

                .pend

;-------------------------------------------------------------------------

label_command:				
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	#0
		STA	unk_1E
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_B5C3:				
		LDY	#1
		LDA	(byte_2B),Y
		BMI	loc_B5EC
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	#0
		STA	byte_6B3
		JMP	loc_B65A

loc_B5D4:				
		LDA	byte_6B3
		BEQ	loc_B5DC
		JSR	sub_B4A7

loc_B5DC:				
		LDY	#3
		CLC
		LDA	(byte_2B),Y
		ADC	byte_2B
		STA	byte_2B
		BCC	loc_B5E9
		INC	byte_2C

loc_B5E9:				
		JMP	loc_B5C3

loc_B5EC:				
		PLA
		STA	current_line_no_lsb
		PLA
		STA	current_line_no_msb
		LDA	unk_1E
		BNE	locret_B5FB
		LDA	#$13
		JMP	loc_859D

locret_B5FB:				
		RTS

;-------------------------------------------------------------------------

label_edit_mode_command: .proc
		LDA	#$13
		PHA
		LDA	#<label_command
		STA	unk_6B1
		LDA	#>label_command
		STA	unk_6B2
		BNE	loc_B618 ;JMP, in effect
                .pend

;-------------------------------------------------------------------------

number_edit_mode_command: .proc
		LDA	#$f     ;"No references to labels were found"
		PHA
		LDA	#<number_command
		STA	unk_6B1
		LDA	#>number_command
		STA	unk_6B2
                ; fall through
                .pend

;-------------------------------------------------------------------------
                
loc_B618: .block 
		JSR	is_program_empty ; sets	C if no	program
		PLA
		BCC	loc_B621
		JMP	loc_859D

loc_B621:				
		LDA	byte_6C0
		STA	byte_39
		LDA	byte_6C1
		STA	byte_3A
		LDY	#1
		LDA	(byte_39),Y
		PHA
		INY
		LDA	(byte_39),Y
		PHA
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	make_cursor_invisible
		JSR	unk_6B0
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JMP	loc_967A

                .bend

;-------------------------------------------------------------------------

loc_B65A: .proc
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#5
		STA	byte_F
		LDX	#0
		LDY	#3
		LDA	(byte_2B),Y
		TAY
		INY
		BNE	loc_B675
		INX

loc_B675:				
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#0
		STY	unk_37
		STY	cursor_offset_msb
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	#4
		STA	unk_1F
		LDA	#5
		STA	byte_20

loc_B689:				
		SEC
		LDA	unk_503
		SBC	#7
		BCC	loc_B695
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BCS	loc_B698

loc_B695:				
		JMP	loc_B5D4

loc_B698:				
		LDY	#0
		LDA	(unk_1F),Y
		CMP	#$22 ; '"'
		BNE	loc_B6A6
		LDA	unk_37
		EOR	#1
		STA	unk_37

loc_B6A6:				
		LDX	unk_37
		BEQ	loc_B6AD

loc_B6AA:				
		JMP	loc_B78C

loc_B6AD:				
		LDA	(unk_1F),Y
		CMP	#$8d ; -$73 ;	'�'
		BNE	loc_B6AA
		LDA	unk_1F
		STA	byte_27
		LDA	byte_20
		STA	byte_28
		LDY	#0
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		LDA	byte_21
		STA	byte_2B
		LDA	byte_22
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JMP	loc_B6DF

loc_B6D4:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B

loc_B6DA:				
		LDX	#4
		JMP	loc_B78E

loc_B6DF:				
		LDY	#1
		LDA	(byte_2B),Y
		CMP	byte_21
		BNE	loc_B6D4
		INY
		LDA	(byte_2B),Y
		CMP	byte_22
		BNE	loc_B6D4
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		LDY	#4

loc_B6F9:				
		LDA	(unk_2F),Y
		CMP	#$20 ; ' '
		BNE	loc_B703
		INY
		JMP	loc_B6F9

loc_B703:				
		CMP	#$f4 ; REM???
		BNE	loc_B6DA
		INY

loc_B708:				
		LDA	(unk_2F),Y
		CMP	#$20 ; ' '
		BNE	loc_B712
		INY
		JMP	loc_B708

loc_B712:				
		CMP	#$40 ; '@'
		BNE	loc_B6DA
		LDX	#1
		CLC
		TYA
		LDY	#0
		ADC	unk_2F
		STA	unk_2F
		BCC	loc_B724
		INC	unk_30

loc_B724:				
		INY
		LDA	(unk_2F),Y
		JSR	sub_B484
		BCC	loc_B72F
		INX
		BNE	loc_B724

loc_B72F:				
		CPX	#1
		BEQ	loc_B6DA
		STX	byte_36
		SEC
		LDA	unk_503
		SBC	#4
		CLC
		ADC	byte_36
		BCC	loc_B745
		LDA	#$12
		JMP	loc_859D

loc_B745:				
		STA	unk_503
		CLC
		LDA	unk_1F
		ADC	#4
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		STA	byte_F
		CLC
		LDA	unk_1F
		ADC	byte_36
		STA	byte_E
		SEC
		LDA	unk_503
		SBC	byte_36
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SBC	#2
		TAY
		LDX	#0
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	unk_2F
		STA	byte_C
		LDA	unk_30
		STA	byte_D
		LDA	unk_1F
		STA	byte_E
		LDA	byte_20
		STA	byte_F
		LDY	byte_36
		LDX	#0
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	byte_36
		STX	byte_6B3
		STX	unk_1E
		BNE	loc_B78E

loc_B78C:				
		LDX	#1

loc_B78E:				
		TXA
		CLC
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		TXA
		CLC
		ADC	unk_1F
		STA	unk_1F
		BCC	loc_B79E
		INC	byte_20

loc_B79E:				
		JMP	loc_B689
                .pend

;-------------------------------------------------------------------------

sub_B7A1: .proc;move_cursor_to_next_line???
					
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	loc_B7AB
		LDA	is_scroll_on	; 1=scroll, 0=noscroll
		BNE	loc_B7B7
		RTS

loc_B7AB:				
		LDA	is_scroll_on	; 1=scroll, 0=noscroll
		BNE	loc_B7B2
		JMP	loc_B89A

loc_B7B2:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_B7BA

loc_B7B7:				
		JMP	edit_mode_loop

loc_B7BA:				
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		STA	byte_36
		JSR	sub_BA69
		TXA
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		TAX
		LDA	$6BF,X
		CMP	byte_2C
		BNE	loc_B7DD
		LDA	$6BE,X
		CMP	byte_2B
		BNE	loc_B7DD
		INC	byte_36

loc_B7DD:				
		LDY	#3
		CLC
		LDA	byte_2B
		ADC	(byte_2B),Y
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDY	#1
		LDA	($C),Y
		BMI	loc_B7B7
		LDA	byte_2D
		STA	unk_34
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	unk_37
		STX	byte_35
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	advance_2b_to_next_line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line
		JSR	calculate_screen_chars_in_line
		CLC
		LDA	byte_2D
		ADC	unk_37
		ADC	byte_3B
		SEC
		SBC	#1
		SEC
		SBC	screen_height
		STA	unk_37
		BEQ	loc_B826
		BPL	loc_B829

loc_B826:				
		JMP	loc_B82C

loc_B829:				
		JSR	sub_B8BD

loc_B82C:				
		LDA	unk_37
		BEQ	loc_B832
		BPL	loc_B85D

loc_B832:				
		LDA	byte_36
		BNE	loc_B85D
		LDA	byte_6B3
		BEQ	loc_B852
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line
		LDX	unk_34
		JSR	calculate_screen_chars_in_line.loc_A021 ;just
                                                                ;scale
                                                                ;by X
		JSR	sub_AA17
		JMP	loc_B89D

loc_B852:				
		LDA	byte_35
		CMP	unk_34
		BNE	loc_B880

loc_B858:				
		PLA
		PLA
		JMP	loc_B89D

loc_B85D:				
		LDA	byte_6B3
		BEQ	loc_B880
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		LDA	byte_3B
		PHA
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B
		JMP	loc_B89D

loc_B880:				
		CLC
		LDA	byte_3B
		PHA
		ADC	byte_35
		STA	byte_3B
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B
		JMP	loc_B858

loc_B89A:				
		JSR	sub_AA06

loc_B89D:				
		LDA	byte_3B
		ASL
		TAX
		INX
		LDY	$6C0,X
		BNE	loc_B8AE
		DEY
		STY	current_line_no_msb
		STY	current_line_no_lsb
		BNE	loc_B8BA

loc_B8AE:				
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		INC	current_line_no_lsb
		BNE	loc_B8BA
		INC	current_line_no_msb

loc_B8BA:				
					
		JMP	sub_A069
                .pend


sub_B8BD: .proc
		SEC
		LDA	unk_37
		SBC	#1
		ASL
		TAX
		TAY

loc_B8C5:				
		INY
		INY
		LDA	$6C0,X
		CMP	$6C0,Y
		BNE	loc_B8DB
		LDA	$6C1,X
		CMP	$6C1,Y
		BNE	loc_B8DB
		INC	unk_37
		BNE	loc_B8C5

loc_B8DB:

                ; copy from $6c0+Y to $6c0 - ok to copy up
		CLC
		TYA
		ADC	#$c0
		STA	byte_C  ;src LSB
		LDA	#6
		STA	byte_F  ;dest MSB
		ADC	#0
		STA	byte_D  ;src MSB
		LDA	#$c0
		STA	byte_E  ;dest LSB

                ; copy (screen_height+1-unk_37)*2
		CLC
		LDA	screen_height
		ADC	#1
		SEC
		SBC	unk_37
		ASL
                
                .if KEEP_B8DB_MEMMOVE
                
		TAY
		LDX	#0
                ; called when scrolling down
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

                .else

                tax
                beq copy_rows_table_done
                ldy #0
copy_rows_table_loop:
                lda (byte_C),y
                sta (byte_E),y
                iny
                dex
                bne copy_rows_table_loop
copy_rows_table_done:
                
                .endif
                                        
		JSR	make_cursor_invisible
		LDX	#0
		LDY	screen_height
		STY	byte_6AB
		JSR	gotoxy
		LDA	#19
		JSR	OSBYTE
		LDY	unk_37
		LDA	#$A

loc_B914:				
		JSR	OSWRCH
		DEY
		BNE	loc_B914
		SEC
		LDA	byte_3B
		SBC	unk_37
		STA	byte_3B
		RTS
                .pend


join_statements_edit_mode_command:	
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_B92A

loc_B927:				
		JMP	beep

loc_B92A:				
		LDY	#3
; set (byte_C) to point at next line
		CLC
		LDA	(byte_2B),Y
		ADC	byte_2B
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDY	#1
		LDA	(byte_C),Y
		BMI	loc_B927	; branch taken if next line is end of program
		JSR	sub_A8C0
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	advance_2b_to_next_line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line
		JSR	rstrip_detokenized_line
		LDA	byte_400
		STA	unk_700
		BEQ	loc_B987
		LDA	#1
		STA	byte_C
		LDA	#4
		STA	byte_D
		LDY	#0

loc_B966:				
		LDA	($C),Y
		CMP	#$20 ; ' '
		BNE	loc_B977
		DEC	unk_700
		INC	byte_C
		BNE	loc_B975
		INC	byte_D

loc_B975:				
		BNE	loc_B966

loc_B977:				
		LDA	#1
		STA	byte_E
		LDA	#7
		STA	byte_F
		LDX	#0
		LDY	unk_700
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size

loc_B987:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line
		JSR	rstrip_detokenized_line
		LDA	unk_700
		BEQ	loc_B9E5
		CLC
		ADC	byte_400
		BCS	loc_B9AD
		STA	unk_37
		LDX	byte_400
		BEQ	loc_B9C4
		CLC
		ADC	#1
		BCC	loc_B9B2

loc_B9AD:				
		LDA	#$14
		JMP	loc_859D

loc_B9B2:				
		CMP	#LINE_LENGTH_LIMIT
		BCS	loc_B9AD
		STA	unk_37
		LDA	#$3A ; ':'
		LDY	byte_400
		STA	$401,Y
		INY
		STY	byte_400

loc_B9C4:				
		CLC
		LDA	byte_400
		ADC	#1
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDA	#1
		STA	byte_C
		LDA	#7
		STA	byte_D
		LDX	#0
		LDY	unk_700
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	unk_37
		STA	byte_400

loc_B9E5:				
		LDA	#0
		STA	byte_6A7
		LDA	#1
		STA	byte_6B3
		JSR	sub_A8C0
		LDA	#1
		STA	byte_6A7
		JSR	find_program
		JSR	advance_2b_to_next_line
		LDA	byte_2B
		STA	byte_E
		LDA	byte_2C
		STA	byte_F
		JSR	advance_2b_to_next_line
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		SEC
		LDA	TOP
		SBC	byte_C
		TAY
		LDA	TOP+1
		SBC	byte_D
		TAX
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JSR	calculate_screen_chars_in_line
		CLC
		LDA	byte_3B
		ADC	byte_2D
		SEC
		SBC	#1
		CMP	screen_height
		BEQ	loc_BA47
		BCC	loc_BA47
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	sub_A069
		JMP	loc_B00D

loc_BA47:				
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	current_line_no_lsb
		PHA
		JMP	loc_B025



rstrip_detokenized_line:		
		LDY	byte_400
		BEQ	loc_BA65

loc_BA5B:				
		LDA	$400,Y
		CMP	#$20 ; ' '
		BNE	loc_BA65
		DEY
		BNE	loc_BA5B

loc_BA65:				
					
		STY	byte_400
		RTS
; End of function rstrip_detokenized_line




sub_BA69: .proc
					
		LDA	screen_height
		ASL
		STA	byte_3A
		LDX	#0

loc_BA71:				
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_BA82
		INX
		LDA	$6C0,X
		CMP	byte_2C
		BNE	loc_BA83
		DEX
		RTS

loc_BA82:				
		INX

loc_BA83:				
		INX
		CPX	byte_3A
		BEQ	loc_BA71
		BCC	loc_BA71
		RTS
                .pend




back_command:				
		LDX	#0		; load colour index (0=background)

set_colour_from_command_line:		
		LDY	byte_6BE
		DEY
		BEQ	loc_BA98

back_command_error:					
		LDA	#$15
		JMP	loc_859D

loc_BA98:				
		LDA	(byte_3E),Y		; get char from	command	line
		AND	#$DF		; toupper

find_colour_loop:			
		CMP	colour_chars,Y	; matched colour char?
		BEQ	got_colour	; taken	if colour found
		INY			; next colour char
		CPY	#8		; last colour?
		BNE	find_colour_loop ; taken if last colour	not yet	reached
		BEQ	back_command_error		; taken	if last	colour reached

got_colour:				
		STY	$A,X
		RTS
; End of function back_command




fore_command:				
		LDX	#1		; load colour index (1=foreground)
		BNE	set_colour_from_command_line ; JMP, in effect
; End of function fore_command		; set appropriate colour




insert_command:				
		LDA	#1

loc_BAB1:				
		STA	is_insert_mode	; 0=overtype 1=insert
		RTS
; End of function insert_command




overtype_command:			
		LDA	#0
		BEQ	loc_BAB1
; End of function overtype_command



help_command .proc
		LDA	#<command_table
		STA	unk_33
		LDA	#>command_table
                STA	unk_34

help_loop
                ldy #0
                lda (unk_33),y
                cmp #$ff
                beq done

                ; print command name
print_command_name_loop
                jsr oswrch
                iny
                lda (unk_33),y
                bne print_command_name_loop

                ; skip terminating 0
                iny
                
                ; fetch args flags into X
                lda (unk_33),y
                iny
                tax

                ; skip command ID
                iny

                ; point unk_34 at next command
                clc
                tya
                adc unk_33
                sta unk_33
                bcc nocarry
                inc unk_34
nocarry

                ; do args
                txa
                and #$20
                bne print_c

                txa
                and #$10
                bne s1s2

                txa
                and #$40
                bne n1n2

                txa
                and #$8
                bne print_p

                txa
                and #$2
                bne print_n

                txa
                and #5
                bne print_s

next_help:
                jsr print_next_string
                .text ", ",255
                
                jmp help_loop

print_c
                ldx #'c'
                bne onechar

print_p
                ldx #'p'
                bne onechar

print_n
                ldx #'n'
                bne onechar

print_s
                ldx #'s'
onechar
                lda #32
                jsr oswrch
                txa
                jsr oswrch
                jmp next_help

s1s2:
                jsr print_next_string
                .text " s1 s2",255
                jmp next_help

n1n2:
                jsr print_next_string
                .text " n1 n2",255
                jmp next_help           

done
print_help_footer:
                jsr print_next_string
                .text "n",$D,$A
                .byte $A
                .text "Where p is a program; s, s1, s2 are strings; n, n1, n2 are numbers; c is a colour [NRGYBMCW].",$D,$A
                .byte 255
                rts
                .pend
                
;-------------------------------------------------------------------------

goto_line_command .proc				
		LDA	byte_3F
		STA	byte_2B
		LDA	byte_3E
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	(byte_2B),Y
		BMI	loc_BBB0
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JMP	loc_9DA8

loc_BBB0:				
		JMP	end_edit_mode_command
.pend


print_bytes_free: .proc
                lda is_bad_program
                bne bad

                lda himem
                sbc top
                tax
                lda himem+1
                sbc top+1
                tay
                jmp print_number

bad:
                lda #'?'
                jmp oswrch
                .pend
                
info_command:				
                JSR	osnewl

                ; lda language_entry_mode
                ; clc
                ; adc #'A'
                ; jsr oswrch

                lda is_bad_program
                bne print_status

                ldx top
                sec
                lda top+1
                sbc oshwm+1
                tay
                jsr print_number

                jsr print_next_string
                .text " used, ",255

                jsr print_bytes_free
                
                jsr print_next_string
                .text " free",13,10,255

print_status:
                .if ENABLE_DEBUG

                jsr print_next_string
                .text "DBG: ",255

                lda debug_flag
                jsr print_on_off

                lda #' '
                jsr oswrch

                ldx debug_counter+0
                ldy debug_counter+1
                jsr itoa
                jsr print_itoa_result
                jsr osnewl
                
                .endif
                
                jsr print_next_string
                .text "Scroll: ",255

                lda is_scroll_on ;1=scroll 0=noscroll
                jsr print_on_off
                
                jsr osnewl

                jsr print_next_string
                .text "Insert: ",255

                lda is_insert_mode ;0=overtype 1=insert
                jsr print_on_off

                jsr osnewl

		LDA	#$87		; get MODE in Y
		JSR	OSBYTE		; get MODE in Y
		CPY	#7		; MODE 7?
                beq loc_BC0B
					
		JSR	print_colour_scheme
		JSR	OSNEWL

loc_BC0B:				
		JSR	OSNEWL
		; LDX	#<aProgramName
		; LDY	#>aProgramName
		; LDA	#$E
                ; JSR	print_n_chars
                jsr print_next_string
                .text "Program name: ",255                
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
                jsr print_program_name
                JSR	OSNEWL
		LDX	#<aLastSearch
		LDY	#>aLastSearch
		LDA	search_string_length
		BNE	loc_BC37
		LDA	#aLastSearchNoneEnd-aLastSearch
		BNE	loc_BC42

loc_BC37:				
		LDA	#aLastSearchEnd-aLastSearch
		JSR	print_n_chars
		LDX	#<unk_643
		LDY	#>unk_643
		LDA	search_string_length

loc_BC42:				
		JSR	print_n_chars
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	OSNEWL
                JSR	OSNEWL
                jsr print_next_string
                .text "Tab value   : ",255
		LDX	tab_value
		LDY	#0
		JSR	print_number
                JSR	sub_BD83
                jsr print_next_string
                .text "No.of lines: ",255
		LDA	is_bad_program
		BNE	loc_BC94
		LDX	#0
		STX	byte_38
		STX	byte_39
		STX	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_BC7C:				
		LDY	#1
		LDA	(byte_2B),Y
		BMI	loc_BC8D
		JSR	advance_2b_to_next_line
		INC	byte_38
		BNE	loc_BC8B
		INC	byte_39

loc_BC8B:				
		BNE	loc_BC7C

loc_BC8D:				
		LDX	byte_38
		LDY	byte_39
		JSR	print_number

loc_BC94:				
		JSR	OSNEWL
		LDA	is_bad_program
		BEQ	loc_BC9C
		RTS

loc_BC9C:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_BCA4
		JMP	loc_BD22

loc_BCA4:				
                jsr print_next_string
                .text "First line  : ",255
                
		JSR	sub_BD8D
		JSR	sub_BD83
                jsr print_next_string
                .text "Last line  : ",255
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#2
		LDA	(unk_2F),Y
		TAX
		DEY
		LDA	(unk_2F),Y
		TAY
		JSR	print_number
                JSR	OSNEWL
                jsr print_next_string
                .text "Current line: ",255
		LDX	current_line_no_lsb
		LDY	current_line_no_msb
		JSR	print_number
		JSR	sub_BD83
		JSR	sub_B37B
		PHP
		LDX	#<aMarkedLine
		LDY	#>aMarkedLine
		PLP
		BNE	loc_BCFF
		LDA	#aMarkedLineEnd-aMarkedLine
		JSR	print_n_chars
		LDX	marked_line_no_lsb
		LDY	marked_line_no_msb
		JSR	print_number
		JMP	loc_BD04

loc_BCFF:				
		LDA	#aMarkedLineNoneEnd-aMarkedLine
		JSR	print_n_chars

loc_BD04:				
		JSR	OSNEWL
		JSR	OSNEWL
		LDX	#<aPendingCommands
		LDY	#>aPendingCommands
		LDA	byte_40
		CMP	#$20 ; ' '
		BNE	loc_BD25
		LDA	byte_46
		CMP	#$20 ; ' '
		BNE	loc_BD25
		LDA	#aPendingCommandsNoneEnd-aPendingCommands
		JSR	print_n_chars

loc_BD1F:				
		JSR	OSNEWL

loc_BD22:				
		JMP	OSNEWL

loc_BD25:				
					
		LDA	#aPendingCommandsEnd-aPendingCommands
		JSR	print_n_chars
		JSR	OSNEWL
		LDA	byte_40
		CMP	#$20 ; ' '
		BEQ	loc_BD46
		LDA	byte_43
		CMP	#$20 ; ' '
		BEQ	loc_BD46
		JSR	sub_AD1A
		BCC	loc_BD46
		LDX	byte_40
		LDY	byte_43
		STX	byte_43
		STY	byte_40

loc_BD46:				
					
		LDA	#0
		STA	byte_39

loc_BD4A:				
		LDX	byte_39
		CPX	#7
		BCS	loc_BD1F
		LDA	$40,X
		CMP	#$20 ; ' '
		BEQ	loc_BD7B
		CMP	#$60 ; '`'
		BCC	loc_BD60
		SEC
		SBC	#$20 ; ' '
		JSR	OSWRCH

loc_BD60:				
		JSR	OSWRCH
		LDA	#$20 ; ' '
		JSR	OSWRCH
		LDA	$41,X
		TAY
		LDA	$42,X
		TAX
		JSR	print_number
		LDX	#3
		LDA	#$20 ; ' '

loc_BD75:				
		JSR	OSWRCH
		DEX
		BNE	loc_BD75

loc_BD7B:				
		INC	byte_39
		INC	byte_39
		INC	byte_39
		BNE	loc_BD4A
; End of function info_command




sub_BD83:				
					
		LDA	#$86 ; -$7A ;	'�'
		JSR	OSBYTE
		LDX	#$15
		JMP	gotoxy
; End of function sub_BD83




sub_BD8D:				
		LDY	#2		; offset of line number	MSB
		LDA	(oshwm),Y		; get line number MSB
		TAX
		DEY			; offset of line number	LSB
		LDA	(oshwm),Y		; get line number LSB
		TAY
; End of function sub_BD8D




print_number: .proc			
					
		JSR	itoa		; Gets string representation of	16-bit number.
					;
					; Entry:
					; Y,X =	value
					;
					; Exit:
					; unk_0	holds digit count
					; unk_1... filled with string

                .pend

print_itoa_result: .proc

		LDX	#1
		LDY	#0
		LDA	byte_0
		JMP	print_n_chars

                .pend

print_colour_scheme: .proc		
					
                LDX	foreground_colour
                lda #$df
                JSR	print_colour_name
                jsr print_next_string
                .text " on ",255
                LDX	background_colour
                lda #$ff

                ; fall through
print_colour_name:
                ldy colour_names_table,x
loop:
                and colour_names_table,y
                jsr oswrch
                iny
                tya
                cmp colour_names_table+1,x
                lda #$ff
                bcc loop
                rts
.pend


sub_BDD3:				
					
		LDA	byte_3E
		PHA
		LDA	byte_3F
		PHA
		LDA	unk_6BA
		STA	byte_3E
		LDA	unk_6BB
		STA	byte_3F
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	byte_6BE
		BCS	loc_BDF5
		SEC
		SBC	#1
		CMP	byte_400
		BEQ	loc_BE09
		BCC	loc_BE09

loc_BDF5:				
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	unk_6BC
		BCS	loc_BE23
		SEC
		SBC	#1
		CMP	#-4 ; '�'
		BCS	loc_BE23
		STA	byte_400
		BCC	loc_BE57

loc_BE09:				
		SEC
		LDA	unk_6BC
		SBC	byte_6BE
		STA	unk_6AE
		CLC
		ADC	byte_400
		PHA
		LDY	unk_6AE
		BMI	loc_BE2B
		BCS	loc_BE23
		CMP	#-4 ; '�'
		BCC	loc_BE2B

loc_BE23:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		LDA	#$25 ; '%'
		JMP	loc_859D

loc_BE2B:				
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		ADC	byte_6BE
		STA	byte_C
		ADC	unk_6AE
		STA	byte_E
		LDA	#4
		STA	byte_D
		STA	byte_F
		LDX	#0
		CLC
		LDA	byte_400
		ADC	#1
		SEC
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SEC
		SBC	byte_6BE
		TAY
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		PLA
		STA	byte_400

loc_BE57:				
		LDA	byte_3E
		STA	byte_C
		LDA	byte_3F
		STA	byte_D
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDX	#0
		LDY	unk_6BC
		CLC
		TYA
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_6B3
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
                RTS
; End of function sub_BDD3




find_mode_getch:				
					
		JSR	kbflush
		LDA	is_insert_mode	; 0=overtype 1=insert
		PHA
		LDA	#1
		STA	is_insert_mode	; 0=overtype 1=insert
		JSR	reset_cursor_shape
		PLA
		STA	is_insert_mode	; 0=overtype 1=insert
		JSR	getch
		JMP	make_cursor_invisible
; End of function find_mode_getch




move_cursor_to_previous_line: .proc ;scroll up??
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	line_empty
		LDA	is_scroll_on	; 1=scroll, 0=noscroll
		BNE	loc_BEB2        ;taken if scroll on
		RTS

line_empty:    
		LDA	is_scroll_on	; 1=scroll, 0=noscroll
		BNE	loc_BEA9        ;taken if scroll on

loc_BEA6:				
		JMP	loc_BFBB

loc_BEA9:				
		LDA	byte_3B
		BNE	loc_BEA6         ;taken if Y!=0 - i.e.,
                                         ;scrolling is unnecessary
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_BEB5         ;taken if program is valid

loc_BEB2:				
		JMP	edit_mode_loop ;

loc_BEB5:				
		JSR	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		LDA	unk_30
		BEQ	loc_BEB2 ;clearly bad if zero
		JSR	make_cursor_invisible
		LDA	byte_2D
		STA	byte_35
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA
		SEC
		SBC	byte_35
		STA	byte_35
		LDA	screen_chars_in_line+0
		PHA
		LDA	screen_chars_in_line+1
		PHA
		JSR	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_msb,
					; current_line_no_lsb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JSR	detokenize_one_line
		JSR	calculate_screen_chars_in_line ;also sets
                                                       ;byte_2d to
                                                       ;line height
		LDX	#0
		LDY	#0
		JSR	gotoxy
		LDA	#19
		STA	byte_6AB
		JSR	OSBYTE  ;this is actually worth doing in Mode
                                ;7...

                ; scroll screen up enough to fit new line
		LDY	byte_2D
		LDA	#11

loc_BEF7:				
		JSR	OSWRCH
		DEY
		BNE	loc_BEF7

                ; 
		LDA	byte_35
		BEQ	loc_BF04
                
		JMP	loc_BF5B

loc_BF04:

                ; ?byte_36 = (screen_height - line_height) + 1
		SEC
		LDA	screen_height
		SBC	byte_2D      
		STA	byte_36
		INC	byte_36


                ; erase any partial line at the bottom of the screen?
loc_BF0E:				
		LDA	byte_36
		ASL            
		TAX            
		TAY            
		INX            
		LDA	$6C0,X 
		BEQ	loc_BF5B
		DEY
		CMP	$6C0,Y
		BNE	loc_BF4F
		DEX
		DEY
		LDA	$6C0,X
		CMP	$6C0,Y
		BNE	loc_BF4F
		LDA	#0
		STA	$6C0,X
		STA	$6C1,X
		DEC	byte_36

                ; gotoxy (0,y)
		CLC
		LDA	byte_36
		ADC	byte_2D
		TAY
		LDX	#0
		JSR	gotoxy

                ; fill with spaces
		CLC
		LDA	code_area_width
		ADC	#6      ;account for line number area
		TAY
		LDA	#$20 ; ' '

loc_BF47:				
		JSR	OSWRCH
		DEY
		BNE	loc_BF47
		BEQ	loc_BF0E ;JMP, in effect

loc_BF4F:				
		LDA	byte_36
		ASL
		TAX
		LDA	#0
		STA	$6C0,X
		STA	$6C1,X

loc_BF5B:
		LDA	byte_2D ;Y coord
		ASL             ;*2
		STA	byte_E

                ; copy from $6c0 to $6c0+y - must copy down
		LDA	#6
		STA	byte_D  ;src MSB
		STA	byte_F  ;dest MSB
		LDA	#$C0
		STA	byte_C  ;src LSB
		CLC
		ADC	byte_E  ;dest LSB
		STA	byte_E  ;dest LSB
		BCC	loc_BF73
		INC	byte_F

loc_BF73:				
		CLC
		LDA	screen_height
		ADC	#1
		SEC
		SBC	byte_2D
		ASL

                .if KEEP_BF73_MEMMOVE

		TAY
		LDX	#0
                ;
                ; called when scrolling up
		JSR	memmove_8bit   ; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
                                        
                .else

                tay
                beq copy_rows_table_done
                dey              ;Y is offset
copy_rows_table_loop:
                lda (byte_C),y
                sta (byte_E),y
                dey
                cpy #$ff
                bne copy_rows_table_loop
copy_rows_table_done:

                .endif

		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JSR	sub_9F00
		JSR	advance_2b_to_next_line
		LDA	byte_2D
		STA	byte_3B
		ASL
		TAX
		LDA	byte_2B
		STA	$6C0,X
		LDA	byte_2C
		STA	$6C1,X
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		PLA
		STA	screen_chars_in_line+1
		PLA
		STA	screen_chars_in_line+0
		LDA	byte_6B3
		BNE	loc_BFB5
		LDA	byte_35
		BEQ	loc_BFBE

loc_BFB5:				
		JSR	sub_AA17
		JMP	loc_BFBE

loc_BFBB:				
		JSR	sub_AA06

loc_BFBE:				
					
		LDA	byte_3B
		ASL
		TAX
		BNE	loc_BFCB
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69

loc_BFCB:				
		DEX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	sub_BA69
		TXA
		LSR
		STA	byte_3B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_msb, current_line_no_lsb = the line number
		JMP	sub_A069
                .pend


; finds	current	line by	number.
;
; Entry:
; current_line_no_msb,
; current_line_no_lsb =	line number to search for
;
; Exit:
; (byte_2B) points to line found

find_current_line_by_number:		
		LDA	current_line_no_msb
		STA	byte_2B
		LDA	current_line_no_lsb
		STA	byte_2C
		JMP	find_line_by_number ; finds a line, given a line number
; End of function find_current_line_by_number ;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
                                        ; (byte_2B) points to most suitable line

zsave_command: .proc
                jsr find_program
                jsr find_program_name
                bcc no_program_name

                ; pretend program name was command line, and forward
                ; straight to SAVE.
                lda program_name_ptr+0
                sta byte_3E
                lda program_name_ptr+1
                sta byte_3F
                jmp save_command

no_program_name:
                lda #39         ;No program name
                jmp loc_859D
.pend

zrun_command: .proc
                jsr zsave_command

                lda #CMD_RUN
                sta current_command_id
                jmp run_or_exit_command
.pend

print_program_name: .proc
                jsr find_program_name
                bcc done

                ldy #0
loop:
                lda (program_name_ptr),Y
                cmp #13
                beq done
                jsr oswrch
                iny
                bne loop

done:
                rts
                .pend

;-------------------------------------------------------------------------

find_program_name: .proc
                ; check for intial 13.
                ldy #0
                lda (oshwm),y
                cmp #13
                bne no

                ; check line MSB - no program if -ve.
                iny

                lda (oshwm),y
                bmi no

                ldy #3
                ; look for REM
                jsr skipspaces
                cmp #REM_TOKEN
                bne no

                ; look for >
                jsr skipspaces
                cmp #'>'
                bne no

                ; no name if just spaces.
                jsr skipspaces
                cmp #13
                beq no

                ; point (byte_3e) at name
                clc
                tya
                adc $17
                sta program_name_ptr+0
                lda $18
                adc #0
                sta program_name_ptr+1
                sec
                rts

no:
                clc
                rts

skipspaces
                iny
                lda (oshwm),y
                cmp #32
                beq skipspaces
return:
                rts
                .pend

;-------------------------------------------------------------------------

maybe_verbose_exit_on_error: .proc
                bit language_entry_mode
                bpl find_program_name.return

                jsr display_error_message
                jmp exit_and_OLD
                
                .pend

;-------------------------------------------------------------------------

                .if ENABLE_DEBUG
reset_debug_values: .proc
                lda #0
                sta debug_counter+0
                sta debug_counter+1
                sta debug_flag
                rts
                .pend
                .endif

;-------------------------------------------------------------------------

                .if ENABLE_DEBUG
inc_debug_counter: .proc
                inc debug_counter+0
                bne done
                inc debug_counter+1
done:
                rts
                .pend
                .endif
                
;-------------------------------------------------------------------------
                .bend
                .send language
