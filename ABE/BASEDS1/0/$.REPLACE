$START\ REPLACE Module\.'Global \GLOBAL REPLACELDA#0BEQ Common\.'Select \SELECTIVE REPLACELDA#&FF.Common STA SwitchJSR Printmsg$EQUB 131$EQUS "Enter Replace$:"$EQUW &87 \Revert to whiteJSR Getline \Get Replace$BCC @E+5 \Escaped?JMP ChoiceJSR Checkline \Check for special syntaxBEQ StoreRSLDA#0STA&37LDA#7STA&38JSR CRUNCHLINE \Crunch Rep$.StoreRS LDY#0STY Highlight \OnSTY Varpack \Clear flagDEY \=FFSTY Lineend \List whole lines.SaveRT INYTAX \Save previous chracterLDA &700,YSTA &5AB,Y \Save Rep$ in page ACMP#13 \End of R$?BNE SaveRTLDA&700 \Get first chrCMP#"["BNE @E+3DEY \Delete[ not incCPX#"]" \Last chr a ] ?BNE SavelenDEYBPL @E+4LDY#0 \Len cant be<0!.Savelen STY&5AA \Lenth of R$ less any []BIT Switch \S or G?BMI Jsure \SelectiveJSR Printmsg$EQUS "ƒGlobal, are you SURE?"$EQUB 0JSR YesNoBNE Rs \JMP Choice if no.Jsure JSR Sure.Rs JMP Choice\ **********************************.'Sure JSR Start \Also called by VarpackBEQ Rx.Nxtsrch JSR Nextline.Rx BIT&FFBMI RzJSR Search.Ra BEQ Ru.Rz RTS \TOP or Escaped.Ru BCS Nxtsrch \Nomatch foundLDY OffsetSTY MatchLDX#3\Check back 3 bytes to ensure matching bytes do not form part of a line#BIT&8BBMI Sp \If Quotes open dont bother as 8D=double hieght.Sn DEYCPY#4BCC Sp \Gone back into line lenLDA(Addr),YCMP#&8D \Line# marker?BEQ St \Yes, dont replaceDEXBNE Sn.Sp BIT Switch \Selective or Global?BPL Replace \Global-do it.Sq JSR Listline \List the lineJSR Printmsg$EQUS "ƒReplace? Y/N:"$EQUB 0JSR YesNoBEQ Replace \YesBIT&FF \Escaped?BMI Rz \Yes.St JSR ConSrch \No,continue searchJMP Ra.Replace BIT VarpackBPL Nvp \Not variable packingBIT &8BBMI St \Quotes open and Varpacking, dont replace-text!.Nvp JSR LinetoIAC \Put line# in IACLDY#4\Copy line out to buffer, upto match pointLDA&5ABCMP#"["BNE CopyLDX#1BNE Insert \[ Deletes up to R$.Copy LDX OffsetDEXDEXDEXBNE C2INXBNE Insert \IF X=0 now then first byte of SS is WC and matching line len byte, so skip first byte of Rep$, also WC!.C2 DEX \No of bytes to copyBEQ Insert \Nothing to copy.Get LDA (Addr),YSTA &6FC,Y \Buffer at &700INYDEXBNE Get\Insert replacement$, X=0.Insert LDA &5AB,X \Get replacement byteINX \Cant exit loop with X=0CMP#13BEQ Addrest \End of R$CMP#3 \Wildcard in replace$?BCS Stuff \NoLDA(Addr),Y \Pickup equivelent byte from original line.Stuff STA &6FC,YCMP#13BEQ Newline \If CR picked up by wildcard, end of lineINYBNE Insert\Get here if line is too long.Toolong JSR Printmsg$EQUB 131$EQUS "Line too long at"$EQUB 0JSR PrtLino \Print Line#JMP Choice.Addrest \Add on rest of original lineDEXBEQ @E+3 \Min value 0!DEXLDA &5AB,X \Get last chr before CR in RSPHATYATAXPLA \Index to XCMP#"]" \] deletes rest of line if last chrBNE AddonDEX \Write over ]LDA#13BNE Adb \Skip rest of line text.AddonLDY SSLen \Pts to next chr after match$ORA &555,Y \Last chr of S$CMP#3 \Both WCs?BCS Ada \NoDEXDEY \Join text over the wcs if both S$ and R$ end WC.Ada LDA(Ptr),Y.Adb STA &6FC,X \Add byte to bufferCMP#13 \End of line?BEQ NewlineINYINXBNE AdaBEQ Toolong \Line too long.Newline LDY#0JSR INSERT \Insert new line into program, text at &700,Y, Line# in IACLDA&700CMP#13BNE @E+5JMP Rx \If first chr on line is CR line was totally deleted,so (Adr) already=next line startLDA&5ABCMP#"[" \Deleting left?BNE Nodelet \NoLDA#4STA Offset \Reset offset to line startCLCADC AddrSTA Ptr \Reset Ptr to first byte of lineLDA#0ADC Addr+1STA Ptr+1.Nodelet LDX &5AA \R$ LenthBEQ ND2 \Prevent X going -veLDA &556 \SS start WC?CMP#3BCS @E+3DEX \Yes, drop ptr back 1.ND2 TXACLCADC PtrSTA Ptr \Update Ptr to past new bytesBCC @E+4INC Ptr+1CLCTXAADC OffsetSTA Offset \Update OffsetJSR Sa \Continue search without incrementing indexsJMP Ra\\ *********************************$END