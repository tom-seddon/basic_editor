$START \ * * * * * * * * * * * * * * * * * * * * * * * \ * ELECTRON BASED \ * EPROM HEADER  + Common subroutines        * \ * VERSION 6.0X  May 86                      * \ * FOR USE WITH ELECTRON                     * \ * based on Probe 6.02 \ * * * * * * * * * * * * * * * * * * * * * * *BRK  \No Language entryBRKBRK JMP Reason \Service entry $EQUB &82 \Service & Language Rom $EQUB Offset-&8000 \Offset to 0(C) $EQUB 6 \Version#.Romname $EQUS "Altra BasicEd (Electron) " $EQUB 0 $EQUS "1.60" \Version$.Offset $EQUB 0 $EQUS "(C)1988 IJW" $EQUB 0.Reason PHA TXA PHA TYA PHA TSX LDA &103,X \Get A back CMP #4 BEQ Command CMP #9 BEQ Help CMP #3 BNE Nosuch.Boot JSR Romtitle \Print Romtitle on Break JSR OSNEWL.'Nosuch PLA \Restore AXY and rtn, not done TAY PLA TAX PLA RTS .Command \(F2),Y=OSCLI$ LDA #&FE \Offset to command table-2 BNE Search.Help JSR Nextoscl \Get chr from OSCL$ BNE Fullhelp \If CR only print Rom$.. JSR Romtitle JSR Rt2 \Print Version$, Romtitle left Y pointing at Version$ JSR OSNEWL JSR Printmsg $EQUS " BASED" $EQUB 0 JSR OSNEWL JMP Nosuch.Fullhelp LDA #(Helptabl-Table-2) \Offset to help table-2 \Search- compares OSCL$ with table of Rom contents, xeqs if match.Search PHA TAX JSR Search2 BCC Xeqn \Found TAY \Original offset PLA TAX JSR Nextoscl CMP #"A" \PREFIX CHR$, A=Altra BNE Nosuch INY \Skip any prefix A JSR Search2 BCS Nosuch PHA \dummy.Xeqn PLA \X TYA PHA \Save new offset under original LDA Table,X \Xeqn addr Hi PHA \on stack LDA Table+1,X \Xeqn addr Lo PHA RTS \Jump to it. Addr is byte before routine.Search2 TYA PHA \Save pseudo offset.Start INX INX \Skip xeqn addr PLA PHA TAY \Get offset JSR Nextoscl \Get byte from OSCL$ INY LDA Table,X \Get byte from rom table BNE Continue \0=end of table PLA \Drop pseudo offset SEC \C=1 for notfound RTS.Continue DEX DEY DEY.Match INX INY LDA Table,X \Rom byte BMI End \End of Rom$ EOR(&F2),Y \Compare with OSCL$ byte AND #&5F \force uppercase BEQ Match \If=0 chrs match,try next DEX \Chrs not matching.Skip INX LDA Table,X BPL Skip \Skip rest of Rom$ LDA (&F2),Y \Get OSCL$ byte again CMP #"." \Abbreviation? BNE Start \no, try next Rom$ INY \next OS chr BCS Xeq \Go do it.End LDA (&F2),Y AND #&DF \Upper case CMP #&41 \If next chr is A-Z BCC Xeq \OSCL$>Rom$ length CMP #&5B \so no match BCC Start.Xeq PLA \drop pseudo offset CLC \C=0 found RTS.'Alldone PLA \Drop secondary offset PLA \Restore AXY and rtn with A=0 TAY PLA TAX PLA LDA #0 RTS \ *********************************.'Printmsg \Print msg upto 0, rtn to byte following. Uses A,Y PLA STA &AE PLA STA &AF.Msgout INC &AE BNE @E+4 INC &AF LDY #0 LDA (&AE),Y JSR OSASCI TAY BNE Msgout.Msgends LDA &AF PHA LDA &AE PHA RTS .'Printit PHA \chr in A to printer only LDA #1 JSR OSWRCH PLA JMP OSWRCH.'Printer \Message to printer only PLA STA &AE PLA STA &AF.Nxtp INC &AE BNE @E+4 INC &AF LDY #0 LDA (&AE),Y BEQ Msgends JSR Printit JMP Nxtp\******************************* \ Skip over spaces in OSCL$,rtn next chr in A, Z=1 if A=CR.'Skposcl INY.'Nextoscl LDA (&F2),Y CMP #32 BEQ Skposcl CMP #13 \CR? RTS.'Space2 JSR Space1.'Space1 LDA #32 JMP OSWRCH \ * Routine to print IAC in decimal *.'OUTIAC LDA #0 \In zero field BEQ @E+4.'LINIAC LDA #5 \In 5 field (line#).'IACOUTA TAX \Field width LDA &2A STA &AE LDA &2B STA &AF \Transfer IAC to scratch JMP IACOUTA2.'OUTIAC2 LDX #0 \Print (AE) in decimal BEQ IACOUTA2.'LINIAC2 LDX #5 \In 5 field.'IACOUTA2 \Fieldwidth in X \ PRINT AE/AF in decimal \ Enter with X= required print field width \ Uses A,X,Y LDA #&80 \Terminator chr.NXTDIG PHA DEX \Dec leading zero count LDY #16 \Bit counter LDA #0 SEC SBC #&80.Roll ROL A CMP #10 BCC Nsub SBC #10.Nsub ROL &AE ROL &AF DEY BPL Roll \Loop 17 times BVC NXTDIG PHA BVS P4.P1 JSR Space1 \Print leading spaces.P4 DEX BPL P1.P2 PLA.P3 ORA #&30 \Make ascii JSR OSWRCH \Print digits PLA BPL P3 RTS\ *********************************.'Hex_asci \Print A in Asci hex via OSWRCH. Uses A only PHA LSR A LSR A LSR A LSR A JSR Nybble PLA.'Nybble \Print LSN of A in hex AND #&F CMP #10 BCC Number ADC #6 \C=1, so +7.Number ADC #&30 JMP OSWRCH \Print it and RTS \ERROR-EXIT Syntax is JSR Errorexit, Error#, Message, 0.'Errorexit PLA STA &AE PLA STA &AF \(AE),1 pts to Error# LDY #0 STY &100 \Set BRK INY \=1 LDA (&AE),Y STA &101 \do err#seperate to allow 0#.EE1 INY LDA (&AE),Y STA &100,Y \Build mssg in stack space BNE EE1 \until 0 terminator found.EE2 JMP &100 \Let lang rom handle error, lets basic REPORT work \YES/NO checks KB for Y or N(default), prints Y/N as rqd, rtns Z=1 for Yes, Z=0 for No.'YESNO LDA #15 LDX #1 JSR OSBYTE \Flush input buffer.'YESNO2 JSR OSRDCH \Get input BCS No \Escaped? AND #&5F CMP #"Y" BEQ Answer.No LDA #"N".Answer PHP JSR OSWRCH \Print Y/N JSR OSNEWL \CR PLP \Restore Z as answer RTS \ ********************************* \* DEC-BIN, Convert decimal asci$ to binary, 0 to 32767 \Enter (F2),Y pointing to first chr of $, X=addr of 2 byte result \Rtns C=1 if result OK, Z=1 if terminator=CR \Rtns next non space chr in A, (F2),Y pointing \If first chr not decimal leaves result bytes as found (ie default).'DECBIN LDA (&F2),Y JSR Decimal BCS number \first chr ok.end JSR Nextoscl \get next non space chr.E1 SEC RTS \Rtn C=1 if result ok.number STA 0,X \Result lo LDA #0 STA 1,X \Clear result hi.DB1 INY LDA (&F2),Y \Next chr JSR Decimal BCC end \not a number PHA \Multiply existing result *10 LDA 1,X PHA LDA 0,X \Result lo ASL 0,X ROL 1,X \*2 BMI Toobig2 ASL 0,X ROL 1,X \*4 BMI Toobig2 ADC 0,X \C=0 STA 0,X PLA \Old result hi ADC 1,X \*4+*1=*5 ASL 0,X ROL A \A=New result hi,=*5*2=*10 BMI Toobig1 BCS Toobig1 STA 1,X PLA \New digit ADC 0,X \C=0 STA 0,X BCC DB1 INC 1,X BPL DB1 BMI bad.Toobig2 PLA.Toobig1 PLA.bad CLC RTS \Rtn C=0 if too big or non numeric.'Decimal CMP #&3A BCS bad \>9 CMP #&30 BCC bad \<0 AND #&F \binary RTS \C=1 if number ok \ ******************************* \ HEXBIN convert asci Hex $ to binary in AE/AF, values 0-FFFF \Enter (F2),Y pointing to first chr \Rtns C=1 if ok, Z=1 if terminator chr is CR \Only valid terminator is space or CR, else rtns C=0 \Rtns next non space chr in A, (F2),Y pointing \ If first chr is not hex leaves AE/F alone.'HEXBIN LDA (&F2),Y JSR Hex BCC bad \Rtn C=0, bad hex first digit LDX #0 STX &AE STX &AF \Zero result bytes.HB1 ASL A ASL A ASL A ASL A \Move into MSNybble LDX #4.HB2 ASL A ROL &AE ROL &AF BCS bad \Result >FFFF DEX BNE HB2 INY LDA (&F2),Y \Next digit JSR Hex BCS HB1 \Hex Ok CMP #32 \Space? BEQ end \Rtn C=1, OK CMP #13 \CR? BEQ E1 \Rtn C=1,Z=1 BNE bad \Rtn C=0, invalid terminator.'Hex CMP #"G" BCS bad \Rtn C=0, not hex CMP #"A" BCC Decimal \If <"A" check for 0-9 SBC #&37 \C=1, makes A=10 etc RTS \Rtn C=1 \ ********************************* \ * None of the routines/tables from here on \ * are accessed from outside the header. \ * So any changes will not alter call addresses.Romtitle JSR OSNEWL LDY #0.Rt2 LDA Romname,Y INY JSR OSWRCH TAX BNE Rt2 RTS \ *******************************.Helpaids \ Print ROM contents for *HELP PROBE JSR Romtitle JSR Rt2 \Print Version$, Romtitle left Y pointing at Version$ JSR OSNEWL LDX #&FE LDY #0.HA1 INX INX \Move past address LDA Table2,X BEQ HAend \FF=end marker PHA JSR Space2 \2 spaces PLA.HA2 JSR OSWRCH \Print name until.. INX LDA Table2,X BPL HA2 \..until addr hi byte LDA #32 \Space.HA3 JSR OSASCI \Print syntax upto CR CMP #13 BEQ HA1 \next name LDA Helpfile,Y INY BNE HA3.HAend PLA \drop extra offset JMP Nosuch \Allow other Roms to respond \ *****************************.Table \Table of Rom contents with xeqn addresses $EQUS "B" \Basic editor short form DDB BASED-1.Table2 \Start for Help file, entries above Table2 do not appear in *HELP $EQUS "BASED" DDB BASED-1 $EQUS "BLIST" DDB BLIST-1 \ $EQUS "CLR" \ DDB CLEAR-1 $EQUS "FKEYS" DDB FKEYS-1              \ $EQUS "MEDIT" \ DDB MEMEDIT-1 $EQUS "MOVE" DDB MOVECMND-1  \ $EQUS "ROMID" \ DDB ROMID-1 $EQUS "SPACE" DDB SPACE-1 \ $EQUS "TXCOPY" \ DDB TXCOPY-1  $EQUS "VLIST" DDB VARCAT-1  $EQUB 0 \End of Command table.Helptabl  $EQUS "BASED" DDB Helpaids-1 $EQUB 0 \End of Help table \ *************************** \Helpfile- each index entry has a string here ending CR. (or CR only).Helpfile $EQUB 13 \BASED $EQUS "<fsp>" \Blist $EQUB 13 \ $EQUB 13 \ CLR $EQUS "[key]" \FKEYS $EQUB 13 \ $EQUS "aaaa [@rom]" \MEDIT \ $EQUB 13 $EQUS " page|ssss ffff|+eeee dddd" \MOVE $EQUB 13 \ $EQUB " [rom address]"  \ROMID \ $EQUB 13 $EQUB 13 \SPACE \ $EQUB 13 \TXCOPY $EQUS "[HR$%PF]"  \VLIST $EQUB 13\****************************************\* CLR - POWER UP RESET EMULATION\****************************************.CLEAR LDA #127 STA &FE4E   \Disable all interrupts in system via JMP(&FFFC)  \Reset$END