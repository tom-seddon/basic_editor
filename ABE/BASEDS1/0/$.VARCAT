$START \ ************************ \ * VARCAT EPROM VERSION * \ * 6/86     IJW         * \ * ANY BASIC VERSION    * \ * OPTIONS =H%$(PFR     * \ ************************.G=&70 \Page 0 use...T0=G.T1=G+1.T2=G+2.T3=G+3.T4=G+4.T6=G+5.T7=G+6.Pad=G+7.Hexopt=G+8.Intopt=G+9.Stropt=G+10.Aryopt=G+11.Procopt=G+12.FNopt=G+13.Realopt=G+14.Trap=G+15    \BYTE.Return=G+16  \WORD.Oldvec=G+18  \WORD\******************************************.'VARCAT JSR Nextoscl CMP #"x" BNE normal JMP Continue \Re-entry.normal TYA PHA \Save oscli ptr JSR CheckBASIC \No return if not BASIC  LDA #&A8 LDX #0 LDY #&FF JSR OSBYTE \Get Extended vector base STX T0 STY T1 LDY #21 \Offset to OSWRCH LDA #HERE MOD 256 STA (T0),Y \Set extended OSWRCH vector INY LDA #HERE /256 STA (T0),Y INY LDA &F4 \This ROM no. STA (T0),Y LDA &20E STA Oldvec LDA &20F STA Oldvec+1 \Save current OSWRCH vector LDY #48 \Offset for eventV LDA #Event MOD 256 STA (T0),Y \Set extended EVENT vector INY LDA #Event /256 STA (T0),Y  INY LDA &F4 STA (T0),Y LDA #&30 STA &220 LDA #&FF STA &221 \Point EVENTV to extended handler at FF30 LDA #14 LDX #6 JSR OSBYTE \Enable Event 6, Escape pressed PLA TAY \Oscli offset  LDA #32 STA Pad \Default space STA Hexopt \Hex off LDA #0 JSR Set \Set all options on +ve.Optb JSR Nextoscl BEQ do_it \CR, do all CMP #"H" \Hex? BNE Opta STA Hexopt INY BNE Optb.Opta LDA #&80 JSR Set \Set all options off -ve DEY \Dummy to allow for first INY.Options JSR Skposcl BEQ do_it \CR found LDX #7.Opt2 CMP Table,X BNE Opt3 STA Pad,X \Set option ON, +ve.Opt3 DEX BPL Opt2 BMI Options.do_it LDA #"@" STA T0 \Start chr ASL Hexopt \Hex option, Make "H"(&48) go -ve, &80 go +ve, &20 +ve BIT Intopt \Test % option BMI DYNAMIC \Off.STATIC JSR SetPrint  LDA T0 JSR OSWRCH  \@..Z TAY LDA #138 LDX #0 JSR OSBYTE  \Insert in Key buff LDA #"%" JSR OSWRCH TAY LDA #138 JSR OSBYTE \X=0 still LDA Pad    \= JSR OSWRCH JSR Ampsnd \Check if & needed JSR NTOASCI \Get BASIC to print value.Stat INC T0  \Next chr @..Z LDA #91 CMP T0 BNE STATIC.DYNAMIC LDA #"@" STA T0          .Next INC T0 \Next chr A..z LDA T0 CMP #123 BNE Nx2 JMP ProcFn.Nx2 ASL A TAY LDA &400,Y TAX INY LDA &400,Y.NextQ BEQ Next.OK STX T1 STA T2 \(T1)=Addr of Variable LDY #1.What INY TAX \Save last chr LDA (T1),Y BNE What \Find 0 terminator of name CPY #2 BEQ real \Single chr name TXA LDX #3.What2 CMP Table+1,X \Check %$( BEQ found0 DEX BNE What2.real LDX #6.found0 LDA Pad+1,X \Test option BMI NWM \Off.Showit  JSR SetPrint \P.~ LDA T0 JSR NAME  \print Name and insert in key buff DEY CPY #1 BEQ Single LDA (T1),Y CMP #"(" BEQ ARRAY.Single PHA LDA Pad    \= or space JSR OSWRCH PLA CMP #"$" BEQ String JSR Ampsnd \Check if & needed.Integer CPY #23 \Y=length of name, max in keybuffer is 22, (=32-10 for P.~/*VL.//) BCC LenOk JSR SetPrint \Flush kbd, Reinsert P..LenOk JSR NTOASCI  \BASIC prints value.NWM LDY #0 LDA ( T1),Y TAX INY LDA ( T1),Y BNE OK JMP NextQ.String LDA #34 JSR OSWRCH \Opening Quote INY \inc past terminating 0 INY LDA (T1),Y STA T3 \Address of $ from sib INY LDA (T1),Y STA T4 INY INY LDA (T1),Y \length of $ TAX BEQ empty LDY #0.Str2 LDA (T3),Y \Print string contents JSR OSWRCH INY DEX BNE Str2.empty LDA #&22.Str3 JSR OSWRCH \Closing quote JSR OSNEWL LDA #21 LDX #0 JSR OSBYTE \flush key buff JMP NWM.ARRAY INY INY LDA (T1),Y CLD SEC SBC #1 CLC ROR A STA T6.Dims INY LDA (T1),Y STA &2A INY LDA (T1),Y STA &2B DEC &2A BCC @E+4 DEC &2B TYA PHA JSR OUTIAC DEC T6 BEQ Last LDA #"," JSR OSWRCH PLA TAY BNE Dims.Last PLA LDA #")" BNE Str3.ProcFn BIT Pad+5 \Test option BMI Again \Off, No PROCs LDA #&F6 \Cat' offset LDX #&F2 \PROC token.P STA T1  STX T0 LDA #4 STA T2 BNE R  .K LDA T0 JSR DECRUNCH \DECRUNCH TOKEN LDA #32 \Space JSR NAME.N LDA #32 JSR OSWRCH INY LDA (T1),Y STA T3 INY LDA (T1),Y STA T4 DEC T4 LDY #0 \Get Xeqn Addr.search DEY LDA (T3),Y CMP #13 BNE search \Find prev' CR TYA PHA LDX #3.Check DEY LDA (T3),Y CMP #13 BNE none \Check its not a line len or line# PLA TYA PHA.none DEX BNE Check PLA TAY INY LDA (T3),Y STA &2B \Line#Hi INY LDA (T3),Y STA &2A \Line#lo JSR OUTIAC \PRINTline#in dec. JSR OSNEWL.R LDY #0 LDA (T1),Y TAX INY LDA (T1),Y STA T2 STX T1 BNE K.Again BIT Pad+6 BMI Done \No FNs LDA #&F8 LDX #&A4 \FN token CPX T0 BNE P.Done JMP VExit \Finished\****************************************************.NAME \Print name and insert in keybuff, A=first chr  LDY #1.M JSR OSWRCH TAX \SAve chr TYA PHA \Save index TXA TAY \Chr in Y LDX #0 LDA #138 JSR OSBYTE \Insert in key buff PLA TAY \Index INY  LDA (T1),Y BNE M.LAST RTS \****************************************************.Set \Set all option switches to A LDX #7.Set2 STA Pad+1,X DEX BNE Set2 \leave Pad and Hex alone RTS.Ampsnd LDA Pad AND Hexopt \Hex option BEQ Amp2 LDA #"&" \If Hex and pad= add & JSR OSWRCH.Amp2 RTS.Table $EQUS "=H%$(PFR"\*******************************************          .SetPrint \Insert P. in key buff.. LDA #21 LDX #0 JSR OSBYTE \flush kbd LDA #138 LDY #"P" LDX #0 JSR OSBYTE LDY #"." JSR OSBYTE BIT Hexopt BPL SP2 LDY #"~" JSR OSBYTE.SP2 RTS\******************************************.NTEXT$EQUB 13 \CR$EQUS "*VL." \Command to get back$EQUB "x" \parameter - reentry$EQUB 13 \CR$EQUB 0         \*******************************************\ BASIC is used to print value by inserting \ 'P.name' in keybuffer, followed by command\ to get back to VLIST.\********************************************.NTOASCI LDX #0.NT1 LDY NTEXT,X BEQ NT2 TXA PHA LDA #138 LDX #0 JSR OSBYTE  \Insert ;<CR> *VL.X <CR> PLA TAX INX BNE NT1.NT2 PLA STA Return PLA STA Return+1 \Save callers address LDA #0 STA Trap \Set +ve off LDA #&15 STA &20E LDA #&FF STA &20F \Point OSWRCH to Extended vector handler at FF15 JMP Alldone \Return to BASIC, which will print Value?! .Continue \Get back here after printing value LDA Oldvec STA &20E   \Restore OSWRCHV LDA Oldvec+1 STA &20F BIT &FF \Escaped? BMI VExit LDA Return+1 PHA \Restore callers address LDA Return PHA  RTS         .VExit                     LDA #13 LDX #6 LDY #0 JSR OSBYTE \Disable Escape event LDX #0 LDA #21 JSR OSBYTE \Flush key buff  JMP Alldone                               \****************************\ OSWRCH HANDLER\****************************.HERE \OSWRCH gets here  BIT Trap BMI Trap2 \On CMP #13 BNE Trap1 \Not CR DEC Trap \set trap -ve.Trap1 RTS \Sink first and last lines, (trap +ve).Trap2 JSR Oldoswrch CMP #13  \CR? BNE Trap3 INC Trap \+ve,end of line we want to show.Trap3 RTS.Oldoswrch JMP(Oldvec) \*******************************\ ESCAPE EVENT HANDLER\*******************************.Event PHA TYA PHA TXA PHA LDA #13 LDX #6 LDY #0 JSR OSBYTE \Disable event 6 LDA Oldvec STA &20E \Restore OSWRCH LDA Oldvec+1 STA &20F LDA #125 JSR OSBYTE \Set escape PLA TAX PLA TAY PLA.not6 RTS  $END