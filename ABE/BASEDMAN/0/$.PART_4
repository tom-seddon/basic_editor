ÄTSON 5ÄDH//The Advanced BASIC Editor//ÄDF//Page |P//ÄTM0ÄHM1ÄFM1ÄLM3ÄBM1ÄPL66ÄSRP 20Å.........*.......*.......*.......*.......*.......*.......*.......*.....<   ÄCE3.0  THE ADVANCED BASIC EDITOR UTILITIES3.1 IntroductionThe Advanced Basic Editor Utilities are accessed either from theeditor's command screen or directly from BASIC. The majority of theseutilities can be selected from a menu which is obtained by pressing *Bfrom the command screen or from BASIC. Alternatively type UTILS fromthe ABE command screen. The menu display is as follows:	E Enter Search$	L List Matches	N Number of Matches	G Global Replace	S Selective Replace       B Bad Program Relink	C Copy	F Format Listing	M Move	P Pack	R Renumber	T Table Line References	U Unpack	V Variables Xref	Search$:	Ready:__The routines include selective or global search and replace, afacility to recover corrupted programs, intelligent block copy andmove (i.e. automatic renumbering of GOTO's etc.), source codecompaction and a corresponding recovery facility, and tables ofvariables or GOTO's cross referenced to the line numbers at which theyoccur. These routines are activated by pressing the first letter ofthe command (as indicated in the menu) at the "Ready:_" prompt.Whilst in the utility environment, the current program (as pointed toby "PAGE") can be listed on the screen by pressing F at the "Ready_"prompt to give an indented listing. Alternatively, a listing instandard LISTO1 format can be obtained by pressing @ (SHIFT 0) at the"Ready_" prompt. In either case, paged mode can be pre-selected withCTRL N and de-selected with CTRL O. It is also de-selected by RETURNon an empty line or any invalid entry, both of which cause the abovemenu to be re-displayed.Additionally, all screen output can be echoed to a printer following aCTRL B. This is disabled with CTRL C or by causing the menu to bere-displayed.ÄPEPaged mode and printer output are both disabled on entry to the TheAdvanced BASIC Editor environment.To return to the Advanced BASIC Editor command screen press the ESCAPEkey.The following sections detail the available utilities under the groupheadings of "Search and Replace", "Moving, Copying and RenumberingLines", "Packing and Unpacking", "Cross Reference Tables",and"Recovery of Bad Programs".Additional functions are also available such as *VLIST - a selectivelisting utility for variable values; and *BLIST - a facility forlisting source code from a program stored on disk without replacingthe current program held in volatile memory (RAM); These additional functions are NOT accessed from the *B menu, but areavailable separately from the command screen of the Advanced BASICEditor  or directly from BASIC. On completion of the chosen utility(or abortion using ESCAPE) control returns to the Advanced BASICEditor command screen.These utilities are detailed in sections 3.8 and 3.9 3.2 Search And Replace Utilities3.2.1  General		This section details the following utilities, L-List matching lines;N-Display the line numbers at which matches occur; G-Replace alloccurrences of the search string with the replace string; S-Onlyreplace selected occurrences of the search string; and H-Display Howmany matches were found.All of these routines require a search string (Search$) to be inputfirst (E-Enter Search$).Throughout this section "Search$" and "Replace$" are used to denotethe search or replace string as it is entered at the keyboard inresponse to the appropriate prompt.		           3.2.2 E Enter Search$After  entering  a  search$  the  current program is searched for anymatches with the new search$  and  the  number  of  matches  is  thendisplayed. A recount can be done at any time by using "H" (How many),and is done automatically every time the menu is displayed.          The search string may be up to 80 characters and after  input  it  istokenised  in  the same way as normal BASIC program lines. This meansthat Basic reserved words must be entered in full or in their properabbreviated form, ie to find PRINT X% the input is either PRINT X% orP. X%  ,   but  not  NT X%  or similar. Embedded character codes ( >&7F - Teletext control etc.) are input viathe normal shift/ctrl  function keys.  Control  codes  (ASCI  3  to ÄPE31) can be entered by the normal Ctrl-Key, as they are not executed oninput. This allows CtrlU to  be entered but it cannot be used todelete the input line. Control codes are  shown  by  |U  or |G etc.(See later section on special syntaxes that use Ctrl@/A/B aswildcards).Escape during input abandons the new line  and  leaves  the  previoussearch$ as the current one.Note that search is case sensitive.          3.2.3  L List match lines          This  is a selective list function. All lines containing the search$are listed (in LISTO1 format) with the search$  highlighted  in  eachcase.Å..       >.......*.......*.......*.......*.......*.......*.......<       To list without the highlighting use CtrlL.ESCAPE restores the "Ready" :- prompt.(ESCAPE before the prompt reappears will stop thelisting.) ESCAPE again at  the  prompt exits the utilities anddisplays the ABE command screen, thus allowing normalscreen editing on the listed lines, (also see section onKeyboard mode "K").Use paged mode (CTRL N) to prevent lines scrolling offscreen.Å.........*.......*.......*.......*.......*.......*.......*.......*.....<         Typical uses of this function might be  to  find  all  calls  of  aspecific  PROCEDURE  or  FUNCTION,  or  all  uses  of  a   particularvariable. e.g.	Using  DEF  as  the  search$  will  list  all  the FN/PROCdefinition  lines.  e.g.	Using  '.' as the search$ will list all labels in assemblerlistings, etc..etc...          3.2.4  N Number match lines          Displays the line numbers of all program  lines  that  include  thesearch$.  A  line  number  is  only  shown  once,  no matter how manyoccurrences it contains.3.2.5  G,S - Global And Selective Replacement          These commands allow  a  search$  to  be  automatically  replaced  byanother different string, the Replace$. This may be longer or shorterthan  the  original search$, or non-existent (deletion). The replaceis tokenised in the same way as the search$  and  may  be  up  to  80characters long.ÄPESELECTIVE  replacement  lists every line concerned and highlights thestring to be replaced. A prompt 'Replace? Y/N:'  is  given.  Any  keyexcept Y means NO, and the next replacement will be listed. Y for YESwill  cause  the  replace$ to be inserted into the program instead ofthe search$.GLOBAL replacement will  replace  every  occurrence  of  the  search$without  asking  every  time. For this reason don't use global unlessyou are very sure that you mean EVERY  occurrence;  check  using  "L"(3.2.3 above).           3.2.6  DELETION Using Replace FunctionsIf the replace$ is nonexistent then it  effectively  deletes  the search$  from  the  relevant lines. An extension to this facility isthat lines may be  deleted  up  to  the search$ from the left, or fromthe search$ to the end of the line.A  "["  as the first character of a replace$,  deletes the line fromthe beginning upto and including the  search$.  If  the search$  isincluded in the replace$ then it is a delete exclusive of the search$.If the last character of the replace$ is "]" all the line  from  thesearch$ up to the end of the line will be deleted.                 Summary: (S$ means Search string)                Replace$   Result       (i)      [        Delete line up to and including search$.       (ii)     [S$      Delete line up to search$.       (iii)    ]        Delete line from start of search$ to end.       (iv)     S$]      Delete line from end of search$ to end of line.       (v)      []       Delete entire line.                 Example: Remove all REMs from program:                Search$=  REM                Replace$= []         3.2.7  WILDCARDS in the Replace$:If any of the wildcards (ctrl@,A,B) are included in the Replace$ theyform a window on to the corresponding byte in the search$, which willthen appear in the final modified text, ie:              Search$  TAB(@#,6)        Matching text  TAB(9,6)             Replace$  TAB(@#,8)       Resulting text  TAB(9,8)Note  that "corresponding" means at the same byte position, so if thereplace$ is different in length to the search$ take great care  usingwildcards in the Replace$.          All wildcards are displayed as a block,"@#" in any listing of searchor replace lines.ÄPE          CTRL @  :  A  general wildcard character can be inserted into a search(or replace) by CTRL @. This will then  match  any  character  in  theprogram line text.          CTRL A  :  A  "non  numeric"  wildcard is produced by CTRL A. Thiswill match against any character which is NOT  a  NUMBER  (0-9).  This is useful when trying to find specific numbers in a program, i.e. To find  all  occurrences of 39: A search$ of '39' would match 399 or 539or 2390 as well as just 39. Using non numeric wildcards for a  search$ of'@#39@#'(CTRL, A, 3, 9 CTRL A) will only match against '39' inprogram text.          CTRL B  :  A  "non  variable" wildcard is produced by CTRL B. Thiswill match with any character that cannot form part of a variable name(or PROC/FN name). This  eases  matching  variable  names  by preventing matches with similar but longer names, e.g.:A  search$  of  'X%' will match with dX%, MAX%, UNIX%, X% etc., but asearch$ of '@#X%' (CTRL-B X%) will only match X%  because  the wildcard cannot match with d,A or I.Note  that  a  CTRL-B  wildcard  at  the start of a search$ excludesnumbers 0-9, as a variable name cannot start with a number.Ampersands (&) are taken to be valid variable name  characters,  thisprevents a search for the variable FAB1 matching  &FAB1 or similar.         3.2.8	ASCII Strings          If  the  Search or replace input is not to be 'tokenised', ie to findthe ASCII string RESTORE PAGE rather than the tokenised form (&F790),precede the input with a quotation mark ". The mark must be the FIRSTcharacter of the input string, and does not itself form part  of  thesearch  or  replace  string. A quote which is not the first characterforms part of the string in the normal way.3.2.9	Line Numbers          @@ as the FIRST characters in an entry string  cause  any  immediatelyfollowing  number  to  be converted into internal line number format.This  allows  searching  for  any  reference  to   a   line   number,irrespective  of  whether it follows GOTO,GOSUB,THEN,RESTORE or is inan ON Variable GOTO/GOSUB sequence.This syntax is necessary as line numbers are not  held  in  ASCII.  Anumber  following GOTO etc. is converted into a special binary formatin 3 bytes, and is preceded by a byte marker (&8D). A simple  searchfor "520" would not find GOTO 520, and a search$= GOTO 520 would notfind GOTO 520 etc.It  is  especially important to use the correct format if you wish toinclude a line number in a replace$. ie:To change ALL references to line 845 to 1040:          Search$=@@845         Replace$=@@1040ÄPE          @@ has been chosen as @% is the only valid syntax in BASIC  using  @,so @@ would not normally occur.          Note that @@CTRL@ will find all line number references.Any text following the @@number is tokenised in the normal way. If @@is not followed by a number or CTRL@ it is ignored.          Remember that @@ only works as the first characters in a string.3.2.10  Errors          Variable Names The Same As Text (e.g. INPUT"Distance", Distance)In  List, Number, Global Replace and Selective Replace no distinctionis made between text and variable names. This will only cause  a problem  if  Global replace  is  used,  so  you  must  be  very  sure you require global replacement.		Problems From Token Codes vs ASCII Codes vs Line Numbers.In BBC Basic bytes > &7F are 'Tokens' and represent  reserved  words,PRINT,  FOR,  NEXT  etc.  However when within quotes codes &81 to &9Frepresent Teletext/Mode7  control  codes.  Thus  searching  for  STEP(token  &88)  would  form  a match with the embedded teletext controlcharacter for FLASH ON, such a match will be taken as true, and causea spurious result.Any byte value &40 to &7F may form part of an  internal  format  linenumber after GOTO etc. Searching for characters "@" to "~" (ASCII &40to  &7E) may thus match against line number bytes and then be countedor listed as a match. Replace however checks  all  matches  for  linenumber  markers  (&8D).  (Note  that  the  marker  itself is also theTeletext code for double height!).This type of mismatch is only likely to occur when using single ASCIIcharacter search$'s, ie searching for 'T'  will  match  against  GOTO12345, but 'T%' would be unlikely to match a line number.      Embedded TELETEXT Control CodesAs  explained above the Teletext/Mode7 control codes are the same assome Tokens. If a program contains such  control  codes  embedded  intext, mismatches will occur in List, Number, Global Replace andSelective Replace. Again this only presents a real problem for Globalreplacement.The  one  code  that  can cause real problems is &8D, as this is thecode for double height and also the token for line number bytes afterGOTO/GOSUB. An &8D embedded in a string as a control code will confuse  any  of the  functions, however, the Replace Utilities willnot change the three bytes following a &8D, to  prevent corruption ofGOTOs etc.    Embedded VDU/CTRL CodesWhen  a line is listed by @,L, or F any embedded VDU codes (ASCII 0 toÄPE&1F), are shown as  G,  U etc. Subsequently use  of  the  screeneditor on such lines will not insert the original codes.3.3 Move, Copy and Renumber Blocks3.3.1   R - Renumber         Allows partial renumbering of program line numbers, unlike the normalBASIC  renumber  which  only  does the whole program. Input syntax isgiven as a prompt: Start,(Finish),Newstart,(Step)?_Å..       >........*.......*.......*.......*.......*.......*.......<          "Start" is the current number  of  the  first  line  to be  renumbered (inclusive)."Finish (optional)",  is the number of the last line to berenumbered. If it is omitted the last line of the programis assumed."Newstart" is the required new number of the Start line."Step (optional)", is the required step between the new line  numbers, minimum value  1,  max  255. If the step isomitted a value of 10 is taken.Å..>.......*.......*.......*.......*.......*.......*.......*.......*.....<Examples:	315,420,200,5 :Renumbers lines 315 to 420 as 200,205,210 etc.	315,420,200   :Uses the default step of 10, to give 200,210..	315,,200      :Renumbers 315 to the end of the program as 	               200,210...	315,315,200   :Renumbers just line 315 as line 200.          All GOTOs etc to the renumbered  lines  are  updated  throughout  theprogram.         Note:  This  routine  does  not produce any "Failed at line nn" errormessages.                    ÄCERENUMBERING DOES NOT CHANGE THE ORDER OF LINES WITHIN THE PROGRAM.3.3.2   M - Move lines          Moves a line or block of lines to a new position in the program,  andupdates  any  GOTOs  to those lines to reflect the new numbers. Inputsyntax is as for Renumber, except that if Finish is  not  given  onlythe Start line is moved."Start" is the current number  of  the  first  line  to  be  moved(inclusive)."Finish (optional)",  is the number of the last line to be moved.ÄPE"Newstart" is the required new number of the moved lines."Step (optional)", is the required step between the new  line  numbers,minimum value  1,  max  255. If the step is omitted a value of 10 istaken.Examples:	200,210,500,5  :Moves lines 200 to 210 (inclusive) to lines	                500,505...	200,,495       :Moves line 200 only to be line 495. viz:          	190 REM line	200 IF X=0 THEN...	210 PRINT"..	.	490 A=1	500 B=0becomes      	190 REM line	210 PRINT"..	.	490 A=1	495 IF X=0 THEN...	500 B=0         Note: Move  will not overwrite  existing  lines  with  the  same (new) numbers,  a  gap in the numbering big enough for the new lines mustexist first. Renumber can be used to produce such a gap.3.3.3   C - Copy lines        Produces  a  copy  of a line or block of lines in another position inthe program, leaving the original line(s) in position. Any  GOTOs  tocopied  lines  from within  those  new  copied lines are updated, butothers are left pointing to the original lines.	Input syntax is as for Move. Eg:          	200,210,300,2 :Copies lines 200 to 210 into lines 300,302..;ie.          	200 X=GET-48	210 ON X GOTO 50,90,120 ELSE 200	220 REM Rest of prog..       	300 X=GET-48	302 ON X GOTO 50,90 120 ELSE 300Note that the reference to 200 has been changed to 300, as  line  200was  a copied line, but the other references have not been changed asthey are to lines which were NOT copied.        Note: Copy will not overwrite  existing  lines  with  the  same (new) ÄPEnumbers,  a  gap in the numbering big enough for the new lines mustexist first. Renumber can be used to produce such a gap.3.3.4   Errors In Renumber/Move/Copy:Possible error messages are:Å..        >.......*.......*.......*.......*.......*.......*.......*.....<(a) "Lines > 32767" : The new numbering scheme would require         numbers greater than the maximum allowed of 32767.(b) "Overlap  at nn" : The new numbers would clash withexisting line numbers that are not being changed.(c) "Syntax error" : This can be caused by any of thefollowing:	-Start or Newstart not given. 	-Missing comma between fields.	-Line number > 32767.	-Step of 0 or greater than 255 given.	-Finish < Start.	-Non numeric character included.	-Newstart lies between Start and Finish		 (Move/Copy only).          Å.........*.......*.......*.......*.......*.......*.......*.......*.....<3.3.5   Embedded TELETEXT Control CodesAs  explained above the Teletext/Mode7 control codes are the same assome Tokens. If a program contains such  control  codes  embedded  intext, mismatches will occur in List, Number Global Replace andSelective Replace. Again this only presents a real problem for Globalreplacement.The  one  code  that  can cause real problems is &8D, as this is thecode for double height and also the token for line number bytes afterGOTO/GOSUB. An &8D embedded in a string as a control code will confuse  any  of the  functions, at worst the three bytes followingmay be changed by Renumber, Move, or Copy.3.4 Packing And Unpacking Programs3.4.1   P - Pack Program          The object of Pack is to try to reduce the amount of memory  occupiedby  the  program.  It  does  this  by  5  means, each of which can beselected or not by answering the questions prompted at the start:          	REMs?	Spaces?	Comments?	Variables?  	Use unused singles?	Concatenate?                 (answer "Y" to remove REMs etc)ÄPEREMs: Removes all the REM statements from the  program.  Ensure  thatthe  program  contains  no  GOTO/GOSUBs  to  lines  consisting of REMstatements only.          Spaces: Removes all  unnecessary  spaces,  including  those  normallyrequired  for correct syntax during input, ie. IF A=B THENC=0 becomesIFA=BTHENC=0, which could not be entered directly as BTHENC would  betaken  as a single variable. This means that great care must be takenediting a program if it has been packed.          Comments: Removes comments from any  assembler  listings.  Note  thatthis  only  affects  a  comment from the "\" delimiter up to the nextseparator (colon or CR), where deleting REMs removes the whole of therest of the line.          Variables: This attempts to shorten all variable, PROC and  FN  namesto one or two letters. The rules are:Å.........>.......*.......*.......*.......*.......*.......*.......*.....<(a) If the name is already single character, does nothing.(b) Tries the first letter of the name as a single letter name.(c) If the name is only two letters long, does nothing.(d) Tries  a  two  letter name consisting of the first twoletters of the current name. If this fails it takes the first and  third  letters,  then  the first  and  fourth  etc.  Ifall these fail it tries the first letter plus a letter from Ato z in turn.(e) If  all  combinations  should  fail,  leaves  the  variable name unchanged.(f) PROC  and  FN names are always condensed to a single lettername, following the general rules above.          Å.........*.......*.......*.......*.......*.......*.......*.......*.....<As each variable is changed the old and new names will  be  displayedin pairs, together with the number of occurrences. ie:	A$ [6]	Klingon% [3]   K%	Key% [15]      Ke%	Record$ [69]   R$	PROCwrite [4]  PROCw        The  order  of  change  is  first  letter alphabetic, then in programorder. The length of a name excludes any %,$ or ( suffix.Use unused singles: When packing variable names the  resultant  shortnames  normally  start with the same letter as the original. By using'unused singles' further space  can  be  saved,  at  the  expense  ofprogram  legibility.  The  program will try any unused initial lettersas single character names before reverting to two characters, as in (c) above.          Concatenate:  This attempts to add short lines together to form linesup to the maximum length allowed, thus saving the line overhead bytes(4 bytes per line, less 1 for  the  extra  colon  required).  Certainlines cannot be concatenated, such as those including IF,DATA,REM,DEFetc  and  those  that  are  targets of GOTOs etc.; these are all leftalone.ÄPE          Before packing, the value of TOP is  shown,  as  packing  proceeds  asecond  line  shows  the  current  value  of  TOP  as  the program isshortened. The total number of bytes saved is shown on completion.                  In order to get the best result from packing, variable  names  shouldbe  packed  BEFORE  concatenating lines. Also note that concatenationmay produce errors if Spaces have not been stripped out first.                    ÄCEALWAYS SAVE A COPY OF THE PROGRAM BEFORE PACKING IT.3.4.2   U - Unpack          The  opposite  of  PACK  !.  Puts  every statement on a new line, andinserts sufficient spaces to restore the  correct  syntax  for  screenediting.          If  there  is insufficient room in the line numbering for the requirednew lines, an error message is displayed, and no unpacking  is  done,	eg:          	Renumber line(s):	500,  620,  931   If a line would become too long after insertion of spaces, it is leftin its packed form.3.4.3  Errors In Packing And UnpackingVariable Names The Same As Text (e.g. INPUT"distance", distance)The replacement of variable names by Pack does NOT replace text withinquotes, i.e. the above example might becomeINPUT"Distance",DiThis means that variable names and text cannot be distinguished inDATA statements if the text is not enclosed in quotes.Embedded VDU/CTRL CodesWhen  a line is listed by U, any embedded VDU codes (ascii 0 to &1F),are shown as  G,  U etc. Subsequently use  of  the  screen editor onsuch lines will not insert the original codes.Assembler If the program contains assembler statements the following apply:ÄPE