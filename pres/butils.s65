
;  CONTROL FILE FOR  ALTRA ELECTRON BASED, VERSION 1.602
;  ( founded on PROBE VERSION 6.02 )

*= $8000
                ; $ORGV $8000

;-------------------------------------------------------------------------

; BASEDS1 refers to BASEDS1.SSD from Dave H's diski mages.
                
                .weak

; If true, exclude ROMID, MEMEDIT and TXCOPY. As per the code supplied
; on BASEDS1.
baseds1_version=false

; If true, include ROMID, MEMEDIT and TXCOPY, but don't follow through
; to fix up anything else. As per the code on BASEDS1, but with the
; relevant $INCLUDEs in !MAKROM uncommented.
;
; (this is included just because I built this particular configuration
; on the Beeb, so it's an additional test case for the code
; conversion)
baseds1_all_version=false

; If true, build ROM matching the prefix of ELK from BASEDS1.
;
; Presumably ELK is a 16 KB dump from reused sideways RAM. The output
; is from this is $29e5 bytes, matching the first $29e5 bytes of ELK.
; Then what looks like some code around CR_3: sta $af, sta Quote, jsr
; Byte_1 - and so on.
baseds1_elk_version=false
                .endweak

;-------------------------------------------------------------------------

include_ROMID=!baseds1_version&&!baseds1_elk_version
include_MEMEDIT=!baseds1_version&&!baseds1_elk_version
include_TXCOPY=!baseds1_version&&!baseds1_elk_version

;-------------------------------------------------------------------------

; $ATD ELECTRON
;  $ORGS &F00

                ; $ERROR 7,0,W
                ; *FX214,1

;  SPY's DDB, Hi_Lo
DDB:            .macro X
                .byte (\X)/256
                .byte (\X) % 256
                .endmacro

                ; $LIST 1,0

                ; include_start: OSLIB


; OSLIB
OSRDRM=$FFB9
OSEVEN=$FFBF
GSINIT=$FFC2
GSREAD=$FFC5
OSFIND=$FFCE
OSGBPB=$FFD1
OSBPUT=$FFD4
OSBGET=$FFD7
OSARGS=$FFDA
OSFILE=$FFDD
OSRDCH=$FFE0
OSASCI=$FFE3
OSNEWL=$FFE7
OSWRCH=$FFEE
OSWORD=$FFF1
OSBYTE=$FFF4
OSCLI=$FFF7

                ; include_end: OSLIB



                ; $IF @P=2
;  $VDU 2
                ; $ENDIF

                ; include_start: HEADER

;  * * * * * * * * * * * * * * * * * * * * * * *
;  * ELECTRON BASED
;  * EPROM HEADER  + Common subroutines        *
;  * VERSION 6.0X  May 86                      *
;  * FOR USE WITH ELECTRON                     *
;  * based on Probe 6.02
;  * * * * * * * * * * * * * * * * * * * * * * *

                brk             ; No Language entry
                brk
                brk

                jmp Reason      ; Service entry

                .byte $82       ; Service & Language Rom
                .byte Offset_0-$8000; Offset to 0(C)
                .byte 6         ; Version#

Romname:
                .if baseds1_elk_version
                .text "Altra Electron BasicEd DEMO 2"
                .else
                .text "Altra BasicEd (Electron) "
                .endif
                .byte 0
                .text "1.60"    ; Version$

Offset_0:       .byte 0
                .text "(C)1988 IJW"
                .byte 0

Reason:         pha
                txa
                pha
                tya
                pha
                tsx
                lda $103,x      ; Get A back
                cmp #4
                beq Command
                cmp #9
                beq Help
                cmp #3
                bne Nosuch

Boot:
                jsr Romtitle    ; Print Romtitle on Break
                jsr OSNEWL

Nosuch:         pla             ; Restore AXY and rtn, not done
                tay
                pla
                tax
                pla
                rts

Command:                        ; (F2),Y=OSCLI$
                lda #$FE        ; Offset to command table-2
                bne Search_0

Help:
                jsr Nextoscl    ; Get chr from OSCL$
                bne Fullhelp    ; If CR only print Rom$..

                jsr Romtitle
                jsr Rt2         ; Print Version$, Romtitle left Y pointing at Version$
                jsr OSNEWL
                jsr Printmsg
                .text " BASED"
                .byte 0
                jsr OSNEWL
                jmp Nosuch

Fullhelp:       lda #(Helptabl-Table_0-2); Offset to help table-2
; Search- compares OSCL$ with table of Rom contents, xeqs if match

Search_0:
                pha
                tax
                jsr Search2
                bcc Xeqn        ; Found
                tay             ; Original offset
                pla
                tax
                jsr Nextoscl
                cmp #"A"        ; PREFIX CHR$, A=Altra
                bne Nosuch
                iny             ; Skip any prefix A
                jsr Search2
                bcs Nosuch
                pha             ; dummy

Xeqn:           pla             ; X
                tya
                pha             ; Save new offset under original
                lda Table_0,x   ; Xeqn addr Hi
                pha             ; on stack
                lda Table_0+1,x ; Xeqn addr Lo
                pha
                rts             ; Jump to it. Addr is byte before routine

Search2:
                tya
                pha             ; Save pseudo offset
Start_0:        inx
                inx             ; Skip xeqn addr
                pla
                pha
                tay             ; Get offset
                jsr Nextoscl    ; Get byte from OSCL$
                iny
                lda Table_0,x   ; Get byte from rom table
                bne Continue_0  ; 0=end of table
                pla             ; Drop pseudo offset
                sec             ; C=1 for notfound
                rts

Continue_0:     dex
                dey
                dey
Match_0:        inx
                iny
                lda Table_0,x   ; Rom byte
                bmi End         ; End of Rom$
                eor($F2),y      ; Compare with OSCL$ byte
                and #$5F        ; force uppercase
                beq Match_0     ; If=0 chrs match,try next
                dex             ; Chrs not matching
Skip_0:         inx
                lda Table_0,x
                bpl Skip_0      ; Skip rest of Rom$
                lda ($F2),y     ; Get OSCL$ byte again
                cmp #"."        ; Abbreviation?
                bne Start_0     ; no, try next Rom$
                iny             ; next OS chr
                bcs Xeq         ; Go do it
End:            lda ($F2),y
                and #$DF        ; Upper case
                cmp #$41        ; If next chr is A-Z
                bcc Xeq         ; OSCL$>Rom$ length
                cmp #$5B        ; so no match
                bcc Start_0

Xeq:            pla             ; drop pseudo offset
                clc             ; C=0 found
                rts

Alldone:        pla             ; Drop secondary offset
                pla             ; Restore AXY and rtn with A=0
                tay
                pla
                tax
                pla
                lda #0
                rts

;  *********************************

Printmsg:                       ; Print msg upto 0, rtn to byte following. Uses A,Y
                pla
                sta $AE
                pla
                sta $AF
Msgout:         inc $AE
                bne *+4
                inc $AF
                ldy #0
                lda ($AE),y
                jsr OSASCI
                tay
                bne Msgout
Msgends:        lda $AF
                pha
                lda $AE
                pha
                rts

Printit:        pha             ; chr in A to printer only
                lda #1
                jsr OSWRCH
                pla
                jmp OSWRCH

Printer:                        ; Message to printer only
                pla
                sta $AE
                pla
                sta $AF
Nxtp:           inc $AE
                bne *+4
                inc $AF
                ldy #0
                lda ($AE),y
                beq Msgends
                jsr Printit
                jmp Nxtp

; *******************************

;  Skip over spaces in OSCL$,rtn next chr in A, Z=1 if A=CR
Skposcl:        iny
Nextoscl:       lda ($F2),y
                cmp #32
                beq Skposcl
                cmp #13         ; CR?
                rts
Space2:         jsr Space1
Space1:         lda #32
                jmp OSWRCH

;  * Routine to print IAC in decimal *
OUTIAC:         lda #0          ; In zero field
                beq *+4
LINIAC:         lda #5          ; In 5 field (line#)
IACOUTA:        tax             ; Field width
                lda $2A
                sta $AE
                lda $2B
                sta $AF         ; Transfer IAC to scratch
                jmp IACOUTA2
OUTIAC2:        ldx #0          ; Print (AE) in decimal
                beq IACOUTA2
LINIAC2:        ldx #5          ; In 5 field
IACOUTA2:                       ; Fieldwidth in X
;  PRINT AE/AF in decimal
;  Enter with X= required print field width
;  Uses A,X,Y
                lda #$80        ; Terminator chr
NXTDIG:         pha
                dex             ; Dec leading zero count
                ldy #16         ; Bit counter
                lda #0
                sec
                sbc #$80
Roll:           rol a
                cmp #10
                bcc Nsub
                sbc #10
Nsub:           rol $AE
                rol $AF
                dey
                bpl Roll        ; Loop 17 times
                bvc NXTDIG
                pha
                bvs P4
P1_0:
                jsr Space1      ; Print leading spaces
P4:             dex
                bpl P1_0
P2_0:           pla
P3_0:           ora #$30        ; Make ascii
                jsr OSWRCH      ; Print digits
                pla
                bpl P3_0
                rts
;  *********************************

Hex_asci:                       ; Print A in Asci hex via OSWRCH. Uses A only
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr Nybble
                pla
Nybble:                         ; Print LSN of A in hex
                and #$F
                cmp #10
                bcc Number
                adc #6          ; C=1, so +7
Number:         adc #$30
                jmp OSWRCH      ; Print it and RTS


; ERROR-EXIT Syntax is JSR Errorexit, Error#, Message, 0
Errorexit:      pla
                sta $AE
                pla
                sta $AF         ; (AE),1 pts to Error#
                ldy #0
                sty $100        ; Set BRK
                iny             ; =1
                lda ($AE),y
                sta $101        ; do err#seperate to allow 0#
EE1:            iny
                lda ($AE),y
                sta $100,y      ; Build mssg in stack space
                bne EE1         ; until 0 terminator found
EE2:            jmp $100        ; Let lang rom handle error, lets basic REPORT work



; YES/NO checks KB for Y or N(default), prints Y/N as rqd, rtns Z=1 for Yes, Z=0 for No
YESNO:          lda #15
                ldx #1
                jsr OSBYTE      ; Flush input buffer
YESNO2:         jsr OSRDCH      ; Get input
                bcs No          ; Escaped?
                and #$5F
                cmp #"Y"
                beq Answer
No:             lda #"N"
Answer:         php
                jsr OSWRCH      ; Print Y/N
                jsr OSNEWL      ; CR
                plp             ; Restore Z as answer
                rts

;  *********************************

; * DEC-BIN, Convert decimal asci$ to binary, 0 to 32767
; Enter (F2),Y pointing to first chr of $, X=addr of 2 byte result
; Rtns C=1 if result OK, Z=1 if terminator=CR
; Rtns next non space chr in A, (F2),Y pointing
; If first chr not decimal leaves result bytes as found (ie default)

DECBIN:         lda ($F2),y
                jsr Decimal
                bcs number      ; first chr ok
end:            jsr Nextoscl    ; get next non space chr
E1:             sec
                rts             ; Rtn C=1 if result ok
number:         sta 0,x         ; Result lo
                lda #0
                sta 1,x         ; Clear result hi
DB1:            iny
                lda ($F2),y     ; Next chr
                jsr Decimal
                bcc end         ; not a number
                pha
; Multiply existing result *10
                lda 1,x
                pha
                lda 0,x         ; Result lo
                asl 0,x
                rol 1,x         ; *2
                bmi Toobig2
                asl 0,x
                rol 1,x         ; *4
                bmi Toobig2
                adc 0,x         ; C=0
                sta 0,x
                pla             ; Old result hi
                adc 1,x         ; *4+*1=*5
                asl 0,x
                rol a           ; A=New result hi,=*5*2=*10
                bmi Toobig1
                bcs Toobig1
                sta 1,x
                pla             ; New digit
                adc 0,x         ; C=0
                sta 0,x
                bcc DB1
                inc 1,x
                bpl DB1
                bmi bad
Toobig2:        pla
Toobig1:        pla
bad:            clc
                rts             ; Rtn C=0 if too big or non numeric

Decimal:        cmp #$3A
                bcs bad         ; >9
                cmp #$30
                bcc bad         ; <0
                and #$F         ; binary
                rts             ; C=1 if number ok

;  *******************************

;  HEXBIN convert asci Hex $ to binary in AE/AF, values 0-FFFF
; Enter (F2),Y pointing to first chr
; Rtns C=1 if ok, Z=1 if terminator chr is CR
; Only valid terminator is space or CR, else rtns C=0
; Rtns next non space chr in A, (F2),Y pointing
;  If first chr is not hex leaves AE/F alone

HEXBIN:         lda ($F2),y
                jsr Hex
                bcc bad         ; Rtn C=0, bad hex first digit
                ldx #0
                stx $AE
                stx $AF         ; Zero result bytes
HB1:            asl a
                asl a
                asl a
                asl a           ; Move into MSNybble
                ldx #4
HB2:            asl a
                rol $AE
                rol $AF
                bcs bad         ; Result >FFFF
                dex
                bne HB2
                iny
                lda ($F2),y     ; Next digit
                jsr Hex
                bcs HB1         ; Hex Ok
                cmp #32         ; Space?
                beq end         ; Rtn C=1, OK
                cmp #13         ; CR?
                beq E1          ; Rtn C=1,Z=1
                bne bad         ; Rtn C=0, invalid terminator

Hex:            cmp #"G"
                bcs bad         ; Rtn C=0, not hex
                cmp #"A"
                bcc Decimal     ; If <"A" check for 0-9
                sbc #$37        ; C=1, makes A=10 etc
                rts             ; Rtn C=1

;  *********************************

;  * None of the routines/tables from here on
;  * are accessed from outside the header.
;  * So any changes will not alter call addresses

Romtitle:
                jsr OSNEWL
                ldy #0
Rt2:            lda Romname,y
                iny
                jsr OSWRCH
                tax
                bne Rt2
                rts

;  *******************************

Helpaids:                       ;  Print ROM contents for *HELP PROBE
                jsr Romtitle
                jsr Rt2         ; Print Version$, Romtitle left Y pointing at Version$
                jsr OSNEWL
                ldx #$FE
                ldy #0
HA1:            inx
                inx             ; Move past address
                lda Table2,x
                beq HAend       ; FF=end marker
                pha
                jsr Space2      ; 2 spaces
                pla
HA2:            jsr OSWRCH      ; Print name until..
                inx
                lda Table2,x
                bpl HA2         ; ..until addr hi byte
                lda #32         ; Space
HA3:            jsr OSASCI      ; Print syntax upto CR
                cmp #13
                beq HA1         ; next name
                lda Helpfile,y
                iny
                bne HA3
HAend:          pla             ; drop extra offset
                jmp Nosuch      ; Allow other Roms to respond

;  *****************************

Table_0:                        ; Table of Rom contents with xeqn addresses
                .text "B"       ; Basic editor short form
                DDB BASED-1

Table2:                         ; Start for Help file, entries above Table2 do not appear in *HELP
                .text "BASED"
                DDB BASED-1

                .text "BLIST"
                DDB BLIST-1

;  $EQUS "CLR"
;  DDB CLEAR-1

                .text "FKEYS"
                DDB FKEYS-1

;  $EQUS "MEDIT"
;  DDB MEMEDIT-1

                .text "MOVE"
                DDB MOVECMND-1

;  $EQUS "ROMID"
;  DDB ROMID-1

                .text "SPACE"
                DDB SPACE-1

;  $EQUS "TXCOPY"
;  DDB TXCOPY-1

                .text "VLIST"
                DDB VARCAT-1

                .byte 0         ; End of Command table

Helptabl:
                .text "BASED"
                DDB Helpaids-1

                .byte 0         ; End of Help table

;  ***************************

; Helpfile- each index entry has a string here ending CR. (or CR only)

Helpfile:
                .byte 13        ; BASED

                .text "<fsp>"   ; Blist
                .byte 13

;  $EQUB 13 \ CLR

                .text "[key]"   ; FKEYS
                .byte 13

;  $EQUS "aaaa [@rom]" \MEDIT
;  $EQUB 13

                .text " page|ssss ffff|+eeee dddd"; MOVE
                .byte 13

;  $EQUB " [rom address]"  \ROMID
;  $EQUB 13

                .byte 13        ; SPACE

;  $EQUB 13 \TXCOPY

                .text "[HR$%PF]"; VLIST
                .byte 13

; ****************************************
; * CLR - POWER UP RESET EMULATION
; ****************************************
CLEAR:
                lda #127
                sta $FE4E       ; Disable all interrupts in system via
                jmp($FFFC)      ; Reset


                ; include_end: HEADER

                ; include_start: BASMOD1



; PROBE &BASED
; BASIC MODULE 1 - CRUNCHLINE, DECRUNCH, LINBINY, INSERT
; RePLAces routines in Basic Roms

Chk_alPHA:      cmp #$7B
                bcs fail
                cmp#$5F
                bcs ret1
                cmp#$5B
                bcs fail
                cmp#"A"
                bcs ret1        ; Ok

Checkdig:       cmp#$3A
                bcs fail
                cmp #"0"
                rts
fail:           clc
                rts

Chkperiod:      cmp#"."
                bne Checkdig
                rts

INCptr3:        inc $37         ; INC ptr
                bne ret1
                inc $38
ret1:           rts

INCget3:
                jsr INCptr3     ; INC ptr
                lda($37),y      ; get chr
                rts

; **********************************

CRUNCHLINE:
; TOKENISE line of text at (37), builds tokeniSED line at 700..

                ldy#0
                sty $3B
                sty $3C
token2:         lda($37),y
                cmp #$D
                beq ret1
                cmp #" "
                bne tk2

tk1:            jsr INCptr3
                bne token2

tk2:            cmp #"&"
                bne tk4         ; Not hex#, skip..
tk3:            jsr INCget3     ; Get chr
                jsr Checkdig    ; 0-9?
                bcs tk3         ; skip digits, hex#
                cmp#"A"
                bcc token2
                cmp #"G"
                bcc tk3         ; A-F still hex#
                bcs token2

tk4:            cmp#$22         ; Quote?
                bne tk6
tk5:            jsr INCget3     ; Get chr
                cmp #$22
                beq tk1
                cmp #$D
                bne tk5         ; find end of text
                rts

tk6:            cmp#":"
                bne tk7
                sty $3B         ; STArt of STAtement
                sty $3C         ; Tokenise line#s
                beq tk1

tk7:            cmp #","
                beq tk1
                cmp #"*"
                bne tk8
                lda $3B         ; STArt of STAtement?
                bne tk15
                rts             ; *OS cmnd.

tk8:            cmp #"."
                beq tk9
                jsr Checkdig    ; 0-9?
                bcc tk14        ; no
                ldx $3C         ; tokenise line#s?
                beq tk9         ; no
                jsr Tokenlineno ; Convert to binary AND insert in text in special form
                bcc tk16        ; Ok

tk9:            lda($37),y
                jsr Chkperiod
                bcc tk10        ; End of no.
                jsr INCptr3
                jmp tk9         ; Find end of no.

tk10:           ldx#$FF
                stx $3B
                sty $3C
                jmp token2

tk11:           jsr Chk_alPHA
                bcc tk15        ; Not alPHA
tk12:           ldy#0
tk13:           lda($37),y
                jsr Chk_alPHA
                bcc tk10        ; not alPHA
                jsr INCptr3
                jmp tk13        ; find end of variable name

tk14:           cmp#"A"
                bcs tk17
tk15:           ldx#$FF
                stx $3B
                sty $3C
tk16:           jmp tk1

tk17:           cmp#"X"
                bcs tk11
; Set (39) to STArt of Keyword table
                ldx #KEYTABLE % 256
                stx $39
                ldx #KEYTABLE/256
                stx $3A

tk18:           cmp($39),y      ; First chr of keyword
                bcc tk12
                bne tk20        ; next keywrd
tk19:           iny
                lda ($39),y     ; next chr from table
                bmi tk25        ; Token reached, Match
                cmp ($37),y     ; Compare to text chr
                beq tk19
                lda($37),y      ; text chr not matching
                cmp#"."
                beq tk21        ; Abbreviation
tk20:           iny
                lda($39),y
                bpl tk20        ; find end of keyword
                cmp#$FE         ; last token?
                bne tk23
                bcs tk12        ; skip, variable name
tk21:           iny
tk22:           lda($39),y
                bmi tk25
                inc $39
                bne tk22
                inc $3A
                bne tk22        ; find token, Y=text len.

tk23:           sec             ; point to next keyword
                iny
                tya
                adc $39
                sta $39
                bcc tk24
                inc $3A
tk24:           ldy#0
                lda($37),y
                jmp tk18        ; Chk next token

tk25:           tax             ; Correct token
                iny
                lda($39),y      ; Tokenising byte
                sta $3D
                dey
                lsr a
                bcc tk26
                lda($37),y
                jsr Chk_alPHA
                bcs tk12
tk26:           txa             ; token
                bit $3D
                bvc tk27        ; Not duplicated keyword
                ldx $3B
                bne tk27        ; not STAtement STArt
                clc
                adc#$40         ; Modify token

tk27:           dey
                jsr Insert_Token
                ldy#0
                ldx#$FF
                lda $3D         ; Tokenising flags
                lsr a
                lsr a
                bcc tk28
                stx $3B         ; Not STArt
                sty $3C         ; No line#s
tk28:           lsr a
                bcc tk29
                sty $3B         ; STArt
                sty $3C
tk29:           lsr a
                bcc tk32
                pha
                iny             ; =1
tk30:           lda($37),y
                jsr Chk_alPHA
                bcc tk31        ; not alPHA
                jsr INCptr3
                jmp tk30

tk31:           dey
                pla
tk32:           lsr a
                bcc tk33
                stx $3C         ; allow line#s
tk33:           lsr a
                bcs tk35
                jmp tk1
tk35:           rts

Insert_Token:                   ; Substitute byte in A for the Y bytes at (&37)
                pha
                clc
                tya
                adc$37
                sta$39
                ldy#0
                tya
                adc$38
                sta$3A
                pla
                sta($37),y
z888D:          iny
                lda($39),y
                sta($37),y
                cmp#$D
                bne z888D
                rts


Tokenlineno:                    ; Convert ascii# at (&37) to binary, then insert in internal
; format into text.
                and#$F
                sta$3D
                sty$3E          ; y=0
Z889D:          iny
                lda($37),y
                cmp#$3A
                bcs Z88DA
                cmp#$30
                bcc Z88DA
                and#$F
                pha
                ldx$3E
                lda$3D
                asl a
                rol$3E
                bmi Z88D5
                asl a
                rol$3E
                bmi Z88D5
                adc$3D
                sta$3D
                txa
                adc$3E
                asl$3D
                rol a
                bmi Z88D5
                bcs Z88D5
                sta$3E
                pla
                adc$3D
                sta$3D
                bcc Z889D
                inc$3E
                bpl Z889D
                pha
Z88D5:          pla
                ldy#0
                sec
                rts

Z88DA:          dey

Z88DB:                          ; Insert line# into text. (3D)=binary form, (37)=Ascii,Y=length
                lda#$8D         ; Line# token
                jsr Insert_Token
                lda$37
                adc#2
                sta$39
                lda$38
                adc#0
                sta$3A
Z88EC:          lda($37),y
                sta($39),y
                dey
                bne Z88EC
                ldy#3
                lda$3E
                ora#$40
                sta($37),y
                dey
                lda$3D
                and#$3F
                ora#$40
                sta($37),y
                dey
                lda$3D
                and#$C0
                sta$3D
                lda$3E
                and#$C0
                lsr a
                lsr a
                ora$3D
                lsr a
                lsr a
                eor#$54
                sta($37),y
                jsr INCptr3
                jsr INCptr3
                jsr INCptr3
                ldy#0
                clc
                rts

; ********************************

KEYTABLE:
                .text "AND"
                .byte $80
                .byte $00
                .text "ABS"
                .byte $94
                .byte $00
                .text "ACS"
                .byte $95
                .byte $00
                .text "ADVAL"
                .byte $96
                .byte $00
                .text "ASC"
                .byte $97
                .byte $00
                .text "ASN"
                .byte $98
                .byte $00
                .text "ATN"
                .byte $99
                .byte $00
                .text "AUTO"
                .byte $C6
                .byte $10
                .text "BGET"
                .byte $9A
                .byte $01
                .text "BPUT"
                .byte $D5
                .byte $03
                .text "COLOUR"
                .byte $FB
                .byte $02
                .text "CALL"
                .byte $D6
                .byte $02
                .text "CHAIN"
                .byte $D7
                .byte $02
                .text "CHR$"
                .byte $BD
                .byte $00
                .text "CLEAR"
                .byte $D8
                .byte $01
                .text "CLOSE"
                .byte $D9
                .byte $03
                .text "CLG"
                .byte $DA
                .byte $01
                .text "CLS"
                .byte $DB
                .byte $01
                .text "COS"
                .byte $9B
                .byte $00
                .text "COUNT"
                .byte $9C
                .byte $01
                .text "DATA"
                .byte $DC
                .byte $20
                .text "DEG"
                .byte $9D
                .byte $00
                .text "DEF"
                .byte $DD
                .byte $00
                .text "DELETE"
                .byte $C7
                .byte $10
                .text "DIV"
                .byte $81
                .byte $00
                .text "DIM"
                .byte $DE
                .byte $02
                .text "DRAW"
                .byte $DF
                .byte $02
                .text "ENDPROC"
                .byte $E1
                .byte $01
                .text "END"
                .byte $E0
                .byte $01
                .text "ENVELOPE"
                .byte $E2
                .byte $02
                .text "ELSE"
                .byte $8B
                .byte $14
                .text "EVAL"
                .byte $A0
                .byte $00
                .text "ERL"
                .byte $9E
                .byte $01
                .text "ERROR"
                .byte $85
                .byte $04
                .text "EOF"
                .byte $C5
                .byte $01
                .text "EOR"
                .byte $82
                .byte $00
                .text "ERR"
                .byte $9F
                .byte $01
                .text "EXP"
                .byte $A1
                .byte $00
                .text "EXT"
                .byte $A2
                .byte $01
                .text "FOR"
                .byte $E3
                .byte $02
                .text "FALSE"
                .byte $A3
                .byte $01
                .text "FN"
                .byte $A4
                .byte $08
                .text "GOTO"
                .byte $E5
                .byte $12
                .text "GET$"
                .byte $BE
                .byte $00
                .text "GET"
                .byte $A5
                .byte $00
                .text "GOSUB"
                .byte $E4
                .byte $12
                .text "GCOL"
                .byte $E6
                .byte $02
                .text "HIMEM"
                .byte $93
                .byte $43
                .text "INPUT"
                .byte $E8
                .byte $02
                .text "IF"
                .byte $E7
                .byte $02
                .text "INKEY$"
                .byte $BF
                .byte $00
                .text "INKEY"
                .byte $A6
                .byte $00
                .text "INT"
                .byte $A8
                .byte $00
                .text "INSTR("
                .byte $A7
                .byte $00
                .text "LIST"
                .byte $C9
                .byte $10
                .text "LINE"
                .byte $86
                .byte $00
                .text "LOAD"
                .byte $C8
                .byte $02
                .text "LOMEM"
                .byte $92
                .byte $43
                .text "LOCAL"
                .byte $EA
                .byte $02
                .text "LEFT$("
                .byte $C0
                .byte $00
                .text "LEN"
                .byte $A9
                .byte $00
                .text "LET"
                .byte $E9
                .byte $04
                .text "LOG"
                .byte $AB
                .byte $00
                .text "LN"
                .byte $AA
                .byte $00
                .text "MID$("
                .byte $C1
                .byte $00
                .text "MODE"
                .byte $EB
                .byte $02
                .text "MOD"
                .byte $83
                .byte $00
                .text "MOVE"
                .byte $EC
                .byte $02
                .text "NEXT"
                .byte $ED
                .byte $02
                .text "NEW"
                .byte $CA
                .byte $01
                .text "NOT"
                .byte $AC
                .byte $00
                .text "OLD"
                .byte $CB
                .byte $01
                .text "ON"
                .byte $EE
                .byte $02
                .text "OFF"
                .byte $87
                .byte $00
                .text "OR"
                .byte $84
                .byte $00
                .text "OPENIN"
                .byte $8E
                .byte $00
                .text "OPENOUT"
                .byte $AE
                .byte $00
                .text "OPENUP"
                .byte $AD
                .byte $00
                .text "OSCLI"
                .byte $FF
                .byte $02
                .text "PRINT"
                .byte $F1
                .byte $02
                .text "PAGE"
                .byte $90
                .byte $43
                .text "PTR"
                .byte $8F
                .byte $43
                .text "PI"
                .byte $AF
                .byte $01
                .text "PLOT"
                .byte $F0
                .byte $02
                .text "POINT("
                .byte $B0
                .byte $00
                .text "PROC"
                .byte $F2
                .byte $0A
                .text "POS"
                .byte $B1
                .byte $01
                .text "RETURN"
                .byte $F8
                .byte $01
                .text "REPEAT"
                .byte $F5
                .byte $00
                .text "REPORT"
                .byte $F6
                .byte $01
                .text "READ"
                .byte $F3
                .byte $02
                .text "REM"
                .byte $F4
                .byte $20
                .text "RUN"
                .byte $F9
                .byte $01
                .text "RAD"
                .byte $B2
                .byte $00
                .text "RESTORE"
                .byte $F7
                .byte $12
                .text "RIGHT$("
                .byte $C2
                .byte $00
                .text "RND"
                .byte $B3
                .byte $01
                .text "RENUMBER"
                .byte $CC
                .byte $10
                .text "STEP"
                .byte $88
                .byte $00
                .text "SAVE"
                .byte $CD
                .byte $02
                .text "SGN"
                .byte $B4
                .byte $00
                .text "SIN"
                .byte $B5
                .byte $00
                .text "SQR"
                .byte $B6
                .byte $00
                .text "SPC"
                .byte $89
                .byte $00
                .text "STR$"
                .byte $C3
                .byte $00
                .text "STRING$("
                .byte $C4
                .byte $00
                .text "SOUND"
                .byte $D4
                .byte $02
                .text "STOP"
                .byte $FA
                .byte $01
                .text "TAN"
                .byte $B7
                .byte $00
                .text "THEN"
                .byte $8C
                .byte $14
                .text "TO"
                .byte $B8
                .byte $00
                .text "TAB("
                .byte $8A
                .byte $00
                .text "TRACE"
                .byte $FC
                .byte $12
                .text "TIME"
                .byte $91
                .byte $43
                .text "TRUE"
                .byte $B9
                .byte $01
                .text "UNTIL"
                .byte $FD
                .byte $02
                .text "USR"
                .byte $BA
                .byte $00
                .text "VDU"
                .byte $EF
                .byte $02
                .text "VAL"
                .byte $BB
                .byte $00
                .text "VPOS"
                .byte $BC
                .byte $01
                .text "WIDTH"
                .byte $FE
                .byte $02
                .text "PAGE"
                .byte $D0
                .byte $00
                .text "PTR"
                .byte $CF
                .byte $00
                .text "TIME"
                .byte $D1
                .byte $00
                .text "LOMEM"
                .byte $D2
                .byte $00
                .text "HIMEM"
                .byte $D3
                .byte $00

; ********************************

DECRUNCH:
; Print chr in A, detokenise if necessary

                sta $37
                cmp #$80
                bcc ZB558       ; Not token
                lda #KEYTABLE % 256
                sta $38
                lda #KEYTABLE/256
                sta $39
                sty $3A
ZB51E:          ldy #$00
ZB520:          iny
                lda ($38),y
                bpl ZB520
                cmp $37
                beq ZB536
                iny
                tya
                sec
                adc $38
                sta $38
                bcc ZB51E
                inc $39
                bcs ZB51E
ZB536:          ldy #$00
ZB538:          lda ($38),y
                bmi ZB542
                jsr ZB558
                iny
                bne ZB538
ZB542:          ldy $3A
                rts

ZB558:          cmp #$0D
                bne ZB567
                jmp $FFEE

ZB567:          jmp ($20E)

; *****************************

LINBINY:
; Convert internal format line# at (&B),Y to binary in IAC
                iny             ; Skip token
                lda ($B),y
                asl a
                asl a
                tax
                and #$C0
                iny
                eor($B),y
                sta $2A
                txa
                asl a
                asl a
                iny
                eor ($B),y
                sta $2B
                iny
                sty $A
                sec
                rts

; ********************************

INSERT:
; INSERT LINE, text at 700,Y; line# in IAC

                sty $3B         ; Save Y
                jsr Delete_line ; Delete line if it exists
                ldy #$07
                sty $3C
                ldy #$00
                lda #$0D
                cmp ($3B),y
                beq ZBD10
ZBC9E:          iny
                cmp ($3B),y
                bne ZBC9E
                iny
                iny
                iny
                sty $3F
                inc $3F
                lda $12
                sta $39
                lda $13
                sta $3A
                jsr ZBE92       ; Update TOP with Y
                sta $37
                lda $13
                sta $38
                dey
                lda $06
                cmp $12
                lda $07
                sbc $13
                bcs ZBCD6

                brk
                .byte 0
                .text "Line space"
                brk

ZBCD6:          lda ($39),y
                sta ($37),y
                tya
                bne ZBCE1
                dec $3A
                dec $38
ZBCE1:          dey
                tya
                adc $39
                ldx $3A
                bcc ZBCEA
                inx
ZBCEA:          cmp $3D
                txa
                sbc $3E
                bcs ZBCD6
                sec
                ldy #$01
                lda $2B
                sta ($3D),y
                iny
                lda $2A
                sta ($3D),y
                iny
                lda $3F
                sta ($3D),y

ZBE56:          tya
                adc $3D         ; ADD Y to 3D
                sta $3D
                bcc ZBE5F
                inc $3E
ZBE5F:

                ldy #$FF
ZBD07:          iny
                lda ($3B),y
                sta ($3D),y
                cmp #$0D
                bne ZBD07
ZBD10:          rts


Delete_line:                    ; line# in IAC

                jsr Z9970       ; Find line
                bcs ZBC80       ; Not found
                lda $3D
                sbc #$02
                sta $37
                sta $3D
                sta $12
                lda $3E
                sbc #$00
                sta $38
                sta $13
                sta $3E
                ldy #$03
                lda ($37),y
                clc
                adc $37
                sta $37
                bcc ZBC53
                inc $38
ZBC53:          ldy #$00
ZBC55:          lda ($37),y
                sta ($12),y
                cmp #$0D
                beq ZBC66
ZBC5D:          iny
                bne ZBC55
                inc $38
                inc $13
                bne ZBC55
ZBC66:          iny
                bne ZBC6D
                inc $38
                inc $13
ZBC6D:          lda ($37),y
                sta ($12),y
                bmi ZBC7C
                jsr ZBC81
                jsr ZBC81
                jmp ZBC5D
ZBC7C:          jsr ZBE92
                clc
ZBC80:          rts
ZBC81:          iny
                bne ZBC88
                inc $13
                inc $38
ZBC88:          lda ($37),y
                sta ($12),y
                rts


; Find line whose number is in IAC. If not found C=1.
; If it exists returns address-1 of text in (&3D)
Z9970:          ldy #$00
                sty $3D
                lda $18
                sta $3E
Z9978:          ldy #$01
                lda ($3D),y
                cmp $2B
                bcs Z998E
Z9980:          ldy #$03
                lda ($3D),y
                adc $3D
                sta $3D
                bcc Z9978
                inc $3E
                bcs Z9978
Z998E:          bne Z99A4
                ldy #$02
                lda ($3D),y
                cmp $2A
                bcc Z9980
                bne Z99A4
                tya
                adc $3D
                sta $3D
                bcc Z99A4
                inc $3E
                clc
Z99A4:          ldy #$02
                rts

; ********************************

ZBE92:          tya             ; Add Y to TOP
                adc $12
                sta $12
                bcc ZBE9B
                inc $13
ZBE9B:          ldy#1
                rts



                ; include_end: BASMOD1
                ; include_start: BASMOD2




; ----------------------------------------
;  BASMOD2b                              -
;  Basic Replacement Module              -
;  SETVAR, FINDVAR                       - 
;  SETPROC, FINDPROC, WARMSTART, CHKBASIC-
;  Warmstart modded 1/87 for OSHWM<>PAGE
; ----------------------------------------

; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

FINDPROC:
                ldy#1
                lda($37),y
                ldy#$F6         ; PROC offset in cat' page
                cmp#$F2         ; PROC token?
                beq Z946F
                ldy#$F8         ; FN offset
                bne Z946F

FINDVAR:                        ; Find Variable in catalogue whose name is at (37),1, length in 39
                ldy#1
                lda($37),y      ; First chr of name
                asl a
                tay

Z946F:
                lda $400,y
                sta$3A
                lda$401,y
                sta $3B

FV1:            lda$3B
                beq FV3         ; link address=0, not found
                ldy#2
FV2:            lda($3A),y      ; Name byte
                bne FV4         ; Still name chr
                dey
                cpy $39         ; Length
                bne FV5         ; Next entry
                iny
                tya
                adc $3A         ; C=1
                sta $2A         ; Set IAC=Addr of Variable
                lda $3B
                adc#0
                sta$2B
FV3:            rts             ; Z=1 if not found

FV4:            cmp($37),y      ; Name chr
                bne FV5         ; Wrong entry
                iny
                bne FV2         ; Check next chr
FV5:            ldy#0
                lda($3A),y      ; Link addr lsb
                pha
                iny
                lda($3A),y      ; msb
                sta $3B
                pla
                sta $3A
                jmp FV1         ; Check next entry

; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

SETPROC:                        ; Create new variable or PROC/FN on catalogue
                ldy#1
                lda($37),y
                tax
                lda#$F6
                cpx#$F2
                beq Z9501
                lda#$F8
                bne Z9501

SETVAR:
                ldy#1
                lda($37),y
                asl a
Z9501:          sta$3A
                lda#4
                sta$3B
Z9507:          lda($3A),y
                beq Z9516       ; End of chain
                tax
                dey
                lda($3A),y
                sta$3A
                stx$3B
                iny
                bpl Z9507
Z9516:          lda$3           ; Vartop
                sta($3A),y
                lda$2
                dey
                sta($3A),y
                tya             ; =0
                iny
                sta(2),y
                cpy$39
                beq Z9558       ; Single chr name
Z9527:          iny
                lda($37),y
                sta(2),y
                cpy$39
                bne Z9527
Z9558:          rts

; ******************************************************

WARMSTART:                      ; Return to BASIC or EDITOR
                pha             ; B=BASIC, ^E=Editor
                lda#126
                jsr OSBYTE      ; Ack any Escape

;  SET OSHWM TO PAGE incase PAGE<>OSHWM, added 1/87
;  Both BASIC & BASIC EDITOR use OSWHM for PAGE
                lda $18         ; PAGE
                sta $244        ; OSHWM
                pla
                cmp #5          ; ^E 
                bne gobasic
                ldx #Editor_0 % 256
                ldy #Editor_0 / 256
                jmp OSCLI

gobasic:        ldx#0
WS1:            ldy Warm,x
                beq WS2
                inx
                txa
                pha
                lda#138
                ldx#0           ; Keybd buffer
                jsr OSBYTE      ; Insert chr
                pla
                tax
                bne WS1

WS2:            ldx #Basic % 256
                ldy #Basic / 256
                jmp OSCLI

Warm:           .text "OLD"
                .byte 13
                .byte 0

Basic:          .text "BASIC"
                .byte 13

Editor_0:       .text "BE"
                .byte 13

; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;  CHECK IF CURRENT LANGUAGE ROM IS BASIC \
; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
CheckBASIC:
                txa
                pha
                tya
                pha
                lda#252
                ldx#0
                ldy#$FF
                jsr OSBYTE      ; Read Current Language rom no.
                stx $100
                lda #187
                ldx#0
                ldy#$FF
                jsr OSBYTE      ; Read BASIC Rom no.
                cpx $100
                beq Bok

                jsr Errorexit
                .byte $D7
                .text "Not BASIC?"
                .byte 0

Bok:
                pla
                tay
                pla
                tax
                rts             ; Only returns if BASIC


                ; include_end: BASMOD2

                ; include_start: BASED

; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;  BASED
;  MAIN FILE and SUBROUTINES
; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Wildcard=0
SSLen=$70
Addr=$71
AddrHi=$72
Ptr=$73
PtrLo=$73
PtrHi=$74
Counter=$75
Switch=$76
Offset=$77
Match=$78
Matchend=$79
Lineend=$7A
Highlight=$7B
Exec=$7C
SSLenW=$7D
Varpack=$7E
Finish=$73
Newstart=$75
Step=$77
Lstart=$79
News2=$7E
Hlt_code=$90
RAMTOP=$91
Old_oswrch=$92
Scrn_Mode=$94
Scrn_width=$95

; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;  * BASIC PRGM EDITOR for Electron       *
;  * V1.33 IJW 21/5/84                    *
;  * Colour Highlighting, CtrlB WC        *
;  * Any Mode code added 1/87             *
;  * Mode 7 disabled for Electron  10/87  *
; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

;  *** MAIN SERVICE ENTRY POINT ***

BASED:
; Check for E, execing instructions
                lda #0
                sta Exec
                jsr Nextoscl    ; Y = oscli offset
                cmp #"E"
                bne Blang
                dec Exec        ; Set exec flag minus -on
Blang:
                lda $20E        ; Save OSWRCH Vector
                sta Old_oswrch
                lda $20F
                sta Old_oswrch+1

get_mode:       lda #$A0
                ldx #$55
                jsr OSBYTE      ; Get Mode in X
                cpx #5
                beq nok         ; mode 5 -> 6
                cpx #2
                bne mok
nok:            inx             ; mode 2 -> 3
                lda #22         ; Change MODE
                jsr $FFEE
                txa
                jsr $FFEE
                jmp get_mode

mok:
                stx Scrn_Mode
                lda #Our_oswrch % 256; NEVER mode 7, trap oswrch
                sta $20E
                lda #Our_oswrch / 256
                sta $20F

mode7:
                lda #39         ; screen width
                cpx #0          ; mode 0?
                beq wide
                cpx #3          ; mode 3
                bne nwide
wide:           lda #79
nwide:          sta Scrn_width

                ldx #1
                stx $500        ; Len of asci SS inc CR
                dex
                stx SSLen       ; Len of token SS less CR
                lda #13
                sta $501
                sta $556        ; SS="" on startup
                lda #$82        ; Green
                sta Hlt_code
                jmp MainCtrl

;  **********************************

NewSS:                          ; Enter new search$
                jsr Getline     ; Get Search$ in &700
                bcs MainCtrl    ; C=1 if Escaped
                tya
                beq MainCtrl    ; Zero SS not allowed
                iny
                sty $500        ; Save len of I SS
SaveSS:         lda $6FF,y
                sta $500,y      ; Save SS I
                dey
                bne SaveSS
                jsr Checkline   ; Check for special syntax
                beq StoreSS     ; Z=1 if line not to be crunched
                lda #0
                sta $37
                lda #7
                sta $38
                jsr CRUNCHLINE  ; Crunch new SS
StoreSS:        ldy #$FF
SaveST:         iny
                lda $700,y
                sta $556,y      ; Save TokenSS
                cmp #13
                bne SaveST
                sty SSLen       ; Save len of tokenised SS less CR
                beq *+5         ; Skip menu

;  **********************************
;  * Fall back into main logic      *
;  **********************************

MainCtrl:
                jsr Menu
                jsr Currentsearch; Print current search$
                ldx SSLen
                beq Choice
                jmp Count       ; Print occurences only if SS exists

;  **********************************

; Keyboard editing
KCB:            .word $700
                .byte $EE
                .byte 32
                .byte $FF
Keys:           ldx #KCB % 256
                ldy #KCB / 256
                sty $2B         ; Set illegal #
                lda #0
                jsr OSWORD
                bcs Choice      ; Escaped
                ldy #0
                sty $F2
                lda #7
                sta $F3
                sta $38
                ldx #$2A        ; Result addr
                jsr Nextoscl    ; Skip spaces
                cmp #128
                bcc KB2
                sta Hlt_code
                bne Choice
KB2:            jsr DECBIN
                bcc Noline      ; Line# error
                lda $2B
                bmi Noline
                tya
                pha
                sta $37
                jsr CRUNCHLINE
                pla
                tay
                jsr INSERT
                beq Choice
Noline:         lda #7
Nol2:           jsr OSWRCH
                jmp Choice
;  **********************************

ERRORHANDLER:                   ; Display error message
                jsr OSNEWL
                ldy#1           ; Skip error no.
Err1:           lda($FD),y
                beq Errend
                jsr OSWRCH
                iny
                bne Err1
Errend:         jsr OSNEWL

Choice:         ldx#$FF
                txs
                lda #132
                jsr OSBYTE      ; Get Screen bottom
                sty RAMTOP
                jsr Dis_Printer
                jsr Printmsg
                .byte 13
                .byte 131
                .text "Ready:"
                .byte 0
                lda #124
                sta $8C         ; Reset Variables flag +ve
                jsr OSBYTE      ; Clear Escape
                bit Exec
                bmi Wait_0      ; Dont flush
                lda #15
                ldx #1
                jsr OSBYTE      ; Flush KB

Wait_0:         jsr OSRDCH      ; Read input
                cmp #$1B
                beq Exit_0      ; Escaped
                cmp #5
                beq Exit_0      ; ^E
                cmp #4
                bcc Nol2        ; Pass Ctrl @ABC
                cmp #14
                bcc W1          ; <14 not passed
                cmp #16
                bcc Nol2        ; Pass Ctrl N,O
W1:             ldx #17         ; 18 Lines in menu
                and #$DF        ; Force uppercase
                cmp #"Q"
                bne Srchmenu

Exit_0:         pha             ;  A = 'B',Esc or ^E
                jsr En_Printer
                jsr OSNEWL
                lda Old_oswrch  ; Restore OSWRCH vector
                sta $20E
                lda Old_oswrch+1
                sta $20F
                pla
                jmp WARMSTART   ; Rtn to Basic or Editor

Srchmenu:       cmp Letter,x
                beq Found       ; Match found
                dex
                bpl Srchmenu
                jmp MainCtrl    ; Any illegal entries show menu

Found:          lda Addr1,x
                pha             ; Addr Hi
                lda Addr2,x
                pha             ; Addr low

Submenu:                        ; Print the Xth line of the menu
                ldy #0
Sub1:           lda Subfile,y
                iny
                cmp #13         ; CR?
                bne Sub1
                dex
                bpl Sub1        ; Pass X CRs
Sub2:           lda Subfile,y
                cmp #13         ; CR?
                beq Sub3
                jsr OSASCI
                iny
                bne Sub2
Sub3:           jsr En_Printer
                jmp OSNEWL      ; And goto routine via RTS

;  *********************************

Letter:                         ; Table of acceptable keys
                .text "@EHLNKGS"
                .byte 12
                .text "BCFMPRTUV"
Addr1:                          ; Table of xeqn addrs Hi bytes
                .byte (Lisprog-1)/ 256; @ is blank
                .byte (NewSS-1)/ 256
                .byte (Count -1)/ 256; H is blank line in menu
                .byte (List -1)/ 256
                .byte (Lines-1)/ 256
                .byte (Keys-1)/ 256; Keys is Blank line
                .byte (Global-1)/ 256
                .byte (Select-1)/ 256
                .byte (List_nohl-1)/ 256; |L is blank line
                .byte (BADPROG-1)/ 256; Bad prog
                .byte (COPY-1)/ 256; Copy
                .byte (Format-1)/ 256; Format
                .byte (Move-1)/ 256; Move
                .byte (PACK-1)/ 256; Pack
                .byte (Renumber-1)/ 256; Renumber
                .byte (TABLE-1)/ 256; Table
                .byte (UNCONCAT-1)/256; Unpack
                .byte (VARXREF-1)/256
Addr2:                          ; Table of xeqn addrs low bytes
                .byte (Lisprog-1)% 256; @
                .byte (NewSS-1)% 256
                .byte (Count -1)% 256
                .byte (List -1)% 256
                .byte (Lines-1)% 256
                .byte (Keys-1)% 256
                .byte (Global-1)% 256
                .byte (Select-1)% 256
                .byte (List_nohl-1)% 256
                .byte (BADPROG-1)% 256; Bad prog
                .byte (COPY-1)% 256; Copy
                .byte (Format-1)% 256; Format
                .byte (Move-1)% 256; Move
                .byte (PACK-1)% 256; pack
                .byte (Renumber-1)% 256; Renumber
                .byte (TABLE-1)% 256; Table
                .byte (UNCONCAT-1)% 256
                .byte (VARXREF-1)%256
; 
;  *********************************
; 
Count2:
                jsr Start
                sta $2A
                sta $2B         ; Reset IAC
                beq *+5
Searchline:     jsr Nextline
                jsr Search
                bne Rts_0       ; TOP of prgm reached
Ctest:          bcs Searchline  ; No match this line
                bit $8C         ; Variable count?
                bpl Cinc        ; No
                bit $8B         ; In Quotes?
                bmi Cexclude    ; Yes
Cinc:           inc $2A
                bne *+4
                inc $2B         ; INC IAC
Cexclude:       jsr ConSrch     ; Check for >1 match/line
                beq Ctest
Rts_0:          rts

Count:                          ; Count occurences of SS
                jsr Count2
                jsr LINIAC      ; Print IAC in decimal
                jsr Printmsg
                .text " matches"
                .byte 0
                jmp Choice

;  *********************************
; 
Nextline:       ldy #3
                lda (Addr),y    ; =Line Len
                clc
                adc Addr
                sta Addr        ; Point to next line
                bcc *+4
                inc Addr+1
                rts

;  *********************************
; 
Menu:           jsr Printmsg
                .byte 3         ; Printer off
;  $EQUB &16 \Mode 7..   << TRY NO MODE CHANGE?
;  $EQUB 135 \but use shadow mode if available
                .byte 26        ; No windows
                .byte 12        ; CLS
                .text " ",131,"  BASIC EDITOR"
Subfile:        .byte 13        ; Start point for submenu
                .byte 13
                .text "",135,"E",131,"Enter Search$"
                .byte 13
                .byte 13
                .text "",135,"L",131,"List matches"
                .byte 13
                .text "",135,"N",131,"Number matches"
                .byte 13
                .byte 13
                .text "",135,"G",131,"Global Replace"
                .byte 13
                .text "",135,"S",131,"Selective Replace"
                .byte 13
                .byte 13
                .text "",135,"B",131,"Bad Program relink"
                .byte 13
                .text "",135,"C",131,"Copy"
                .byte 13
                .text "",135,"F",131,"Format listing"
                .byte 13
                .text "",135,"M",131,"Move"
                .byte 13
                .text "",135,"P",131,"Pack"
                .byte 13
                .text "",135,"R",131,"Renumber"
                .byte 13
                .text "",135,"T",131,"Table line references"
                .byte 13
                .text " U",131,"Unpack"
                .byte 13
                .text "",135,"V",131,"Variables Xref"
                .byte 13
                .byte 0         ; Msg ends
                rts
;  *********************************

Currentsearch:                  ; Print current search$ and check SSLen for non number wilds
                jsr Printmsg
                .byte 13
                .text "",131,"Search$:",135,""
                .byte 0
                ldx $500        ; Len of SS
                lda $4FF,x      ; Last chr of SS
                ldx SSLen       ; Len of Token SS
                cmp #3          ; WC?
                bcs CSX         ; No
                dex             ; Dec lenghth of SS used in search
                beq CSZ         ; Cant allow -ve
CSX:            lda $501        ; First chr WC?
                cmp #3
                bcs CSZ         ; Not WC
                dex
CSZ:            stx SSLenW
                ldy #0
CS1:            iny
                lda $500,y
                jsr Prbyte
                bne CS1         ; Not CR
                rts
; 
;  *********************************

Type:           cmp #$41
                bcc LV1
                cmp #$5B
                bcc LV2
                cmp #$5F
                bcc LV1
                cmp #123
                bcc LV2
LV1:            clc
                rts
LV2:            sec
                rts

;  *********************************

Lines:                          ; Print match line numbers
                jsr Lines2
                jmp Choice

Lines2:         jsr Start       ; Also called by Var-Xref
                beq *+5
Nxtline:        jsr Nextline
                bit $FF
                bmi LL3         ; Escaped
                jsr Search
Li3:            bne LL3         ; TOP reached
                bcs Nxtline     ; No match
                bit $8C         ; Variables?
                bpl Linc        ; No
                bit $8B         ; In quotes?
                bpl Linc        ; No
                jsr ConSrch
                jmp Li3         ; Yes
Linc:           jsr LinetoIAC
                lda #8          ; 8 spaces rqd
                jsr IACOUTA     ; PRINTLine# in 8 field
                bmi Nxtline
LL3:            rts

;  *********************************

YesNo:          bit Exec        ; 0=KB, FF=Execing
                bmi Y1
                jmp YESNO       ; Flush KB then..
Y1:             jmp YESNO2      ; ..Get Y/N and print Y/N+CR
; 

LinetoIAC:                      ; Put line# in IAC
                ldy #1
                lda (Addr),y    ; Line# Hi
                sta $2B         ; IAC Hi
                iny
                lda (Addr),y    ; Line# Lo
                sta $2A         ; IAC Lo
                rts

PrtLino:                        ; PRINT LINE#
                jsr LinetoIAC   ; Put line# in IAC
                jmp LINIAC      ; Print line# in IAC & RTS
; 

Start:          lda $18
                sta Addr+1      ; Start at PAGE
                lda #0
                sta Addr
                rts

;  *********************************

Getline:                        ; Input line at &700
; Rtn C=1 if escaped, Y=line len
; Doesnt use OSWORD 0 to allow input of control codes
                bit Exec
                bmi Reset_0     ; Execing, dont flush
                lda #15
                ldx #1
                jsr OSBYTE      ; Flush KB
Reset_0:        ldx #0
                stx $3A         ; Reset len counter
Get_0:          jsr OSRDCH      ; Get input
                bcs RtnG        ; Escaped
                cmp #127        ; Delete?
                bne G2

                lda #121
                ldx #(1 ^ $80)
                jsr OSBYTE      ; Check ctrl
                lda #127
                cpx #$80
                bcs G2          ; -ve=Ctrl down, insert 7F
                dec $3A
                bmi Reset_0
                ldx $3A
                ldy $700,x      ; Previous chr
                cpy #$7F
                beq ctrldel
                cpy #32         ; Control chr?
                bcs cd2         ; No
                cpy #3          ; WC?
                bcc cd2         ; delete 1 for WC
ctrldel:        jsr OSWRCH      ; Delete 2 chrs for |ctrl
cd2:            jsr OSWRCH
                jmp Get_0

G2:             ldy $3A         ; Ptr
                cpy #80         ; Max line length
                bcc G1          ; Ok
                lda #7
                jsr OSWRCH      ; Beep, too long
                bne Get_0       ; Wait for delete or escape
G1:             sta $700,y      ; Build line
                inc $3A         ; Inc Ptr
asci:           jsr Prbyte
                bne Get_0       ; Not CR
                clc             ; C=0 for good line
RtnG:           rts
; 
; 
Checkline:                      ; Check input for special syntax
; Quote as first chr means dont crunch line
; @@ as line start means crunch following number into internal line# form
; Returns Z=0 if no special syntax
                lda $700        ; First chr of line
                cmp #$22        ; Quotes?
                beq Moveleft
                cmp #"@"
                bne Rtn_0
                lda $701
                cmp #"@"        ; @@ required for line#
                bne Rtn_0
                lda $702
                pha
                bne Real
                lda #$30
                sta $702        ; Insert dummy line# 0 for wildcard
Real:           lda #"G"
                sta $700        ; Construct GOTO in buffer
                lda #"."
                sta $701        ; in abbreviated form
                lda #0
                sta $37
                lda #7
                sta $38
                jsr CRUNCHLINE  ; Convert to tokens
                pla
                bne Moveleft    ; Not wildcard line#
                sta $702
                sta $703
                sta $704        ; Make line# bytes all 0 if wild
Moveleft:       ldx #0
                dey
Shift_0:        lda $701,x      ; Move line left 1 byte
                sta $700,x      ; to loose quote or GOTO
                inx
                cmp #13         ; CR?
                bne Shift_0
Rtn_0:          rts             ; Z=1 if Special syntax

;  *********************************

Lisprog:                        ; List the Program
                lda #$FF
                sta Highlight
                sta Lineend     ; No highlights, whole lines
                jsr Start
L1_0:           ldy #1
                lda (Addr),y
                ora $FF
                bmi L2_0        ; TOP or Escaped
                jsr Listline
                jsr Nextline
                bne L1_0
L2_0:           jmp Choice

Dis_Printer:    ldx #4
                bne *+4

En_Printer:     ldx #0
                lda #3
                ldy #$FB        ; Mask bit2
                jmp OSBYTE      ; Printer on/off

;  ********************************

Prbyte:         cmp #3          ; wild A,B ?
                bcs CS2_0       ; No
CS4:            lda #$FF        ; Wildcard block
CS2_0:          cmp #13
                beq CS3b        ; CR

Printasci:      cmp #32
                bcc CS3         ; ctrl code
                cmp #$7F        ; delete?
                bne CS3b        ; ascii \7F=|?
CS3:            pha
                lda #"|"
                jsr OSWRCH      ; Print |ctrl
                pla
                eor #$40
CS3b:           jsr OSASCI
                cmp #13
                rts

LineB_iac:                      ; Put line# in IAC
                ldy #1
                lda ($B),y
                sta $2B
                iny
                lda ($B),y
                sta $2A
                rts

Nonexistent:                    ; Print message...
                jsr Printmsg
                .text " Nonexistent ("
                .byte 0
                jsr OUTIAC      ; Print line# in 2A/B
                jsr Printmsg
                .text ")"
                .byte 13
                .byte 0
                rts

; 
Findcall:                       ; Search program for any reference to line# in 2C/2D
                jsr StartB      ; Set (B) to PAGE
S1:             ldy #4
Findcall2:                      ; Reentry point
S2:             lda ($B),y
                cmp #$8D        ; Line# marker?
                beq Cfound
                iny
                cmp #13         ; CR?
                bne S2
                lda ($B),y
                bpl S3
S9:             rts             ; TOP found, rtn with Z=0, no match
S3:             jsr UpB         ; Update (B) ptr
                bcc S1
Cfound:         jsr LINBINY     ; Convert to binary in IAC
                lda $2A
                cmp $2C
                bne Wrong
                lda $2B
                cmp $2D
                beq S9          ; Rtn with Z=1, match found
Wrong:          ldy $A
                bne S2          ; Continue search

UpB:                            ; Update (B) pointer
                ldy #3
                lda ($B),y      ; Line length byte
                clc
                adc $B
                sta $B
                bcc x_
                inc$C
                clc
x_:             rts

StartB:         lda $18         ; Page
                sta $C
                ldy #0
                sty $B          ; Rtn Y=0
                rts

Findstart:                      ; Rtn (Addr) of Start line
                lda Lstart
                sta $2A
                lda Lstart+1
                sta $2B

Findline:                       ; Search program for line whos # is in 2A/2B, rtn (Addr)
                jsr Start       ; Set (Addr) to PAGE
                beq *+5
FL1:            jsr Nextline    ; Update (Addr)
                clc
                ldy #1
                lda (Addr),y
                bmi FL2         ; Top found,Z=0,C=0
                iny
                cmp $2B         ; Hi byte looking for
                bcc FL1
                bne FL2         ; Gone past, Z=0,C=1
                lda (Addr),y
                cmp $2A         ; Lo byte
                bcc FL1
FL2:            rts             ; RTN Z=1 if line found
; C=1 if (Addr) valid, C=0 if TOP

Topover:                        ; Backup before..
                lda #13
                jsr OSWRCH      ; CR, no LF
Topis:          jsr Printmsg
                .text "TOP=&"
                .byte 0
Toprint:        lda $13         ; TOP hi
                jsr Hex_asci
                lda $12         ; TOP lo
                jmp Hex_asci    ; Print TOP in HEX

Newstoiac:      ldx Newstart
                stx $2A
                lda Newstart+1
                sta $2B
                rts

News2_news:     lda News2
                sta Newstart
                lda News2+1
                sta Newstart+1
                rts

Lineiachi:      ldy #2
                lda (Addr),y
                sta $2C
                dey             ; =1
                lda (Addr),y
                sta $2D
                rts             ; Rtn -ve if top found

Iachi_lo:       lda $2C
                sta $2A
                lda $2D
                sta $2B
                rts

;  ********************************************
;  Trap all teletext control chrs if not mode 7
;  ********************************************

Our_oswrch:     cmp #$80        ; oswrch points here unless mode 7
                bcs ours
notus:          jmp (Old_oswrch)
ours:           cmp #$A0
                bcs notus
                cmp Hlt_code
                beq highon
                cmp #$87        ; White
                beq highoff
                cmp #$89        ; Flash off
                beq highoff
                lda #32
                jmp notus       ;  any other teletext -> space 

highoff:        pha
                lda #32
                jsr notus
                lda #17
                jsr notus
                lda #128
                jsr notus       ; COLOR 128
                lda #17
                jsr notus
                lda #7
                jsr notus       ; COLOR 1
                pla
                rts

highon:         pha             ; Inverse text for highlighting 
                lda #17
                jsr notus
                lda #135
                jsr notus       ; COLOR 135 (White bg)
                lda #17
                jsr notus
                lda #0
                jsr notus       ; COLOR 0 (Black fg)
                lda #32
                jsr notus
                pla
                rts



                ; include_end: BASED
                ; include_start: SEARCH



;  *** SEARCH ***
Badpgm:         jmp WARMSTART   ; Let BASIC say Bad program
Search:                         ; SEARCH PRGM LINE FOR SS
; Rtns Z=0 if TOP reached
; C=0 If match found,(Ptr)Y=byte after match ends
; C=1 If no match
                ldy#0
                sty $8B         ; Reset quotes flag at line start
                lda(Addr),y
                cmp#13
                bne Badpgm      ; Line must start CR
                iny
                lda(Addr),y
                bpl *+4         ; Not TOP, TOP=&FF
                tya
                rts             ; TOP reached,Z=0
                ldy#3
                lda(Addr),y     ; Get Line Len
                sec
                sbc#4           ; 4bytes/line overheads
                sbc SSLenW      ; Sub ST len less wilds at ends
                bcc Nomatch     ; Line len < ST len?
                ldy#0
                ldx SSLen
                cpx#1
                beq Se          ; If single chr search cant match len byte
                lda$556         ; First byte of SS
                cmp#3           ; WC?
                bcs Se          ; No
                iny
                dex
                lda#3           ; If WC assume Linelen byte as a match, and start at byte 2 of SS,initial offset 3, 1 less byte to compare
                bne WildB
Se:             lda#4           ; Normal offset
WildB:          sta Offset      ; Posn of Ptr wrt Addr
                clc
                adc Addr        ; A=3 or 4
                sta Ptr
                lda Addr+1
                adc#0
                sta PtrHi       ; Ptr now to first byte of line text if not ctrlB
                bne Sb          ; Skip for first byte of line
Sa:             ldy#0
                lda(PtrLo),y
                cmp#$22
                bne GWX
                lda $8B
                eor#$FF
                sta$8B          ; Toggle quotes flag
GWX:            ldx SSLen       ; Search$ Len
Sb:             lda(PtrLo),y
                cmp#13          ; Prgm byte=CR?
                bne Sf          ; No
                cpx#1           ; Last chr of S$
                bne Nomatch
                tya
                beq Nomatch     ; If Y=0 single chr search, cant allow match even if WC
                lda $556,y      ; Last chr of S$
                cmp#3           ; WC?
                bcc Matching    ; If last chr of S$ is WC it can match the CR
                bcs Nomatch
Sf:             lda $556,y      ; Search$
                beq Wild        ; Assume match if SS byte is 0,(Wildcard)
                cmp#1           ; Non numeric wild?
                beq NumWild
                cmp#2
                beq Nonvariable
                cmp (PtrLo),y   ; =Prgm byte?
                bne Sc          ; No match

Wild:           iny
                dex
                bne Sb
Matching:       lda#0
                clc
                rts             ; Match found,C=0,Z=1

NumWild:                        ; Non numeric wilds here
                lda(PtrLo),y    ; Line byte
                cmp#$30
                bcc Wild        ; assume match if<"0"
                cmp#$3A
                bcs Wild        ; assume match if>"9"

Sc:
ConSrch:
                inc PtrLo
                bne *+4
                inc PtrHi
                inc Offset      ; Offset is posn of (Ptr) wrt to (Adr)
Sd:             bne Sa
Nomatch:        sec
                lda#0
                rts             ; No match this line,C=1,Z=1

Nonvariable:    lda(PtrLo),y
                cmp#"&"
                beq Sc          ; Hex& not allowed
                jsr Type
                bcs Sc          ; Letter, NO match
                cpx#1
                beq Last_0
                cmp#$F2         ; PROC?
                beq Sc          ; Include PROC/FN in name if not last chr
                cmp#$A4         ; FN?
                beq Sc
                bne Wild

; IF last chr of S$ (X=1), A number cant match ctrlB (ie can be part of name)
Last_0:         cmp#$30
                bcc NV2         ; <0
                cmp#$3A         ; >9?
                bcc Sc          ; 0-9 cant match ctrlB, ie can be part of name

NV2:                            ; Check last chr for %$(
                cmp#"%"
                beq Sc          ; take % as name chr
; Prevents NAME^B matching NAME%
                cmp#"$"
                beq Sc
                cmp#"("         ; Array?
                bne Wild

; For ( check S$ for PROC/FN
                ldx SSLen
NV3:            lda $555,x
                cmp#$F2         ; PROC?
                beq NV4
                cmp#$A4         ; FN?
                beq NV4
                dex
                bne NV3
                ldx#1
                bne Sc          ; No FN/PROC found, take ( as part of real name, prevent match
NV4:            ldx#1
                bne Wild        ; IF PROC/FN found allow ( to match CtrlB


                ; include_end: SEARCH
                ; include_start: LIST


;  ******** LIST **************
; 

List_nohl:      lda#$FF
                bmi List2       ; No highlighting

List:                           ; List all match lines
                lda#0           ; Highlights on
List2:          sta Highlight
                jsr Start
                beq *+5

Nxtlist:        jsr Nextline
                bit$FF          ; Test escape
                bmi LL1
                jsr Search
                bne LL1         ; TOP reached
                bcs Nxtlist     ; No match
                tya
                clc
                adc Offset
                sta Lineend     ; Partial listing pointer
                lda Offset
                sta Match       ; Rqd for highlighting
                jsr Listline    ; List match line up to first match
NL2_0:          jsr ConSrch     ; Keep looking on same line
                php             ; Save result of search
                tya
                clc
                adc Offset
                ldy Lineend     ; Pickup where listing stopped
                sta Lineend     ; Partial listing pointer
                plp             ; result of search
                bcc NL3_0       ; Another match
                lda#$FF
                sta Lineend     ; Rest of line
                sta Match       ; No highlight
                jsr Contlist    ; List rest of line, match still OK as past
                jmp Nxtlist
NL3_0:          lda Offset
                sta Match       ; Update match posn
                jsr Contlist
                jmp NL2_0
LL1:            jmp Choice

; 
;  ********************************
; 

; LISTLINE For NO Highlight, Match=FF. For Partial line list, Set Lineend to rqd length, else FF

Listline:       jsr PrtLino
                jsr Space1      ; Space
                ldy#4           ; First byte of text
                ldx#$FF
                stx$4D          ; Quotes test flag
                lda Addr
                sta$B
                lda Addr+1
                sta$C           ; Needed for LINBINY

Contlist:       lda Match
                tax
                clc
                adc SSLen
                sta Matchend    ; End of match$ posn
                cpx#4
                bcs Listbyte
                inc Match       ; Minimum Match is 4, 3=WC matching line len

Listbyte:       bit Highlight
                bpl Lb2
Lb1:            jmp Notyet      ; No highlighting
Lb2:            cpy Match
                bcc Lb1         ; Wait for start of match
                bne Middle
                tya
                pha             ; Save Y, Start of match
                lda#$86
                jsr OSBYTE      ; Read cursor pos

HL6:            pla
                tay
                pha
                lda(Addr),y     ; Next byte
                bmi HLtoken     ; Token
                cpx Scrn_width  ; Last posn of line? 39/79
                bne HL0         ; No
                beq HLnl        ; start highlight on new line

HLtoken:        txa
                sec
                sbc Scrn_width  ;  39/79 
                adc #8
                bcc HL0

HLnl:           jsr OSNEWL      ; If within 8 of line end start new line for token
                bne HL1

HL0:            txa
                beq HL1         ; Start of newline
                lda #8
                jsr OSWRCH      ; Backspace 1
                lda #$87
                jsr OSBYTE      ; Read chr at cursor
                cpx #$20        ; Space?
                beq HL1         ; Leave backspaced
                lda #9
                jsr OSWRCH      ; Forward again
HL1:            lda Hlt_code
                bne HL4         ; Start Highlight

Middle:         tya
                pha             ; Save Y
                cpy Matchend
                beq HL3         ; End of match$
                bcs HL5         ; Past match$
                lda#$86
                jsr OSBYTE      ; Get cursor x
                txa
                beq HL1         ; Start of new line within match$
                pla
                tay
                pha
                lda(Addr),y
                bpl HL5         ; Not token
                cpx#32
                bcs HLnl        ; New line if within 8 of end for token
                bcc HL5
HL3:            lda#$87         ; End of match$, white default
                ldy Hlt_code
                cpy#$88         ; Flash?
                bne *+4
                lda#$89
                jsr OSWRCH
                pla
                tay
                lda(Addr),y
                cmp#$20         ; Next chr a space?
                bne Notyet
                iny
                inc Lineend
                bne Notyet      ; Skip space
                dec Lineend
                bne Notyet      ; If whole line listing, keep=FF
HL4:            jsr OSWRCH
HL5:            pla
                tay

Notyet:         cpy Lineend
                bcc Lmore
                cpy#$FF
                beq Lmore       ; Allow for max length lines
                rts

Lmore:          lda(Addr),y
                cmp#$D          ; CR?
                beq CR_0
                cmp#$22         ; Quotes?
                bne La_0        ; No
                lda#$FF
                eor$4D
                sta$4D          ; Toggle flag
                lda#$22

Lout_0:         jsr Printasci   ; |Ctrls
                iny
                jmp Listbyte

La_0:           bit$4D          ; Within quotes?
                bpl Lout_0      ; Yes
                cmp#$8D         ; Line#?
                bne Lb          ; No
                jsr LINBINY     ; Convert internal to binary number in IAC
                tya
                pha             ; Save offset
                jsr OUTIAC      ; PRINTline#
                pla
                tay
                jmp Listbyte

Lb:             cmp#$80
                bcc Lout_0
                jsr DECRUNCH    ; Token
                iny
                jmp Listbyte

CR_0:           jmp OSASCI      ; End of line


                ; include_end: LIST
                ; include_start: REPLACE


;  REPLACE Module
; 
Global:                         ; GLOBAL REPLACE
                lda#0
                beq Common
; 
Select:                         ; SELECTIVE REPLACE
                lda#$FF
Common:         sta Switch
                jsr Printmsg
                .byte 131
                .text "Enter Replace$:"
                .word $87       ; Revert to white
                jsr Getline     ; Get Replace$
                bcc *+5         ; Escaped?
                jmp Choice
                jsr Checkline   ; Check for special syntax
                beq StoreRS
                lda#0
                sta$37
                lda#7
                sta$38
                jsr CRUNCHLINE  ; Crunch Rep$
StoreRS:        ldy#0
                sty Highlight   ; On
                sty Varpack     ; Clear flag
                dey             ; =FF
                sty Lineend     ; List whole lines
SaveRT:         iny
                tax             ; Save previous chracter
                lda $700,y
                sta $5AB,y      ; Save Rep$ in page A
                cmp#13          ; End of R$?
                bne SaveRT
                lda$700         ; Get first chr
                cmp#"["
                bne *+3
                dey             ; Delete[ not inc
                cpx#"]"         ; Last chr a ] ?
                bne Savelen
                dey
                bpl *+4
                ldy#0           ; Len cant be<0!
Savelen:        sty$5AA         ; Lenth of R$ less any []
                bit Switch      ; S or G?
                bmi Jsure       ; Selective
                jsr Printmsg
                .text "",131,"Global, are you SURE?"
                .byte 0
                jsr YesNo
                bne Rs          ; JMP Choice if no
Jsure:          jsr Sure
Rs:             jmp Choice
;  **********************************
Sure:           jsr Start       ; Also called by Varpack
                beq Rx
Nxtsrch:        jsr Nextline
Rx:             bit$FF
                bmi Rz
                jsr Search
Ra:             beq Ru
Rz:             rts             ; TOP or Escaped
Ru:             bcs Nxtsrch     ; Nomatch found
                ldy Offset
                sty Match
                ldx#3
; Check back 3 bytes to ensure matching bytes do not form part of a line#
                bit$8B
                bmi Sp          ; If Quotes open dont bother as 8D=double hieght
Sn:             dey
                cpy#4
                bcc Sp          ; Gone back into line len
                lda(Addr),y
                cmp#$8D         ; Line# marker?
                beq St          ; Yes, dont replace
                dex
                bne Sn
Sp:             bit Switch      ; Selective or Global?
                bpl Replace_0   ; Global-do it
Sq:             jsr Listline    ; List the line
                jsr Printmsg
                .text "",131,"Replace? Y/N:"
                .byte 0
                jsr YesNo
                beq Replace_0   ; Yes
                bit$FF          ; Escaped?
                bmi Rz          ; Yes
St:             jsr ConSrch     ; No,continue search
                jmp Ra
Replace_0:      bit Varpack
                bpl Nvp         ; Not variable packing
                bit $8B
                bmi St          ; Quotes open and Varpacking, dont replace-text!
Nvp:            jsr LinetoIAC   ; Put line# in IAC
                ldy#4
; Copy line out to buffer, upto match point
                lda$5AB
                cmp#"["
                bne Copy_0
                ldx#1
                bne Insert      ; [ Deletes up to R$
Copy_0:         ldx Offset
                dex
                dex
                dex
                bne C2_0
                inx
                bne Insert      ; IF X=0 now then first byte of SS is WC and matching line len byte, so skip first byte of Rep$, also WC!
C2_0:           dex             ; No of bytes to copy
                beq Insert      ; Nothing to copy
Get_1:          lda (Addr),y
                sta $6FC,y      ; Buffer at &700
                iny
                dex
                bne Get_1
; Insert replacement$, X=0
Insert:         lda $5AB,x      ; Get replacement byte
                inx             ; Cant exit loop with X=0
                cmp#13
                beq Addrest     ; End of R$
                cmp#3           ; Wildcard in replace$?
                bcs Stuff_0     ; No
                lda(Addr),y     ; Pickup equivelent byte from original line
Stuff_0:        sta $6FC,y
                cmp#13
                beq Newline_0   ; If CR picked up by wildcard, end of line
                iny
                bne Insert
; Get here if line is too long
Toolong_0:      jsr Printmsg
                .byte 131
                .text "Line too long at"
                .byte 0
                jsr PrtLino     ; Print Line#
                jmp Choice
Addrest:                        ; Add on rest of original line
                dex
                beq *+3         ; Min value 0!
                dex
                lda $5AB,x      ; Get last chr before CR in RS
                pha
                tya
                tax
                pla             ; Index to X
                cmp#"]"         ; ] deletes rest of line if last chr
                bne Addon
                dex             ; Write over ]
                lda#13
                bne Adb         ; Skip rest of line text
Addon:
                ldy SSLen       ; Pts to next chr after match$
                ora $555,y      ; Last chr of S$
                cmp#3           ; Both WCs?
                bcs Ada         ; No
                dex
                dey             ; Join text over the wcs if both S$ and R$ end WC
Ada:            lda(Ptr),y
Adb:            sta $6FC,x      ; Add byte to buffer
                cmp#13          ; End of line?
                beq Newline_0
                iny
                inx
                bne Ada
                beq Toolong_0   ; Line too long
Newline_0:      ldy#0
                jsr INSERT      ; Insert new line into program, text at &700,Y, Line# in IAC
                lda$700
                cmp#13
                bne *+5
                jmp Rx          ; If first chr on line is CR line was totally deleted,so (Adr) already=next line start
                lda$5AB
                cmp#"["         ; Deleting left?
                bne Nodelet     ; No
                lda#4
                sta Offset      ; Reset offset to line start
                clc
                adc Addr
                sta Ptr         ; Reset Ptr to first byte of line
                lda#0
                adc Addr+1
                sta Ptr+1
Nodelet:        ldx $5AA        ; R$ Lenth
                beq ND2         ; Prevent X going -ve
                lda $556        ; SS start WC?
                cmp#3
                bcs *+3
                dex             ; Yes, drop ptr back 1
ND2:            txa
                clc
                adc Ptr
                sta Ptr         ; Update Ptr to past new bytes
                bcc *+4
                inc Ptr+1
                clc
                txa
                adc Offset
                sta Offset      ; Update Offset
                jsr Sa          ; Continue search without incrementing indexs
                jmp Ra
; 
;  *********************************

                ; include_end: REPLACE
                ; include_start: TABLE


;  TABLE
;  ***********************************

Moveflag=$7B
Renum=$80
Temp=$81

;  **** TABLE LINE REFERENCES ****

TABLE:

; CHECK LINE NUMBERS AND TABLE REFERENCES
                jsr StartB      ; Set (B) to PAGE
                iny             ; =1
                lda($B),y
                bmi Finished    ; TOP if bit7 set
R1:             ldy#4           ; Text starts 4 bytes in
R2:             lda($B),y
                cmp#$8D         ; Line# marker?
                beq Gotone
                iny
                cmp#$D          ; CR?
                bne R2          ; Wait for end of line
                lda($B),y       ; Pick up first byte of next line
                ora $FF         ; Test Escape
                bmi Sort        ; Escaped or TOP
                jsr UpB         ; Update (B) pointer
                bcc R1
; 
; 
Gotone:                         ; Line reference found, check if it exists
                jsr LINBINY     ; ConJert no. to binary in IAC, save Y in &A
                jsr Findline
                bne Failed      ; Line not found
; Match found, reference OK
                ldy$A
                bne R2          ; Continue looking for 8D's
Failed:         jsr LINIAC      ; Print line# not found
                jsr LineB_iac   ; Put calling line# in IAC
                jsr Nonexistent
                ldy $A          ; Pickup original offset
                bne R2          ; Continue looking for &8D's
; 
; 
;  **********************************
done_0:         jsr OSNEWL      ; CR
Finished:       jmp Choice
; 
Sort:
; Print reference table in line# order
                jsr Start       ; Set (71) to PAGE
S0:             jsr Lineiachi
                bmi done_0
                bit$FF
                bmi Finished    ; Escaped
                jsr Findcall    ; Search prgm for any reference to line# in 2C/2D
S6:             bne S5          ; No call found
                jsr Iachi_lo    ; Copy # into 2A/2B
                jsr OSNEWL      ; CR
                jsr LINIAC      ; Print # in 5 field of referenced line
                jsr Printmsg
                .text "   "
                .byte 0
S7:             jsr Printmsg    ; Call of line# in 2C/2D found
                .text " ("
                .byte 0
                ldy$A           ; Offset Y in line (B),Y
                jsr LineB_iac   ; Put line# in 2A/B
                jsr LINIAC      ; Print # in 5 field
                lda#")"
                jsr OSWRCH
                ldy$A           ; Offset Y in line (B),Y
                jsr Findcall2   ; Continue search for any further calls of same line
                beq S7          ; Another call found
S5:             jsr Nextline    ; Update (71) ptr
                bne S0          ; Check next line#


                ; include_end: TABLE
                ; include_start: RELINK


;  RELINK
;  ****************************************
BADPROG:
; RELINK BADPROGRAM
                lda#$FF
                sta Highlight
                sta Lineend     ; List options
                jsr Start       ; (Addr)=PAGE
                ldy#1
                sta(Addr),y     ; A=0, OLD

Newtop:         ldy#0
                sty$2C
                sty$2D          ; Reset last line#
                lda#13
                sta(Addr),y     ; CR at PAGE
                iny             ; =1
                lda(Addr),y
                and#$7F         ; Do OLD
                sta(Addr),y

Next_0:         jsr LinetoIAC   ; Put line# in 2A/B, Y=2
                ldx$2B
                cpx$2D
                bcc Badlen2     ; New# < Old#
                bne NX1_0       ; New > Old ok
                cmp$2C          ; If hibytes=, check lows
                bcc Badlen2     ; New<Old
NX1_0:          sta$2C
                stx$2D          ; Update old#
                iny             ; =3

Findcr:         iny
                beq Toolong_1   ; Max line len is 255
                lda(Addr),y
                cmp#13          ; CR?
                beq Foundcr
                cmp#32          ; Control code?
                bcs Findcr      ; No
                lda#"#"         ; Mark controls with #
                sta(Addr),y
                bne Findcr

Foundcr:                        ; Found CR terminating line
                tya             ; Y=Line len
                ldy#3
                sta (Addr),y    ; Set line len byte
                jsr Listline    ; List line# linked
                jsr Nextline    ; Update (addr)
                ldx Addr+1
                inx
                cpx RAMTOP      ; Check addr
                bcs Toofar      ; Addr within 256 of Video ram?
                ldy#1
                lda(Addr),y     ; Next lines hi line#
                bpl Next_0      ; Link next line
                bmi Repeat      ; Possible TOP found

Toolong_1:                      ; Y=256, no CR found within 255 bytes of line start
                ldy#3
                lda(Addr),y     ; Original line len
                cmp#5
                bcc Badlen      ; Min length is 5
                tay
                lda#13
                sta(Addr),y     ; Put CR according to original length
                bne Foundcr

Toofar:                         ; (Addr) now in video?
                ldy#1
                lda#$FF
                sta(Addr),y     ; Put a TOP in

Linkdone:       jsr Update_Basic
                jmp Choice      ; and finish

Badlen:                         ; No CR and length<5
                ldy#$FF
                lda#13
                sta(Addr),y     ; Put CR in at max len
                tya             ; =&FF
                ldy#$3
                sta(Addr),y     ; Line Len
                bne Badlen3

Badlen2:        lda#0
                ldy#2
                sta(Addr),y     ; LSB of#
                dey
                sta(Addr),y     ; MSB

Badlen3:        ldy#1
                lda(Addr),y
                ora#$80
                sta(Addr),y     ; Force a TOP marker

Repeat:                         ; Ask if any more required
                lda Addr
                clc
                adc#2
                sta$12          ; Update BASIC TOP
                lda Addr+1
                adc#0
                sta$13
                jsr OSNEWL
                jsr Topis
                jsr Printmsg
                .text ", More?"
                .byte 0
                jsr YesNo       ; ROM's, always flush
                bne Linkdone    ; No
                jmp Newtop


                ; include_end: RELINK
                ; include_start: LINES


;  LINES
;  ****************************************
; 
;  **** MOVE / COPY / RENUMBER ****
Move:
;  MOVE LINES, deleting source lines
                lda#$FF
                bne CO1

COPY:
;  COPY LINES, not deleting
                lda#0

CO1:            sta Moveflag
                ldx#0
                stx Renum       ; Set flag false
                jsr Getnumbers
                bcc *+5         ; IF C=1 Newstart lies between Start & finish
                jsr Synerr      ; JSR as synerr drops stack
                jsr Checkcrash  ; Checkcrash checks if newlines will overwrite existing lines

                bit Moveflag
                bpl CO12        ; Copying
                jsr Rereference ; If Moveing change any calls
                jsr News2_news

CO12:           jsr Findstart   ; rtns Addr of first line in (Addr)
Moveline:
                jsr Newstoiac   ; Put rqd line# in 2A/2B
                jsr Lineiachi   ; Save line# of source line
                ldy#3
ML1:            iny
                lda(Addr),y
                sta$6FC,y       ; Move line text into buffer 700
                cmp#13          ; CR?
                bne ML1

                ldy#0
                jsr INSERT      ; Insert line, # in IAC, text at 700,Y
                jsr Iachi_lo
                jsr Findline    ; Find new addr of source line
                bit Moveflag
                bpl Copying

                lda#13
                sta$700         ; Line =CR only
                ldy#0
                jsr INSERT      ; Delete source line
                jmp CO2         ; If deleting (Addr) already = nextline

Copying:        jsr Nextline    ; Update (Addr)

CO2:            jsr UpNews
                bcc Moveline    ; Not finished yet
                bit Moveflag
                bpl *+5         ; Copying
                jmp Choice      ; Moving all done

; If Copying renumber any valid calls
Copyrenumber:
; Check new lines for any reference to new lines and update.
                sec
                lda Newstart
                sbc Step
                tax
                ldy Newstart+1
                bcs *+3
                dey
                jsr News2_news
                stx News2
                sty News2+1     ; Set News2 to last new# used
                jsr Newstoiac
                jsr Findline    ; Find (Addr) of New lines start
                lda Addr
                sta Temp
                lda Addr+1
                sta Temp+1      ; Save Addr
                jsr Findstart   ; Find (Addr) of Old lines start
CR1_0:          jsr Lineiachi   ; Put old line# in 2C/D
                lda Temp
                sta$B
                lda Temp+1
                sta$C           ; Set (B) to start of new lines
                ldy#4
CR2:            jsr Findcall2   ; Search for any reference to line 2C/D
                bne CR5_0       ; No call found
; Call found, check if its in a line past the last newline
                ldy#1
                lda($B),y
                cmp News2+1     ; Check Hi bytes
                bcc CR3_0       ; Calling line is a new line
                bne CR5_0       ; Calling line is not new
                iny
                lda News2
                cmp($B),y
                bcc CR5_0       ; Calling line is not new
CR3_0:                          ; Call of new line by a new line found
                jsr Newstoiac
                jsr Insertline_no; Insert new#
                bne CR2         ; Continue looking for calls
CR5_0:                          ; No (more) calls of line 2C/D found
                jsr Nextline    ; Update (Addr)
                jsr UpNews      ; Add step to Newstart and check finish
                bcc CR1_0
                jmp Choice      ; Copy all done!

UpNews:                         ; Update Newstart#
                lda Step
                clc
                adc Newstart    ; Add step to line#
                sta Newstart
                bcc *+4
                inc Newstart+1

Checkfinish:
                ldy#1
                lda(Addr),y     ; Hibyte of line#
                bmi gonepast    ; TOP found
                cmp Finish+1
                bcc notyet
                bne gonepast
                iny
                lda(Addr),y     ; Lo byte of line#
                cmp Finish
                bcc notyet
                beq notyet
gonepast:       sec
                rts             ; RTN C=1
notyet:         clc
                rts             ; RTN C=0
;  ****************************************
Getnumbers:
; GET Required line numbers
; START,(FINISH),NEWSTART,(STEP)
                jsr Printmsg
                .byte 131
                .text "Start,(Finish),Newstart,(Step)?"
                .byte 13
                .byte 0
                jsr Getline     ; Input line at 700
                bcs Out_0       ; Escaped
                ldy#0
                sty$F2
                lda#7
                sta$F3          ; Point (F2),Y to line
                ldx#Lstart      ; Addr for result
                lda#$FF
                sta Lstart+1
                sta Newstart+1
                jsr DECBIN      ; Rtns next chr in A
                bcs Numok
Synerr:         jsr Printmsg
                .text "Syntax"
                .byte 0
Out_0:          pla
                pla             ; Drop rtn addr
                jmp Choice

Numok:          beq Synerr      ; IF CR line tooshort
                ldx Lstart+1
                bmi Synerr      ; If Hi byte still FF no number given
                bit Renum
                bmi GN1         ; Leave Finish if Renumbering
                stx Finish+1
                ldx Lstart
                stx Finish      ; Set default finish to start for MOVE/COPY only
GN1:            ldx#10
                stx Step
                ldx #0
                stx Step+1      ; default step 10
                jsr Skipcomma
                ldx #Finish
                jsr DECBIN
                bcc Synerr      ; Too big
                beq Synerr      ; CR, line too short
                ldx Finish+1
                cpx Lstart+1
                bcc Synerr      ; If hibyte of Finish < Start!
                bne GL1
                ldx Finish      ; If hibytes equal, check lows
                cpx Lstart
                bcc Synerr      ; Finish < Start!
GL1:            jsr Skipcomma
                ldx#Newstart
                jsr DECBIN
                bcc Synerr      ; Too big
                beq GL3         ; CR, Step not given
                jsr Skipcomma
                ldx#Step
                jsr DECBIN
                bne Synerr      ; CR must follow step
                bcc Synerr      ; Too big
                lda Step+1
                bne Synerr      ; Step>255
                lda Step
                beq Synerr      ; Step=0
GL3:            jsr Newstoiac
                sta News2+1
                stx News2       ; Save 2nd copy of Newstart#

; Check if line# in 2A/B lies between start and finish nos., if so rtn C=1
GL8:            lda$2B
                bmi Synerr      ; Line# not given
                cmp Lstart+1
                bcc GL4         ; RTS,C=0 if NS<S
                bne GL5         ; If NS>S check finish
                lda$2A          ; If hibytes=, check lows
                cmp Lstart
                bcs GL5         ; NewS>S, check F
GL4:            rts             ; Rtn C=0 if NS<S
GL5:                            ; If NS>=S, check finish
                lda Finish+1
                cmp$2B
                bcc GL6         ; F<NS, rtn C=0
                bne GL6         ; F>NS, rtn C=1
                lda Finish
                cmp$2A
GL6:            rts

Skipcomma:      cmp#","
                beq comma
                pla
                pla
                jmp Synerr
comma:          jmp Skposcl     ; Get next non space chr
;  ****************************************
; .Nonexist JSR Nonexistent
; JMP Out \Drop rtn addr

; Checkcrash checks if newlines will overwrite existing lines, and if new#s go > 32767

Checkcrash:     jsr Findstart
; BNE Nonexist \Start line not there
                bcc CC6         ; TOP
                jsr Newstoiac
                jsr StartB      ; Point (B) to PAGE
                beq *+5
CC1:            jsr UpB         ; Update (B)
                ldy#1           ; Find first existing line# after Newstart
                lda($B),y
                bmi CC6         ; Top found
                cmp$2B          ; First new number
                bcc CC1         ; Existing< new
                bne foundit     ; Existing > new
                iny
                lda($B),y       ; Check low bytes if hi bytes equal
                cmp$2A
                bcc CC1
                bne foundit     ; existing>new
                bit Renum
                bpl Crash       ; Existing=Newstart and not renumbering
                jsr LineB_iac   ; If renumbering check match is outside S&F
                jsr GL8
                bcc Crash
                bcs CC5

foundit:                        ; Found the first existing line# after Newstart#
                bit Renum
                bpl CC3         ; Not renumber
                jsr LineB_iac   ; Put line# in 2A/B
                jsr GL8         ; See if line lies between start and finish
CC5:            jsr Newstoiac   ; Replace Newstart in 2A
                bcs CC1         ; If it does lie between S&F go on to find the first that isnt.
CC6:            jsr News2_news
                jsr Newstoiac   ; For renumber put real newstart in news
CC3:            jsr Nextline    ; Update (Addr)
                jsr Checkfinish
                bcs CC2         ; Finished
                lda Step
CC4:            clc
                adc$2A
                sta$2A
                tax             ; Add Step to Newline#
                lda$2B
                adc#0
                sta$2B
                bmi Linetobig   ; >32767
                ldy#1
                cmp($B),y       ; Hi byte of stop line#
                bcc CC3
                bne Crash       ; gone past stop line#
                iny
                txa             ; Check lo bytes
                cmp($B),y
                bcc CC3
Crash:
                jsr Printmsg
                .text "Overlap at "
                .byte 0
                jsr OUTIAC      ; Print line# in 2A/B
                jmp Out_0       ; Drop rtn addr and exit
Linetobig:
                jsr Printmsg
                .text "Lines > 32767"
                .byte 0
                jmp Out_0
CC2:                            ; Line#s OK
                rts
;  ****************************************
Renumber:
                ldx #$FF
                stx Renum
                stx Finish
                stx Finish+1    ; Set Finish to last line
                jsr Getnumbers
; Doesnt matter if NS lies between S&F

                lda Lstart
                sta Newstart
                lda Lstart+1
                sta Newstart+1
                jsr Checkcrash
                jsr Checkcrash

                jsr Rereference ; Update all GOTOs

                jsr Findstart   ; Rtn addr of Start in (Addr)
                jsr News2_news  ; Restore Newstart

RN2:            ldy#1
                lda Newstart+1
                sta(Addr),y     ; Insert new# hi
                iny
                lda Newstart
                sta(Addr),y     ; Insert new# lo
RN3:            jsr Nextline    ; Update (Addr)
                jsr UpNews      ; Update Newstart#
                bcc RN2         ; Not finished yet
                jmp Choice      ; RENUMBER done


Rereference:
;  Change any calls to lines about to be renumbered.
                jsr StartB      ; Set (B) to PAGE
                beq RF2
RF1:            jsr UpB         ; Update (B)
RF2:            ldy #1
                lda ($B),y
                bpl RF3
                rts             ; TOP found, all done
RF3:            ldy#3
RF4:            iny
RF4a:           lda($B),y
                cmp#13          ; CR?
                beq RF1
                cmp #$8D        ; Line#?
                bne RF4

; 8D line marker found
                jsr LINBINY     ; Convert to binary in 2A/B
; Check if line# is < Start
                lda$2A
                sec
                sbc Lstart
                lda$2B
                sbc Lstart+1
; If line# is < Start, C=0
                bcs RF5

Nochange:       ldy $A          ; Left in A by LINBINY
                bne RF4a

RF5:                            ; Check if Line# > Finish
                sec
                lda Finish
                sbc $2A
                lda Finish+1
                sbc $2B
;  If line# > Finish C=0
                bcc Nochange

; Call to Renumbered line found
; Calculate new number and insert it at call
                lda$2A
                sta$2C
                lda$2B
                sta$2D          ; Save line#
                jsr Findstart   ; Rtn (Addr) of Start line
                jsr News2_news
RF6:            ldy#1
                lda (Addr),y
                cmp $2D
                bne RFnotyet
                iny
                lda(Addr),y
                cmp $2C         ; Line# low
                beq Changeit
RFnotyet:       jsr Nextline    ; Update (Addr)
                jsr UpNews      ; Add Step to Newstart
                bcc RF6         ; C should be 0
                bcs Nochange

Changeit:                       ; (B),A = addr of call to renumbered line, New# in Newstart
                jsr Newstoiac   ; Put new# in 2A/B
                jsr Insertline_no; Rtns Y offset correct
                jmp RF4a        ; Continue looking


Insertline_no:                  ; Insert line# in 2A/B into line text at (B),A in internal format.
                ldy$A
                dey             ; Offset into line
                lda$2B
                ora#$40         ; Set 6 & 7
                sta($B),y
                dey
                lda$2A
                and#$3F
                ora#$40         ; Set 6 & 7
                sta($B),y
                dey
                lda$2A
                and#$C0
                sta$2A
                lda$2B
                and#$C0
                lsr a
                lsr a
                ora$2A
                lsr a
                lsr a
                eor#$54         ; Set 7&6, invert 2&4
                sta($B),y
                ldy$A           ; Rtn with original line offset
                rts
Exit:           jmp Choice


                ; include_end: LINES
                ; include_start: PACK


;  PACK
;  ***************************
PACK:
; Strip program of REMs,COMMENTS,SPACES and CONCATENATE lines
Space_del=$83
Rem_del=$84
Comm_del=$85
Concat_flag_0=$86
Assm_flag=$87
Space=$7E
Tempx=$7F
Tempy=$80
Previous=$81
RHS=$82
Singleuse=$8A

                lda#0
                sta Varpack
                sta Singleuse
                ldx#4
PK1:            sta Space_del,x ; Clear flags
                dex
                bpl PK1
                jsr Printmsg
                .text"REMs?"
                .byte 0
                jsr YesNo
                bne *+4
                dec Rem_del     ; Flag on,-ve
                jsr Printmsg
                .text "Spaces?"
                .byte 0
                jsr YesNo
                bne *+4
                dec Space_del
                jsr Printmsg
                .text"Comments?"
                .byte 0
                jsr YesNo
                bne *+4
                dec Comm_del
                jsr Printmsg
                .text "Variables?"
                .byte 0
                jsr YesNo
                bne Novar
                dec Varpack
                jsr Printmsg
                .text "Use unused singles?"
                .byte 0
                jsr YesNo
                bne Novar
                dec Singleuse

Novar:          jsr Printmsg
                .text"Concatenate?"
                .byte 0
                jsr YesNo
                bne *+4
                dec Concat_flag_0

                bit$FF
                bpl *+5
                jmp Choice      ; Escaped
                jsr OSNEWL
                jsr Topis
                lda $12
                sta$A8
                lda$13
                sta$A9          ; Save TOP
                bit Varpack
                bpl *+5
                jsr VARPACK
                jsr OSNEWL
                jsr Topis
                jsr Dis_Printer
                lda Comm_del
                ora Space_del
                ora Rem_del
                beq PK99        ; If no flags set goto concat
                jsr Start
                jsr StartB

Nxtlin:
                ldy#1
                lda(Addr),y
                sta($B),y       ; Transfer line#
                ora $FF         ; Test Escape
                bpl PK88

PK99:           jmp CONCATENATE ; TOP found or escaped

PK88:           iny
                lda(Addr),y
                sta($B),y
                iny
                lda(Addr),y
                sta$2A          ; Keep line length
                iny
                ldx#1           ; Get & put offsets

Nxtchr:         lda(Addr),y
                cmp#13
                bne *+5
PK10:           jmp Insertline
                cmp#$22         ; Quote?
                bne Notquote_0
                jsr Putchr
PK3:            jsr Transfer
                beq PK10        ; CR found
                cmp#$22
                bne PK3         ; Transfer up to next quote or CR
                beq Nxtchr

Notquote_0:     cmp#$8D         ; Line#?
                bne Notlineno
                lda#4
                sta Tempx
PK4:            jsr Transfer
                dec Tempx
                bne PK4         ; Transfer 4 bytes
                beq Nxtchr

Notlineno:      bit Assm_flag   ; In assembler?
                bpl Notassm
                cmp#"\"         ; Comment?
                bne Notcommt
                stx Tempx
PK5:            jsr Transfer
                beq PK6         ; CR
                cmp#":"
                bne PK5         ; Transfer up to colon or CR
                bit Comm_del
                bpl Nxtchr      ; Not deleting
                ldx Tempx       ; If deleting restore X to previous value
                cpx#1
                beq Nxtchr      ; If \ first on line ignore it, else..
                dey
                jsr Transfer    ; Transfer the colon
                bne Nxtchr
PK6:            bit Comm_del
                bpl PK10        ; Insertline
                ldx Tempx
                bne PK10        ; Insertline

Notcommt:       cmp#"]"         ; End of assembler?
                bne Notassm
                sta Assm_flag   ; Flag off +ve

Notassm:        cmp#"["         ; Start of assembler?
                bne *+4
                ror Assm_flag   ; Flag on-ve, C=1
                cmp#$F4         ; REM?
                bne Notrem
                stx Tempx
PK7:            jsr Transfer
                bne PK7         ; Transfer rest of line
                bit Rem_del
                bpl Insertline  ; Not deleting REMS
                ldx Tempx
                cpx#1           ; If X=1 REM is first on line
                beq Insertline  ; so force blank line
                dex             ; If REM not first delete the previous..
                bne Insertline  ; ..colon

Notrem:         cmp#$DC         ; DATA?
                bne Notdata
PK8:            jsr Transfer
                bne PK8         ; Transfer rest of line
                beq Insertline

Notdata:        cmp#"*"         ; Check OSCLI
                bne Notoscl
                cpx#1
                beq PK8         ; Transfer rest of line if first chr is *
                lda Previous
                cmp#":"
                beq PK8         ; or start of statement
                cmp#$8C         ; or THEN
                beq PK8
                cmp#$8B         ; or ELSE
                beq PK8
                lda#"*"         ; Restore *

Notoscl:        cmp#32          ; Space?
                beq Spc
PK9:            jsr Putchr
                jmp Nxtchr

Spc:            bit Space_del
                bpl PK9
                bmi Spcoff

Transfer:       lda(Addr),y
Putchr:         sta $6FF,x
                sta Previous
                inx
                iny
                cmp#13
                rts

Insertline:     lda#13
                sta $6FF,x
                jsr Nextline    ; Update Addr
Put:            iny
                lda$6FC,y
                sta($B),y
                cmp#13
                bne Put
                tya
                pha
                cmp#4
                beq Dont
                ldy#3
                sta($B),y
                jsr UpB

Dont:           pla
                cmp#4
                bne *+4
                lda#0
                clc
                adc$12
                bcc *+4
                inc$13
                sec
                sbc$2A
                bcs *+4
                dec$13
                sta$12
                jsr Topover     ; Print new TOP
                jmp Nxtlin

Spcoff:
                stx Tempx
                sty Tempy
                iny
                lda(Addr),y
                sta RHS
                jsr TypeX2      ; Look at next chr.
                beq dropspc     ; Space not rqd
                dex
                txa
                eor#1
                sta Space       ; Letter=1,number=0
                ldy Tempx
                dey
                lda Previous
                jsr TypeX2
                beq dropspc
                ldx#1           ; Dummy for first pass
                iny
back:           dex
                txa
                ora Space
                sta Space
                dey
                lda $6FF,y
                jsr TypeX2
                bne back        ; Search back until NOT number or NOT letter or line start
                cpy#0
                beq ChkE        ; IF terminator on LHS is line Len, OK
                cmp#"&"
                bne ChkE
                lda RHS         ; If terminator is hex (&) check RHS chr is not A-F
                cmp#"A"
                bcc dropspc
                cmp#"G"
                bcc Keepspc
                bcs dropspc
ChkE:           ldx Space
                bne Keepspc
                lda RHS
                cmp#"E"         ; IF chr after space is E look for possible Exponent confusion
                bne dropspc
                lda Previous
                jsr TypeX2      ; Check chr before space
                dex
                bne dropspc     ; not a number OK
; IF it is, space is rqd, to avoid viz. IF X=12 E2%=0 becoming 12E2 (1200)

Keepspc:                        ; Space required for legal syntax
                ldx Tempx
                ldy Tempy
                jsr Transfer
PK11:           jmp Nxtchr

dropspc:        ldx Tempx
                ldy Tempy
                iny
                bne PK11        ; Dont transfer space

TypeX2:         ldx#0
                cpy#0
                beq F_0         ; Start of line
                cmp#$30
                bcc F_0
                cmp#$3A
                bcc N_0
                cmp#$40
                bcc F_0
                cmp#$5B
                bcc L
                cmp#$5F
                bcc F_0
                cmp#$7B
                bcs F_0
L:              inx             ; Rtn X=2 for letters
N_0:            inx             ; Rtn X=1 for numbers
F_0:            cpx#0           ; Rtn X=0 for others
                rts


                ; include_end: PACK
                ; include_start: CONCAT


;  CONCAT
; ***********************************
Concat_flag_1=$86
Vptr_0=$7F
Startchr=$81
Firstletter=$82
Nameptr=$89
Assmflag=$87
Secondchr=$88

;  ****  LINE CONCATENATE ROUTINE  ****

CONCATENATE:
                bit Concat_flag_1
                bpl T1_0        ; Not concatenating
                jsr Start       ; Set (Addr) to PAGE
TRYIT:
                ldy#1
                lda(Addr),y
                ora$FF          ; Test Escape
                bpl T2_0

T1_0:           sec
                lda$A8
                sbc$12
                sta$2A          ; TOP difference
                lda$A9
                sbc$13
                sta$2B
                jsr En_Printer  ; Enable printer
                jsr Printmsg
                .byte 13
                .text "Bytes saved= "
                .byte 0
                jsr OUTIAC
                jsr Update_Basic
                jmp Choice

T2_0:           ldy#3
                lda(Addr),y     ; Line length
                clc
                adc Addr
                sta Ptr         ; Set (Ptr) to next line
                lda Addr+1
                adc#0
                sta Ptr+1
                ldy#1
                lda(Ptr),y
                bmi T1_0        ; TOP found, all done
                ldy#3
                lda(Addr),y     ; Line length of line1
                sbc#2           ; C=0, so -3
                clc
                adc(Ptr),y      ; Line length of line2
                bcc LenthOK     ; Total < 256, OK

FAILED:                         ; Cant add lines1+2 for any reason
                lda Ptr
                sta Addr
                lda Ptr+1
                sta Addr+1      ; Transfer line2 ptr to line1 ptr
                bne TRYIT       ; and try with new line1

LenthOK:                        ; Check line2 is not referenced by number
                ldy#1
                lda(Ptr),y      ; Line# Hi
                sta$2D
                iny
                lda(Ptr),y      ; Line# Lo
                sta$2C
                jsr Findcall    ; Search prgm for any reference to line# in 2C/2D
                beq FAILED      ; Line is referenced
; Check lines for invalidating syntax
                ldy#4           ; Text start 4 bytes in
                lda(Addr),y
                cmp#"*"
                beq FAILED      ; If line1 starts * then OS cmnd.
                lda(Ptr),y
                cmp#$DD
                beq FAILED      ; Line2 cant start DEF
                cmp#$DC
                beq FAILED      ; Line2 cant start DATA

Check_0:        lda(Addr),y
                iny
                cmp#13          ; CR?
                beq Passed      ; End of line, syntax OK
                cmp#$E7         ; IF?
                beq FAILED
                cmp#$F4         ; REM?
                beq FAILED
                cmp#$DC         ; DATA?
                beq FAILED
                cmp#$85         ; ERROR?
                beq FAILED
                cmp#":"
                bne Check_0
                lda(Addr),y     ; Next byte
                cmp#"*"
                beq FAILED      ;  colon* means OS cmnd.
                bne Check_0

Passed:                         ; Syntax OK
; COPY LINE 1 OUT TO BUFFER
                ldy#3
P1_1:           iny
                lda(Addr),y
                sta $6FC,y      ; Assemble line in page 7
                cmp#13          ; CR?
                bne P1_1
                lda#":"
                sta $6FC,y      ; Replace CR with colon
                tya
                tax
                inx
; ADD LINE 2 TO BUFFER
                ldy#3
P3_1:           iny
                lda(Ptr),y
                cmp#":"         ; Skip leading colons
                beq P3_1
P2_1:           lda(Ptr),y      ; Line2 text
                sta $6FC,x
                iny
                inx
                cmp#13          ; CR?
                bne P2_1
; PUT LINE1 Number in IAC, Save line2 number in temp
                jsr LinetoIAC   ; Put line# in 2A/B
                lda(Ptr),y
                sta$2C
                dey
                lda(Ptr),y
                sta$2D          ; Save Line#2 in 2C/D
                ldy#0
                jsr INSERT      ; Insert compound line into prgm, text at 700,Y, number in IAC
                jsr Iachi_lo    ; Transfer line#2 from 2C/D to 2A/B
                lda#13          ; CR
                sta $700        ; Put CR in line buffer, ie blank line
                ldy#0
                jsr INSERT      ; Delete original line2, number in IAC
                jsr Topover     ; Print TOP
                jmp T2_0


                ; include_end: CONCAT
                ; include_start: VARPACK


;  VARPACK
Vptr=$7F
SVp=$7A
OldVartop=$4B6
;  * VARPACK and VARXREF *

VARXREF:        lda#0
                sta Varpack
Xv1:            jsr VARPACK
Xv2:            jmp Choice

VARPACK:        jsr Scanprogram
                lda$2           ; Vartop
                sta OldVartop
                lda$3
                sta OldVartop+1 ; Save current value
                jsr Readstack
Vclear:         ldx#$80
                lda#0
Vcl1:           sta$47F,x       ; Clear Link table
                dex
                bne Vcl1
                sta Assmflag    ; Reset to +ve, off
                rts

Readstack:      jsr OSNEWL
                lda#2
                sta Startchr    ; CtrlB, WC
                lda#"@"
                sta Firstletter
                ldx# Fake % 256
                lda# Fake / 256
                sta$8C          ; Set Variables flag -ve,on
                bne SS2         ; @% is not in chain
Fake:           .word 0         ; No link addr
                .text "%"
                .byte 0

Newletter:      inc Firstletter
                lda Firstletter
                cmp#123
                bcc Nxl4        ; <=z
                bne Nxl1        ; FN yet to do?
                ldx#$F2         ; PROC token
                lda# $F6/2      ; Offset to PROC chain/2
                bne Nxl3
Nxl1:           cmp#$A5         ; FN done?
                bne Nxl2        ; No
Vend:           ldx#0
                stx SSLen
                inx
                stx$500         ; Set SSLens to 0
                lda#13
                sta$501
                sta$556         ; Set S$s to CRs
                rts             ; Alldone
Nxl2:           ldx#$A4         ; FN token
                lda#$F8/2       ; Offset to FN chain/2
Nxl3:           stx Firstletter
                ldy#0
                sty Startchr    ; Ctrl@, WC
Nxl4:           asl a
                tay             ; Link offset addr
                ldx $400,y      ; LSB in X
                lda $401,y      ; MSB of link
Nxl5:           beq Newletter   ; No chain link

Setsearch:
                cmp OldVartop+1 ; Check not reading any
                bcc SS2         ; new single chr variables
                bne Newletter
                cpx OldVartop
                bcs Newletter
SS2:            sta Vptr+1
                stx Vptr
                bit$FF
                bmi Vend        ; Escaped
                lda Startchr
                sta$556         ; WC starts S$
                sta$5AB         ; and R$
                lda Firstletter ; A-z or token
                ldy#1
                sta$5AC         ; R$ first chr
Stuff_1:        sta$556,y       ; Build S$
                jsr DECRUNCH    ; Print 
                iny
                lda(Vptr),y
                bne Stuff_1     ; 0 ends name
; Y=Length of name+1
                sty SSLen       ; Length inc initial WC
                dey
                cpy#1
                beq real_0      ; If Y=1 single chr real name
                lda(Vptr),y     ; Last chr of name
                jsr TypeX2
                beq notreal     ; rtns Z=1 if not letter or number, ie (%$
; This is a real or PROC/FN name
real_0:         lda#2
                sta $557,y      ; Put in final CtrlB WC
                inc SSLen
notreal:        sty SSLenW      ; Length of S$ less end WCs
                jsr Count2      ; Count occurences
                jsr Printmsg
                .text" ["
                .byte 0
                jsr OUTIAC      ; Print in 0 field
                lda#"]"
                jsr OSWRCH
                lda#134
                jsr OSBYTE      ; Read Cursor pos
                txa
                sec
                sbc#16          ; Tab to col 16 if possible
                bcc Tb4
                lda#$FE         ; else +2
Tb4:            tax
Tab_0:          jsr Space1      ; Tab to next column
                inx
                bne Tab_0
                bit Varpack
                bmi Replace_1
                jsr Lines2      ; Print match line#s for XREF

UpdateVp:       jsr OSNEWL
                ldy#0
                lda (Vptr),y
                tax             ; LSB of link addr
                iny
                lda (Vptr),y    ; MSB in A
                jmp Nxl5

Replace_1:                      ; Shorten variable names by global replace
                ldx#3
                bit Firstletter
                bpl *+3
                inx             ; Min length=2 for PROC/FN
                cpx SSLen
                bcs UpdateVp    ; length short already

                ldy#2
                sty Nameptr
                lda#"@"
                sta Secondchr
                lda#13
NM0:            sta $5AE,y      ; Y=2 still
                dey
                bpl NM0         ; Put 3 CR in as lenght of R$ varies
;  Startchr and Firstletter already in 5AB/C
; Try single chr name first if not PROC/FN
                bit Firstletter
                bpl *+5
NMJ:            jmp Newname
                ldx SSLen       ; Check S$ not A%( or B$( etc
                lda$554,x       ; 2nd last chr of S$
                cmp#38          ; % or $ ?
                bcs NMK         ; No
                cpx#5           ; X=4 for A%(
                bcc NMJ         ; Goto 2chr name
NMK:            ldy#$2
                sty$39          ; Name len, A% etc
                iny             ; =3
                sty $5AA        ; R$ len
                jsr NM2b        ; Check newname not used
                bne Newsingle   ; already in use
                jmp Substitute
Newsingle:                      ; Try for unused single chr name
                bit Singleuse
                bmi *+5
                jmp Newname     ; Singles not required
                lda#"@"
                sta$5AC         ; First chr of R$
Nextsingle:                     ; Check catalogue for other variables using their own start chr.
                inc$5AC
                lda$5AC
                cmp#123         ; >z?
                bcs Newname     ; Goto 2 chr name
                cmp#91          ; >Z?
                bne SN1
                lda#97          ; Skip to a
                sta$5AC
SN1:            asl a
                tay
                lda$401,y
                tax             ; MSB of Link
                lda$400,y
Setlink:        sta SVp         ; LSB
                txa
                sta SVp+1       ; MSB
                beq Foundsingle ; End of chain, current R$ OK to use
                ldy#1
                lda#$FF         ; dummy
Loop_0:         iny
                tax
                lda(SVp),y
                bne Loop_0      ; Find 0 terminator
                txa             ; Last chr of name
                ldx$5AA         ; R$ length
                cmp#"0"
                bcc Snotreal    ; <0=$(%
; Name is real, is R$ real?
                lda$5AA,x
                cmp#3
                bcc Nextsingle  ; Yes
                bcs Linkup
Snotreal:       cmp#"("         ; Array?
                beq Sarray
                cmp $5AA,x
                beq Nextsingle
                bne Linkup
Sarray:         cmp$5AA,x       ; Is R$ an array?
                bne Linkup
                dey
                dey
                cpy#2
                bcc Srealarray
                lda(SVp),y      ; 2nd last chr of name
                cmp#"0"
                bcs Srealarray
                cmp$5A9,x
                beq Nextsingle
                bne Linkup
Srealarray:     lda$5A9,x
                cmp#"0"
                bcs Nextsingle
Linkup:         ldy#1
                lda(SVp),y
                tax             ; MSB of Link addr
                dey
                lda(SVp),y
                jmp Setlink
Foundsingle:                    ; R$ is valid name
                jsr SETVAR      ; 37,38,39 are still set
                jsr Vf9         ; Update Vartop
                bcs Newname     ; No room left
                jmp Substitute

Newname:        lda Firstletter
                sta$5AC         ; Restore R$ first letter
                ldx SSLen
                cpx#5
                bcs *+5
Upstage:        jmp UpdateVp    ; Already 2 chr name
                ldy#3
                sty$39          ; Name len for stack search
                iny             ; =4
                sty$5AA         ; R$ len
                inc Nameptr
                ldy Nameptr
                lda$555,y       ; Next letter from S$
                cpy SSLen       ; At or Past end of S$?
                bcc NM1         ; Not yet
Fiddle:                         ; Generate a name
                inc Secondchr
                lda Secondchr
                cmp#123         ;  >z?
                bne F2
                lda#"0"         ; Try 0-9 last
                sta Secondchr
F2:             cmp#$3A
                beq Upstage     ; Cant produce a new name
                cmp#91
                bne NM1
                lda#95
                sta Secondchr   ; [\]^ are illegal, so skip to _
NM1:            cmp#"$"
                beq Array       ; IF chr (not last) is $ or % must be an array
                cmp#"%"
                bne NM2
Array:          cpy#5
                bcc Upstage     ; If Y<5 then name is NA%( or N$( etc, dont shorten
                bcs Fiddle      ; Start fiddling a name
NM2:            sta$5AD         ; Insert new 2nd chr
                jsr NM2b
                bne Newname     ; Name in use
                jmp Substitute
NM2b:           ldx SSLen       ; Check if R$ is already a variable name
                lda $555,x      ; Last chr of S$
                cmp#3
                bcs NM3         ; Not a WC
                dec $39         ; Real names are only 2 chrs
NM3:            ldy$554,x       ; Get 2nd to last chr
                ldx$5AA         ; R$ len 3 or 4
                cmp#"("         ; Array?
                bne NM4
                cpy#"%"
                beq NM5
                cpy#"$"
                bne NM4
NM5:            sta $5AB,x      ; Put the ( in as last chr
                inc $5AA        ; Add 1 to R$ len
                inc$39          ; and name len
                tya             ; % or $
NM4:            sta $5AA,x      ; Last chr of R$ or 2nd to last if $ or % array
                lda#$AB
                sta $37         ; (&37) points to chr before Name
                lda#5
                sta$38          ; MSB
; Length already in &39
                bit Firstletter
                bpl NN2         ; If -ve its a Token..
                jmp FINDPROC

NN2:            jmp FINDVAR

; Transfer new name to stack and print it
Substitute:     ldy#1
                ldx#2
NN4:            lda$5AA,x
                cmp#32
                bcc NN5         ; CR or WC marks end
                jsr DECRUNCH
                cpy#1
                beq NN8         ; First chr not on stack
                sta (Vptr),y
NN8:            iny
NN7:            inx
                bne NN4
NN5:            lda#0
                sta Switch      ; Global replace switch ON
                sta(Vptr),y     ; End of name moves
                jsr Sure        ; Do a Global replace
                jmp UpdateVp

; Lexical analysis of Prgm to find variables

Scanprogram:

                jsr Vclear      ; Clear link table
; Set VARTOP to LOMEM+64
                ldx$1           ; Lomem MSB
                lda$0           ; Lomem LSB
                adc#64
                sta$2           ; VARTOP
                bcc *+3
                inx
                stx$3
                jsr Start       ; Set (Addr) to PAGE
                beq Vnl2
Vnxtline:       jsr Nextline    ; Update (Addr)
Vnl2:           ldy#1
                lda(Addr),y
                ora $FF         ; Test escape and Top
                bpl *+3
                rts             ; TOP or Escaped
                ldy#3
Vnxtchr:        iny
Vnxtchr2:       lda(Addr),y     ; Line byte
                cmp#13          ; CR?
                beq Vnxtline
                cmp#$22         ; Quote?
                bne Vnotq
Vq1:            iny
                lda(Addr),y     ; Find..
                cmp#$22         ; .Closing quote
                beq Vnxtchr
                cmp#13
                beq Vnxtline    ;  or CR
                bne Vq1
Vnotq:          cmp#$8D         ; Line#?
                bne Vnotlino
                iny
                iny
                iny             ; Skip next 3 bytes
                bne Vnxtchr
Vnotlino:       bit Assmflag
                bpl Vnotasmb
                cmp#"\"         ; Comment?
                bne Vnotcomm
Vc1:            iny
                lda(Addr),y     ; Find..
                cmp#":"         ; .colon
                beq Vnxtchr
                cmp#13
                beq Vnxtline    ;  or CR
                bne Vc1
Vnotcomm:       cmp#"]"         ; End of assembler?
                bne Vnotasmb
                sta Assmflag
                beq Vnxtchr     ; +ve = off
Vnotasmb:       cmp#"["         ; Start of Assembler?
                bne VRem
                lda#$FF
                sta Assmflag    ; -ve = on
                bne Vnxtchr
VRem:           cmp#$F4         ; REM?
                beq Vnxtline    ; Skip rest of line
                cmp#$DC         ; DATA?
                beq Vnxtline
                cmp#"*"         ; Possible OS cmnd?
                bne Vnotoscl
                tya
                tax             ; Save Y
Vo2:            dey             ; Look for previous chr
                cpy#4           ; Gone back into line len?
                bcc Vnxtline    ; If so * is first chr, Skip line
                lda(Addr),y
                cmp#32          ; Space?
                beq Vo2
                cmp#":"
                beq Vnxtline    ; Colon* is OS cmnd
                cmp#$8C         ; THEN?
                beq Vnxtline
                cmp#$8B         ; ELSE?
                beq Vnxtline
                txa
                tay             ; Restore Y
                bne Vnxtchr     ; Variable cant start * anyway
Vnotoscl:       cmp#"&"         ; HEX?
                bne Vnothex
Vn2:            iny             ; Find end of Hex$
                lda(Addr),y
                jsr TypeX2      ; Rtns X=0 if not 0-9 or A-z
                beq Vnxtchr2    ; Terminator found if X=0
                cmp#"G"
                bcc Vn2         ; 0-9 or A-F, still hex
                jmp Vnxtchr2    ; >F, not hex
Vnothex:        cmp#$B8         ; TO?
                bne Vnotop
                iny
                lda(Addr),y     ; Look at next chr
                cmp#"P"         ; TOP?
                beq Vnxt2       ; Yes
                dey             ; Restore offset
                lda(Addr),y     ; and byte
Vnotop:         cmp#$F2         ; PROC?
                beq Vfound
                cmp#$A4         ; FN?
                beq Vfound
                tax             ; Set sign flag
                bpl Vn3         ; Not a token if +ve
Vnxt2:          jmp Vnxtchr
Vn3:            jsr Type        ; Alpha?
                bcc Vnxt2       ; Not A-z
; START OF VARIABLE FOUND
Vfound:         dey             ; Point back to chr before name
                sta Firstletter ; Save first chr of name
                tax
                lda(Addr),y     ; Get previous chr
                cpy#4           ; Check
                bit Assmflag
                bpl Vf2
; If in assembler check for Label
                bcc Vf3         ; Not label if Y<4
                cmp#"."         ; Label?
                beq Vf2b        ; Yes
Vf3:            iny             ; Restore Y
                bne Vnxt2       ; Not label, continue
Vf2:                            ; Check for Exponent, 3E6 etc
                bcc Vf2b        ; If Y=3 then ok
                cpx#"E"
                bne Vf2b        ; Not E, ok
                jsr TypeX2      ; Rtn X=1 for numbers
                dex
                bne Vf2b        ; Not a number before the E
; This is an exponent, skip all following numbers
                iny             ; Offset to E
Ve:             iny             ; Next chr
                lda(Addr),y
                jsr TypeX2
                dex
                bne Ve          ; Still numeric
                jmp Vnxtchr2
Vf2b:           tya
                clc
                adc Addr
                sta$37          ; Point(37) to byte before name
                lda#0
                sta $39         ; Name len counter
                adc Addr+1
                sta$38
                iny             ; Restore offset to First chr
Vf4:            iny
                inc$39
                lda(Addr),y     ; Next chr of name?
                jsr TypeX2      ; X=0 if not letter or number
                bne Vf4         ; Still valid name
; Terminating chr found
                bit Firstletter ; FN or PROC?
                bmi Vf8         ; Yes, dont check %$(
                cmp#"%"         ; Integer?
                beq Vf5
                cmp#"$"         ; String?
                bne Vf6
Vf5:            inc$39
                iny             ; Include % or $ in name
                lda(Addr),y     ; Next chr
Vf6:            cmp#"("         ; Array?
                bne Vf7
                inc$39
                iny             ; Include ( in name
Vf7:                            ; Y now points to next chr not in name
                sty Startchr    ; Save Y
                jsr FINDVAR     ; Name already found?
                bne Allset      ; Yes
                jsr SETVAR      ; Set name on stack
                beq Vf88        ; Z=1
Vf8:            sty Startchr
                jsr FINDPROC
                bne Allset
                jsr SETPROC
Vf88:           jsr Vf9
                bcc Allset
                jsr Printmsg
                .text"No Room, do partial?"
                .byte 0
                jsr YesNo
                beq *+4         ; Yes
                pla
                pla             ; Drop Rtn address if No
                rts             ; Rtn from scanprgm early
Allset:         ldy Startchr
                jmp Vnxtchr2    ; Continue search
Vf9:            lda#0
                iny
                sta($2),y       ; Put zero terminator in
                tya
                sec
                adc$2
                sta$2           ; Update VARTOP by Y+1
                bcc *+4
                inc$3
                lda$3
                cmp RAMTOP
                bcc Vf9b        ; VARTOP < Video, ok
                lda#0           ; Stack clashing with screen
                ldy#1
                sta($3A),y      ; Block chain at previous point
Vf9b:           rts             ; C=1 if No room


                ; include_end: VARPACK
                ; include_start: FORMLIS


;  FORMLIS
;  ***********************************
Indent=$75
Forcount=$76
Repcount=$77
Flag=$78
;  **** FORMAT LISTING ****
exit:           jmp Choice
Format:         lda#0
                sta Forcount
                sta Repcount
                jsr StartB
                jsr Start
Line_0:         ldy#1
                lda(Addr),y
                ora$FF
                bmi exit        ; TOP or Escaped
                dey             ; =0
                sty Indent      ; Reset indents
                sty$4D          ; Reset quotes flag
                sty Flag        ; Set no tabs done yet
                jsr PrtLino     ; Printline#
                ldy#3
Nxtbyte:        iny
Byte_0:         lda(Addr),y
                cmp#$D          ; CR?
                bne Notcr
CR_1:           jsr OSASCI
                jsr Nextline
                jsr UpB
                bne Line_0
Notcr:          cmp#$22         ; Quote?
                bne Notquote_1
                lda#$FF
                eor$4D          ; Toggle flag
                sta$4D
                lda#$22
Lout_1:         jsr Printbyte
                bne Nxtbyte
Notquote_1:     bit$4D          ; Quotes open?
                bmi Lout_1      ; Yes
                cmp#$8D         ; Line# Mark?
                bne Notlino
                jsr LINBINY     ; Convert to binary in IAC
                jsr OUTIAC      ; Print IAC in 0 field
                ldy$A           ; Pickup offset
                bne Byte_0
Notlino:        cmp#":"
                bne Notcolon
                jsr Printbyte   ; Print the colon
                jsr Newline_1   ; Start newline
                bne Nxtbyte
Notcolon:       cmp#$E3         ; FOR ?
                bne Notfor
                jsr Current     ; Newline + Current Tabs
                inc Forcount
Notfor:         cmp#$F5         ; REPEAT?
                bne Notrep
                jsr Current     ; Newline + Current Tabs
                inc Repcount
Notrep:         cmp#$E7         ; IF ?
                bne Notif
                jsr Current     ; Newline + Current Tabs
                inc Indent
Notif:          cmp#$8C         ; THEN ?
                bne Nothen
                jsr Current     ; Newline + Current Tabs
                bne NL3_1
NL2_1:          jsr Newline_1

NL3_1:          bit Flag        ; Tabs done?
                bmi *+5         ; Yes
                jsr Tabin
                cmp#$80
                bcc NTok
                jsr DECRUNCH    ; Print token or byte
                jmp Ckspc
NTok:           jsr Printasci
                cmp#$40
                bcc Nxtbyte
Ckspc:          iny
                lda(Addr),y     ; Look at next byte
                bpl CK2         ; Not a Token
                jsr Space1      ; Force a space between adjacent tokens
CK2:            jmp Byte_0

Nothen:         cmp#$8B         ; ELSE ?
                bne Notelse
                dec Indent
                bpl NL2_1       ; Start newline back 1
                inc Indent      ; If gone -ve force 0
                bpl NL2_1
Notelse:        cmp#$FD         ; UNTIL ?
                bne Notuntil
                dec Repcount
                bpl NL2_1       ; Start newline back 1
                inc Repcount    ; If gone -ve force 0
                bpl NL2_1
Notuntil:       cmp#$ED         ; NEXT ?
                bne NL3_1       ; Not a formatting byte
                sty$A           ; Save offset
NX1_1:          dec Forcount
                bpl NX2
                inc Forcount    ; If gone -ve force 0
NX2:            iny
                lda(Addr),y     ; Look at next byte
                ldx#2
NX3:            cmp NX5,x       ; Check against list of terminators
                beq NX4
                cmp#","         ; Multiple Nexts ?
                beq NX1_1       ; Yes
                dex
                bpl NX3
                bmi NX2         ; Continue looking for terminator or ,
NX4:            ldy$A           ; Pickup offset
                lda#$ED         ; Next
                bne NL2_1       ; Start newline with new indents
NX5:            .byte ":"       ; List of bytes that can terminate NEXT string
                .byte 13        ; CR
                .byte$8B        ; ELSE
Newline_1:      bit Flag
                bpl D1_0        ; Dont throw another newline if nothing done since the last one
                pha
                jsr OSNEWL
                ldx#5           ; Length of line no.
NW1:            jsr Space1
                dex
                bne NW1
                stx Flag        ; 0= No tabs done yet AFTER CR
                pla
D1_0:           rts
Current:        jsr Newline_1
Tabin:          clc
                pha
                lda Indent
                adc Forcount
                adc Repcount
                asl a           ; *2
                tax
NW2:            jsr Space1
                dex
                bpl NW2         ; Print X+1 spaces
                pla
                dec Flag        ; -ve=tabs done this line
                rts
Printbyte:      bit Flag        ; Tabs done?
                bmi *+5         ; Yes
                jsr Tabin
                jmp Printasci


                ; include_end: FORMLIS
                ; include_start: UNPACK

;  **********************************
;  *                                *
;  * UNPACK, DECONCATENATES BASIC   *
;  *                                *
;  **********************************

Colon_count=$82
Extra=$83
Length_0=$84
Pass=$85
Concatflg=$86
Renmsg=$87
Quotes=$8B

Source_0=$A8                    ; Move pointers
Destin_0=$AA
Extent_0=$AC

UNCONCAT:
                ldx#0
                stx Renmsg
                dex             ; =FF
                stx Pass        ; FF=First
                stx Highlight
                stx Lineend     ; Set list options

PASS:           jsr Start       ; (Addr)=PAGE
                beq Line_1

Line_end:                       ; Leave line alone
                jsr Nextline

Line_1:         ldy#1
                sty Concatflg
                lda (Addr),y    ; Line# msb
                sta $2B
                sta $2D
                ora $FF         ; Escaped or TOP?
                bpl L2_1
                jmp K_0

L2_1:           iny
                lda (Addr),y    ; Line# lsb
                sta $2A
                sta $2C
                iny
                lda (Addr),y    ; Length
                sta Length_0
; CMP #7
; BCC Line_end
                lda #0
                sta Colon_count
Ldspc:          iny
                lda (Addr),y    ; First byte
                cmp#32          ; Ignore leading spaces
                beq Ldspc
                cmp #"*"        ; OS cmnd?
                beq Line_end
                cmp #$DC        ; DATA?
                beq Line_end
                ldy #3
                ldx #3

D:              lda #0
                sta Quotes

E:              iny
                inx
                beq Toolong_2
                lda (Addr),y
                sta $6FC,x      ; Build new line text
                cmp #$D         ; CR?
                beq CR_2
                bit Quotes
                bpl F_1         ; Not inside ""
                cmp#$22         ; Quote?
                bne E           ; Find closing quote or CR
                beq D

F_1:            cmp #$E7        ; IF?
                beq rest
                cmp #$F4        ; REM?
                beq rest
                cmp #$85        ; ERROR?
                bne Lineno
rest:           pha
                lda#$FF
                sta Concatflg   ; -ve=off
                pla

Lineno:         cmp #$8D        ; Line#?
                bne G_0
                lda #3
                sta Temp
Ln:             iny             ; Skip line#
                inx
                beq Toolong_2
                lda (Addr),y
                sta $6FC,x
                dec Temp
                bne Ln
                beq E

Toolong_2:      jmp Line_end    ; Cant expand line

G_0:            cmp #$22        ; Quote?
                bne H
                dec Quotes      ; -ve = on
                bne E

H:              cmp #":"        ; Colon?
                bne notcolon
                bit Concatflg
                bmi E           ; leave colons alone
                cpy #4          ; First byte of line?
                beq E
                inc Colon_count
                bit Pass
                bmi E           ; First pass
                lda #3          ; 4 extra bytes inc colon
Un:             jsr Unpack      ; Form new line
                jmp Line_1

CR_2:
                bit Pass
                bmi cr2         ; First pass -ve
                lda #0          ; No extra bytes needed
                beq Un          ; Deal with line on 2nd pass

cr2:            sty Temp
                jsr Nextline
                lda Colon_count
                beq J           ; No colons
                ldy Temp
                cpy #7
                bcc J           ; Only 1 or 2 bytes on line
                jsr Check_room
J:              jmp Line_1      ; Next line

notcolon:       stx Temp
                cmp #"0"
                bcc nospace
                cmp #$3A
                bcc spc
                cmp #"@"
                bcc nospace

Ig:             ldx #6
Ign:            cmp Ignore,x    ; Check token(
                beq nospace
                dex
                bpl Ign

spc:            iny
                lda (Addr),y    ; Next byte
                bpl nospc       ; Not Token
                lda #32
                inc Temp
                ldx Temp
                beq Toolong_2
                sta $6FC,x      ; Insert space
nospc:          dey
nospace:        ldx Temp
                jmp E

Ignore:
                .byte $A7       ; INSTR(
                .byte $C0       ; LEFT$(
                .byte $C1       ; MID$(
                .byte $B0       ; POINT(
                .byte $C2       ; RIGHT$(
                .byte $C4       ; STRING$(
                .byte $8A       ; TAB(

K_0:            bit $FF
                bmi M_0         ; Escaped
                bit Renmsg
                bmi M_0         ; Set, cant unpack
                inc Pass
                bne M_0         ; Alldone
                jmp PASS        ;  2nd pass

M_0:            jsr OSNEWL
                jsr Update_Basic
                jmp Choice      ; Alldone

;  **********************************

Check_room:
                ldy #1
                lda (Addr),y    ; Next line# msb
                bmi Ok          ; TOP, no problem
                lda $2A
                clc
                adc Colon_count
                tax
                lda $2B
                adc #0
                cmp (Addr),y    ; Nextline# msb
                bcc Ok
                txa             ; lsb of required line#
                iny
                cmp (Addr),y
                bcs Cant        ; No room to expand

Ok:             lda $2B
                cmp#$7F         ; Max line# yet?
                bne Rtn_1
                lda $2A
                cmp #$FF
                bne Rtn_1       ; All ok

Cant:           bit Renmsg
                bmi prntd       ; Mssg already printed
                dec Renmsg
                jsr Printmsg
                .byte 13
                .text " Renumber line(s):"
                .byte 13
                .byte 0

prntd:          lda #8          ; Field width 8
                jsr IACOUTA     ; Print line# in 2A/B
Rtn_1:          rts

;  **********************************

Unpack:
; Make a new line and line#
; Text at 700..
; X=line length inc overheads
;  & spaces

                sta Extra

                sty Temp
                lda #13
                sta $6FC,x      ; Insert CR
                ldy #3
                txa
                sta (Addr),y    ; New length

                tya             ; Set up move pointers
                sec             ; +1 to skip colon
                adc Addr
                sta Source_0
                lda Addr+1
                adc #0
                sta Source_0+1

                txa
                sec
                sbc Temp        ; =Y
                clc
                adc Extra       ; 0 or 4
                tax             ; Extra bytes in line

                clc
                adc Source_0
                sta Destin_0
                lda Source_0+1
                adc #0
                sta Destin_0+1

                lda $12         ; TOP
                sec
                sbc Source_0
                sta Extent_0
                lda $13         ; TOP msb
                sbc Source_0+1
                sta Extent_0+1

                txa
                clc
                adc $12         ; TOP lsb
                tay
                lda $13         ; TOP msb
                adc #0
                cmp RAMTOP      ; Bottom of Screen ?
                bcc U2_0
                jmp Noroom

U2_0:           sta $13         ; New TOP msb
                sty $12         ; lsb

                jsr Blockmove   ; Move rest of prog up

                ldy #4
                ldx #4
Newl:           lda $6FC,x
                sta (Addr),y    ; Insert expanded line
                iny
                inx
                cmp #13
                bne Newl

                jsr Listline
; JSR Iachi_lo \Restore Line#
                jsr Nextline    ; (Addr) now = new CR

; Update line# of rest of line
                lda Extra
                beq oldline     ; No new line# rqd

                lda Length_0    ; of original line
                sec
                sbc Temp        ; Bytes in new fragment
                clc
                adc #3          ; Extra overheads
                ldy #3
                sta (Addr),y    ; remaining length
                dey             ; =2
                lda $2C         ; Line# lsb
                clc
                adc #1
                sta (Addr),y
                dey             ; =1
                lda $2D
                adc #0
                sta (Addr),y    ; Line# Msb

oldline:        rts

Noroom:         jsr Printmsg
                .byte 13
                .byte 13
                .byte 7
                .text "No room"
                .byte 0
                jmp M_0         ; Quit

Update_Basic:                   ; UPDATE TOP,LOMEM,VARTOP
                jsr Start
UB1:            ldy#1
                lda (Addr),y
                bmi UB2         ; TOP
                jsr Nextline
                jmp UB1
UB2:            lda Addr
                clc
                adc#2
                sta $12         ; TOP
                sta $00         ; LOMEM
                sta $02         ; VARTOP
                lda Addr+1
                adc#0
                sta $13
                sta $01
                sta $03
                rts


                ; include_end: UNPACK

                ; include_start: ROMID
                .if include_ROMID


;  ****************************************************
;  *            ROMID reader/copier                   *
;  *            V5 18/9/84 IJW                        *
;  *            Syntax- *ROMID page addr              *
;  ****************************************************

Null=$90
Rom_0=$91
Entry=$92
RomOffset=$93
WORK3=$900
STACK=$7C0

ROMID:
                jsr OSNEWL
                lda #170
                ldx #0
                ldy #$FF
                jsr OSBYTE      ; Get addr of Rom table
                stx $F8
                sty $F9

; Check if page#/address given
                pla
                pha
                tay             ; Oscli offset
                jsr Nextoscl
                beq idroms      ; CR only

                jsr HEXBIN      ; Convert page#
                beq done_1      ; CR no address
                bcc done_1      ; Illegal hex
                ldx $AE         ; Result
                cpx #$10
                bcs done_1      ; Illegal page#>15
                stx Rom_0

                cmp #"O"        ; Check ON/OFF
                bne RomAddr
                jsr Skposcl
                cmp #"N"
                beq Rom_on
                lda #0          ; 0=off
                beq Set_table

Rom_on:         lda#6
                sta $F6
                lda #$80
                sta $F7
                ldy Rom_0
                jsr $FFB9       ; Get Rom type

Set_table:
                ldy Rom_0
                sta ($F8),y     ; Set Rom type in table

idroms:         jsr romid
done_1:         jmp Alldone


RomAddr:        jsr HEXBIN      ; Convert address
                bcc idroms      ; Illegal address
                lda $AF         ; Addr MSB
                cmp #$E
                bcc idroms      ; If address<E00 illegal
                sta $AB
                lda $AE
                sta $AA         ; Save address
                lda #0
                sta $F6
                lda #$80
                sta Null
                sta $F7         ; Set (F6) to &8000

move:           ldy Rom_0
                jsr $FFB9       ; Get (F6) of rom Y
                cmp ($F6),y     ; =this rom?
                beq m2
                sty Null        ; Y=0, clear if any bytes<>
m2:             sta ($AE),y     ; Y=0
                inc $AE
                bne *+4
                inc $AF
                inc $F6
                bne move
                ldy Null        ; if<>0 first 256 bytes
                bne loaded      ; =this rom!
                inc $F7
                lda $F7
                cmp #$C0
                bcc move

loaded:
                jsr Printmsg
                .byte 13
                .text " *SAVE "
                .byte 0
                ldy #9
name:           lda ($AA),y     ; Rom name
                bmi save
                cmp #33         ; No spaces or ctrl chrs
                bcc save
                jsr OSWRCH
                iny
                cpy #$10
                bcc name

save:           jsr Space1
                lda $AB
                jsr Hex_asci    ; Print save addr in hex
                lda $AA
                jsr Hex_asci
                jsr Printmsg
                .text " +"
                .byte 0

; Check if 8 or 16K image
                lda $AA
                sta $AE
                lda $AB
                clc
                adc #$20        ; Add 8K
                sta $AF
                ldy #0
Find:           lda ($AA),y
                cmp($AE),y
                bne K16
                iny
                bne Find        ; Check first 256
K8:             lda #"2"
                bne K_1
K16:            lda #"4"
K_1:            jsr OSWRCH
                jsr Printmsg
                .text "000 "
                .byte 0

                lda $FFFD
                jsr Hex_asci
                lda $FFFC       ; Print reset address
                jsr Hex_asci
                jsr Printmsg    ; Reload address
                .text " 8000"
                .byte 13
                .byte 0
                jmp Alldone

;  *******************************

romid:          lda #15
                sta Rom_0

Nextrom:        lda Rom_0
                tay
                jsr Nybble      ; Print Rom page
                ldx #"-"
                lda ($F8),y     ; Rom type
                bne valid
                ldx #$20        ; Space if ROM not on
valid:          txa
                jsr OSWRCH
                lda #$80
                sta $F7         ; (F6)points to (C) offset
                jsr Checkrom
                bne NOROM       ; Not valid image
                jsr Print_Rom_Id

NOROM:          jsr Curpos
                beq NOROM2
                jsr OSNEWL

NOROM2:         dec Rom_0
                bpl Nextrom     ; Do roms 15-0
                rts

;  **********************************

Checkrom:       lda #7
                sta $F6
                jsr Getbyte     ; Get byte (F6) of Rom Y
                sta $F6         ; (F6) now points to 0(C)
; Check if rom exists/valid
                ldx #4
Chk:            stx Null
                jsr Getbyte
                ldx Null
                cmp Copy_1-1,x
                bne Notrom
                inc $F6
                dex
                bne Chk         ; Check 4 bytes
Notrom:         rts             ; Z=1 if good rom
Copy_1:         .text ")C("
                .byte 0

;  *******************************

Print_Rom_Id:   lda #8
                sta $F6         ; Point to Version#
                jsr Getbyte
                jsr Hex_asci    ; Print version#
                jsr Space1
                ldy #3
                sty Null        ; Allow 3 nulls in name
Get_2:          inc $F6
                jsr Curpos
                beq PRI2        ; End of line
                jsr Getbyte
                cmp #127
                bcs Skip_1
                cmp #32
                bcc Skip_1
                jsr OSWRCH
Skip_1:         cmp #0
                bne Get_2
                jsr Space1
                dec Null
                bne Get_2
PRI2:           rts

Curpos:         lda #134
                jsr OSBYTE      ; Read cursor XY
                cpx #0
                rts

Getbyte:        ldy Rom_0
                bmi Ram         ; Only 0-F are Rom#'s
                jmp $FFB9       ; Get byte (F6) of Rom Y
Ram:            ldy #0
                lda ($F6),y
                rts


                .endif
                ; include_end: ROMID
                
                ; include_start: MOVE

P_0=$A8                         ; Page 0 use..

Source_1=P_0
Destin_1=P_0+2
Extent_1=P_0+4



;  *******************************
;  * MOVE Routine for 16K Rom IV *
;  * Syntax-                     *
;  * MOVE <page> for BASIC only  *
;  * MOVE<destin><source><finish>*
;  * or                          *
;  * MOVE<destin><source><+extnt>*
;  *******************************

MOVECMND:
; Set defaults to move BASIC from PAGE to E00
                lda $18         ; PAGE
                sta Source_1+1
                lda #$E
                sta Destin_1+1
                lda $13         ; TOP MSB
                sec
                sbc $18         ; TOP-PAGE
                sta Extent_1+1
                lda $12         ; TOP LSB
                sta Extent_1
                lda #0
                sta Source_1
                sta Destin_1
                jsr Nextoscl
                beq Move4       ; CR, no addr given, use defaults
                jsr HEXBIN      ; Get destination address
                bcs Aok

Badaddr:        jsr Errorexit
                .byte 28        ; Err#, Bad hex
                .text "Bad Address"
                .byte 0

Aok:            php
                lda $AF
                sta Destin_1+1
                lda $AE         ; LSB, for basic leave =0
                plp
                beq Move4       ; CR, no source addr given, Move basic
                sta Destin_1
                jsr HEXBIN      ; Get source address
                bcc Badaddr
                beq Badaddr     ; Extent must be given
                pha
                lda $AF
                sta Source_1+1
                lda $AE
                sta Source_1
                pla
                cmp #"+"        ; Extent or addr?
                php
                bne L1_1
                jsr Skposcl     ; Move past +

L1_1:           jsr HEXBIN      ; Get ext addr
                bcc Badaddr
                ldx $AE
                lda $AF         ; Result
                plp
                beq Ext         ; +
; Finish addr given, calculate extent
                sec
                txa
                sbc Source_1
                tax
                lda $AF
                sbc Source_1+1

Ext:            sta Extent_1+1  ; MSB
                stx Extent_1    ; LSB
                jmp Move5

Move4:                          ; Basic move
; Check new TOP < HIMEM and Update BASIC pointers
                jsr CheckBASIC  ; No return if not BASIC
                lda Destin_1+1
                clc
                adc Extent_1+1
                cmp $7          ; HIMEM MSB
                bcs Badaddr
                lda Source_1+1
                sec
                sbc Destin_1+1
; Move up =-ve, Down =+ve
                tax

Reset_1:        dec $13         ; TOP
                dec $01         ; LOMEM
                dec $18         ; PAGE
                dex
                bne Reset_1

Move5:          jsr Blockmove
                jmp Alldone

; **********************************

Blockmove:
                ldy #0          ; Zero index
                ldx Extent_1
                sec             ; Test direction of move
                lda Source_1
                sbc Destin_1
                sta $AF
                lda Source_1+1
                sbc Destin_1+1
                ora $AF
                beq BRET        ; No move, SILLY!
                bcc Up          ; C=0, Dest>Source

Down:                           ; Start at bottom and work up
                inc Extent_1+1  ; Dummy for later DEC
                txa             ; Partial block?
                beq D2          ; No partial
Loop1:          lda (Source_1),y; Move byte
                sta (Destin_1),y
                iny
                bne D1_1
                inc Source_1+1
                inc Destin_1+1
D1_1:           dex
                bne Loop1
D2:             dec Extent_1+1
                bne Loop1

BRET:           rts             ; All moved

Up:                             ; Start at last byte and work down
                txa             ; LSB of extent
                adc Source_1    ; C=0
                sta Source_1
                lda Extent_1+1
                adc Source_1+1
                sta Source_1+1  ; Change S&D to point to last byte-255
                dec Source_1+1
                txa
                clc
                adc Destin_1
                sta Destin_1
                lda Extent_1+1
                adc Destin_1+1
                sta Destin_1+1
                dec Destin_1+1
                dey             ; =255
                inc Extent_1+1  ; Dummy for later DEC
                txa             ; Partial block ?
                beq U2_1        ; No
Loop2:          lda (Source_1),y; Move byte
                sta (Destin_1),y
                tya
                bne U1          ; Not 0 yet
                dec Source_1+1
                dec Destin_1+1
U1:             dey
                dex
                bne Loop2
U2_1:           dec Extent_1+1
                bne Loop2
                rts


                ; include_end: MOVE
                ; include_start: SPACE



;  ***********************
;  * BASIC SPACE display *
;  * Version 0.0 6/84    *
;  ***********************

SPACE:

                ldx #$FF
L0:             jsr OSNEWL
                ldy #7          ; Length of messg
Loop_1:         inx
                lda Mess,x
                beq L1_2
                jsr OSWRCH
                dey
                bne Loop_1
L1_2:
L2_2:           jsr Space1      ; Pad with spaces
                dey
                bne L2_2

                jsr Printmsg
                .text "= &"
                .byte 0
                inx             ; Point to byte after 0
                ldy Mess,x      ; Get address of value
                bmi L4_0        ; End of Messg
                lda $1,y        ; MSB of Value
                jsr Hex_asci
                lda $0,y        ; LSB of Value
                jsr Hex_asci
                bne L0
L4_0:           lda $18         ; PAGE msb
                jsr Hex_asci
                lda #0
                jsr Hex_asci

                jsr Printmsg
                .byte 13
                .byte 13
                .text "Program = "
                .byte 0
                lda $13         ; TOP msb
                sec
                sbc $18         ; PAGE msb
                sta $2B
                lda $12         ; TOP lsb
                sta $2A
                jsr OUTIAC      ; Print prog size
                jsr Printmsg
                .text " bytes, ("
                .byte 0

                lda $18
                sta $A9
                lda #0
                sta $A8
                sta $2A
                sta $2B
L9:             ldy #1
                lda ($A8),y
                bmi Top
                inc $2A
                bne L10
                inc $2B
L10:            ldy #3
                lda ($A8),y
                clc
                adc $A8
                sta $A8
                bcc L9
                inc $A9
                bcs L9
Top:            jsr OUTIAC
                jsr Printmsg
                .text " lines)"
                .byte 13
                .byte 13

                .text "Bytes free = "
                .byte 0
                lda $6          ; HIMEM lsb
                sec
                sbc $2          ; Vartop lsb
                sta $2A
                lda $7          ; HIMEM msb
                sbc $3          ; Vartop msb
                sta $2B
                jsr OUTIAC      ; Print bytes free
                jsr OSNEWL
                jmp Alldone

Mess:           .text "HIMEM"
                .word $0600     ; Addr of HIMEM
                .text "VARTOP"
                .word $0200
                .text "LOMEM"
                .word 0
                .text "TOP"
                .word $1200
                .text "PAGE"
                .word $FF00     ; End marker


                ; include_end: SPACE
                ; include_start: VARCAT


;  ************************
;  * VARCAT EPROM VERSION *
;  * 6/86     IJW         *
;  * ANY BASIC VERSION    *
;  * OPTIONS =H%$(PFR     *
;  ************************

G_1=$70                         ; Page 0 use..
T0=G_1
T1_1=G_1+1
T2_1=G_1+2
T3=G_1+3
T4=G_1+4
T6=G_1+5
T7=G_1+6

Pad=G_1+7
Hexopt=G_1+8
Intopt=G_1+9
Stropt=G_1+10
Aryopt=G_1+11
Procopt=G_1+12
FNopt=G_1+13
Realopt=G_1+14

Trap=G_1+15                     ; BYTE
Return=G_1+16                   ; WORD
Oldvec=G_1+18                   ; WORD

; ******************************************

VARCAT:
                jsr Nextoscl
                cmp #"x"
                bne normal
                jmp Continue_1  ; Re-entry

normal:
                tya
                pha             ; Save oscli ptr
                jsr CheckBASIC  ; No return if not BASIC 
                lda #$A8
                ldx #0
                ldy #$FF
                jsr OSBYTE      ; Get Extended vector base
                stx T0
                sty T1_1
                ldy #21         ; Offset to OSWRCH
                lda #HERE % 256
                sta (T0),y      ; Set extended OSWRCH vector
                iny
                lda #HERE /256
                sta (T0),y
                iny
                lda $F4         ; This ROM no.
                sta (T0),y
                lda $20E
                sta Oldvec
                lda $20F
                sta Oldvec+1    ; Save current OSWRCH vector

                ldy #48         ; Offset for eventV
                lda #Event % 256
                sta (T0),y      ; Set extended EVENT vector
                iny
                lda #Event /256
                sta (T0),y
                iny
                lda $F4
                sta (T0),y
                lda #$30
                sta $220
                lda #$FF
                sta $221        ; Point EVENTV to extended handler at FF30
                lda #14
                ldx #6
                jsr OSBYTE      ; Enable Event 6, Escape pressed
                pla
                tay             ; Oscli offset

                lda #32
                sta Pad         ; Default space
                sta Hexopt      ; Hex off
                lda #0
                jsr Set         ; Set all options on +ve

Optb:           jsr Nextoscl
                beq do_it       ; CR, do all
                cmp #"H"        ; Hex?
                bne Opta
                sta Hexopt
                iny
                bne Optb

Opta:           lda #$80
                jsr Set         ; Set all options off -ve
                dey             ; Dummy to allow for first INY

Options:        jsr Skposcl
                beq do_it       ; CR found
                ldx #7
Opt2:           cmp Table_1,x
                bne Opt3
                sta Pad,x       ; Set option ON, +ve
Opt3:           dex
                bpl Opt2
                bmi Options

do_it:          lda #"@"
                sta T0          ; Start chr
                asl Hexopt      ; Hex option, Make "H"(&48) go -ve, &80 go +ve, &20 +ve
                bit Intopt      ; Test % option
                bmi DYNAMIC     ; Off

STATIC:
                jsr SetPrint
                lda T0
                jsr OSWRCH      ; @..Z
                tay
                lda #138
                ldx #0
                jsr OSBYTE      ; Insert in Key buff
                lda #"%"
                jsr OSWRCH
                tay
                lda #138
                jsr OSBYTE      ; X=0 still
                lda Pad         ; =
                jsr OSWRCH
                jsr Ampsnd      ; Check if & needed
                jsr NTOASCI     ; Get BASIC to print value

Stat:
                inc T0          ; Next chr @..Z
                lda #91
                cmp T0
                bne STATIC

DYNAMIC:        lda #"@"
                sta T0

Next_1:         inc T0          ; Next chr A..z
                lda T0
                cmp #123
                bne Nx2
                jmp ProcFn
Nx2:            asl a
                tay
                lda $400,y
                tax
                iny
                lda $400,y
NextQ:          beq Next_1

OK:             stx T1_1
                sta T2_1        ; (T1)=Addr of Variable
                ldy #1
What:           iny
                tax             ; Save last chr
                lda (T1_1),y
                bne What        ; Find 0 terminator of name
                cpy #2
                beq real_1      ; Single chr name
                txa
                ldx #3
What2:          cmp Table_1+1,x ; Check %$(
                beq found0
                dex
                bne What2

real_1:         ldx #6
found0:         lda Pad+1,x     ; Test option
                bmi NWM         ; Off

Showit:
                jsr SetPrint    ; P.~
                lda T0
                jsr NAME        ; print Name and insert in key buff
                dey
                cpy #1
                beq Single
                lda (T1_1),y
                cmp #"("
                beq ARRAY

Single:         pha
                lda Pad         ; = or space
                jsr OSWRCH
                pla
                cmp #"$"
                beq String
                jsr Ampsnd      ; Check if & needed

Integer:
                cpy #23         ; Y=length of name, max in keybuffer is 22, (=32-10 for P.~/*VL.//)
                bcc LenOk
                jsr SetPrint    ; Flush kbd, Reinsert P.

LenOk:          jsr NTOASCI     ; BASIC prints value

NWM:
                ldy #0
                lda ( T1_1),y
                tax
                iny
                lda ( T1_1),y
                bne OK
                jmp NextQ

String:         lda #34
                jsr OSWRCH      ; Opening Quote
                iny             ; inc past terminating 0
                iny
                lda (T1_1),y
                sta T3          ; Address of $ from sib
                iny
                lda (T1_1),y
                sta T4
                iny
                iny
                lda (T1_1),y    ; length of $
                tax
                beq empty
                ldy #0

Str2:           lda (T3),y      ; Print string contents
                jsr OSWRCH
                iny
                dex
                bne Str2

empty:          lda #$22
Str3:           jsr OSWRCH      ; Closing quote
                jsr OSNEWL
                lda #21
                ldx #0
                jsr OSBYTE      ; flush key buff
                jmp NWM

ARRAY:          iny
                iny
                lda (T1_1),y
                cld
                sec
                sbc #1
                clc
                ror a
                sta T6
Dims:           iny
                lda (T1_1),y
                sta $2A
                iny
                lda (T1_1),y
                sta $2B
                dec $2A
                bcc *+4
                dec $2B
                tya
                pha
                jsr OUTIAC
                dec T6
                beq Last_1
                lda #","
                jsr OSWRCH
                pla
                tay
                bne Dims
Last_1:         pla
                lda #")"
                bne Str3

ProcFn:         bit Pad+5       ; Test option
                bmi Again       ; Off, No PROCs
                lda #$F6        ; Cat' offset
                ldx #$F2        ; PROC token
P_1:            sta T1_1
                stx T0
                lda #4
                sta T2_1
                bne R

K_2:            lda T0
                jsr DECRUNCH    ; DECRUNCH TOKEN
                lda #32         ; Space
                jsr NAME
N_1:            lda #32
                jsr OSWRCH
                iny
                lda (T1_1),y
                sta T3
                iny
                lda (T1_1),y
                sta T4
                dec T4
                ldy #0

; Get Xeqn Addr
search:         dey
                lda (T3),y
                cmp #13
                bne search
; Find prev' CR
                tya
                pha
                ldx #3
Check_1:        dey
                lda (T3),y
                cmp #13
                bne none
; Check its not a line len or line#
                pla
                tya
                pha
none:           dex
                bne Check_1
                pla
                tay
                iny
                lda (T3),y
                sta $2B
; Line#Hi
                iny
                lda (T3),y
                sta $2A
; Line#lo
                jsr OUTIAC      ; PRINTline#in dec.
                jsr OSNEWL

R:              ldy #0
                lda (T1_1),y
                tax
                iny
                lda (T1_1),y
                sta T2_1
                stx T1_1
                bne K_2

Again:          bit Pad+6
                bmi Done        ; No FNs
                lda #$F8
                ldx #$A4        ; FN token
                cpx T0
                bne P_1
Done:           jmp VExit       ; Finished

; ****************************************************

NAME:                           ; Print name and insert in keybuff, A=first chr 
                ldy #1
M_1:            jsr OSWRCH
                tax             ; SAve chr
                tya
                pha             ; Save index
                txa
                tay             ; Chr in Y
                ldx #0
                lda #138
                jsr OSBYTE      ; Insert in key buff
                pla
                tay             ; Index
                iny
                lda (T1_1),y
                bne M_1
LAST:           rts

; ****************************************************

Set:                            ; Set all option switches to A
                ldx #7
Set2:           sta Pad+1,x
                dex
                bne Set2        ; leave Pad and Hex alone
                rts

Ampsnd:         lda Pad
                and Hexopt      ; Hex option
                beq Amp2
                lda #"&"        ; If Hex and pad= add &
                jsr OSWRCH
Amp2:           rts

Table_1:        .text "=H%$(PFR"

; *******************************************          

SetPrint:                       ; Insert P. in key buff..
                lda #21
                ldx #0
                jsr OSBYTE      ; flush kbd
                lda #138
                ldy #"P"
                ldx #0
                jsr OSBYTE
                ldy #"."
                jsr OSBYTE
                bit Hexopt
                bpl SP2
                ldy #"~"
                jsr OSBYTE
SP2:            rts

; ******************************************

NTEXT:
                .byte 13        ; CR
                .text "*VL."    ; Command to get back
                .byte "x"       ; parameter - reentry
                .byte 13        ; CR
                .byte 0

; *******************************************
;  BASIC is used to print value by inserting 
;  'P.name' in keybuffer, followed by command
;  to get back to VLIST.
; ********************************************
NTOASCI:
                ldx #0
NT1:            ldy NTEXT,x
                beq NT2
                txa
                pha
                lda #138
                ldx #0
                jsr OSBYTE      ; Insert ;<CR> *VL.X <CR>
                pla
                tax
                inx
                bne NT1

NT2:
                pla
                sta Return
                pla
                sta Return+1    ; Save callers address
                lda #0
                sta Trap        ; Set +ve off
                lda #$15
                sta $20E
                lda #$FF
                sta $20F        ; Point OSWRCH to Extended vector handler at FF15
                jmp Alldone     ; Return to BASIC, which will print Value?!

Continue_1:                     ; Get back here after printing value
                lda Oldvec
                sta $20E        ; Restore OSWRCHV
                lda Oldvec+1
                sta $20F
                bit $FF         ; Escaped?
                bmi VExit
                lda Return+1
                pha             ; Restore callers address
                lda Return
                pha
                rts

VExit:
                lda #13
                ldx #6
                ldy #0
                jsr OSBYTE      ; Disable Escape event
                ldx #0
                lda #21
                jsr OSBYTE      ; Flush key buff 
                jmp Alldone

; ****************************
;  OSWRCH HANDLER
; ****************************
HERE:                           ; OSWRCH gets here 
                bit Trap
                bmi Trap2       ; On
                cmp #13
                bne Trap1       ; Not CR
                dec Trap        ; set trap -ve
Trap1:          rts             ; Sink first and last lines, (trap +ve)

Trap2:          jsr Oldoswrch
                cmp #13         ; CR?
                bne Trap3
                inc Trap        ; +ve,end of line we want to show
Trap3:          rts

Oldoswrch:      jmp(Oldvec)

; *******************************
;  ESCAPE EVENT HANDLER
; *******************************
Event:
                pha
                tya
                pha
                txa
                pha
                lda #13
                ldx #6
                ldy #0
                jsr OSBYTE      ; Disable event 6
                lda Oldvec
                sta $20E        ; Restore OSWRCH
                lda Oldvec+1
                sta $20F
                lda #125
                jsr OSBYTE      ; Set escape
                pla
                tax
                pla
                tay
                pla
not6:           rts


                ; include_end: VARCAT
                ; include_start: BLIST


Quote=$AD
Channel=$AC
Length_1=$AB

;  ***********************
;  * BLIST for ROM       *
;  * LISTS BASIC FILES   *
;  * DIRECT FROM STORE   *
;  * *BLIST <fsp>        *
;  ***********************

BLIST:
                tya
                clc
                adc $F2
                tax             ; lsb of fsp address
                ldy $F3
                bcc A1_0
                iny
A1_0:           lda #$40
                jsr OSFIND      ; OPENIN
                tay             ; Channel#
                bne Open

                jsr Errorexit
                .byte $D6
                .text "File not found"
                brk

Open:           sta Channel
                jsr Byte_1
CR1_1:          cmp #$D
                bne Bad
CR_3:           jsr OSASCI
                jsr Byte_1
                tay
                bmi done_2      ; Line#msb -ve =TOP
                sta $AF
                sta Quote       ; Reset off, +ve
                jsr Byte_1
                sta $AE
                jsr LINIAC2     ; Print AE/F in 5 field
                jsr Space1
                jsr Byte_1      ; Line length
                sbc #2          ; C=0
                sta Length_1
Next_2:         jsr Byte_1
                beq CR1_1       ; Length=0
                cmp #$22        ; Quote?
                bne La_1
                lda #$FF
                eor Quote
                sta Quote
                lda #$22

Lout_2:         jsr Printasci   ; Ctrls=|
                jmp Next_2
La_1:           bit Quote
                bmi Lout_2      ; Within quotes
                cmp #$8D        ; Line#?
                beq Line_no
                tax
                bpl Lout_2      ; Not token
                jsr DECRUNCH
                jmp Next_2
Byte_1:         bit $FF
                bmi Out_1
                ldy Channel
                jsr OSBGET
                bcs Out2        ; EOF
                dec Length_1
                rts
Out_1:          lda #126
                jsr OSBYTE      ; Ack escape
Out2:           pla
                pla             ; Drop rtn address
done_2:         ldy Channel
                lda #0
                jsr OSFIND
                jsr OSNEWL
                jmp Alldone

Bad:            jsr Errorexit
                .byte 214
                .text "Bad program"
                brk

Line_no:        jsr Byte_1
                asl a
                asl a
                sta $AF
                and #$C0
                sta $AE
                jsr Byte_1
                eor $AE
                sta $AE
                lda $AF
                asl a
                asl a
                sta $AF
                jsr Byte_1
                eor $AF
                sta $AF
                jsr OUTIAC2
                jmp Next_2


                ; include_end: BLIST
                ; include_start: FKEYS

;  *********************************
;  * Function Keys Lister          *
;  * Modded 7/86 for MASTER SERIES *
;  *********************************

FKEYS:
                jsr Nextoscl
                beq All         ; CR, show all keys
                ldx #$AD        ; Result address
                jsr DECBIN
                bcs Keyok

Badkey:         jsr Errorexit
                .byte 251
                .text "Bad key"
                .byte 0

Keyok:          ldx $AD
                cpx #16
                bcs Badkey
                lda $AE
                bne Badkey      ; MSB must=0
                jsr Keyout
done_3:         jmp Alldone

All:            ldx #0
A1_1:           stx $AD
                jsr Keyout
                ldx $AD
                inx
                cpx #16
                bcc A1_1

;  Print out Key status

                jsr Printmsg
                .byte 13
                .text "f:"
                .byte 0
                lda #225
                jsr Ftype       ; Get Normal fcn key status

                jsr Printmsg
                .text "Sf:"
                .byte 0
                lda #226
                jsr Ftype       ; Get Shifted Fkeys

                jsr Printmsg
                .text "Cf:"
                .byte 0
                lda #227
                jsr Ftype       ; Get Ctrl Fkeys

                jsr Printmsg
                .text "SCf:"
                .byte 0
                lda #228
                jsr Ftype       ; Get Shifted/Ctrl Fkeys
                jsr OSNEWL
                jmp Alldone

Ftype:          ldx #0
                ldy #$FF
                jsr OSBYTE
                jsr FT0

Tab_1:          lda #134
                jsr OSBYTE      ; Get POS
                sec
                txa
t1:             sbc #10         ; Tab to next of 10,20,30..
                bcs t1
                tax
t2:             jsr Space1
                inx
                bne t2
                rts
FT0:            txa             ; X=result
                bne FT1

Off:            jsr Printmsg
                .text "off"
                .byte 0
                rts

FT1:            cpx #1
                bne Asci
User:           jsr Printmsg
                .text "user"
                .byte 0
                rts

Asci:           lda #"&"
                jsr OSWRCH
                txa
                jmp Hex_asci

Keyout:         jsr Printmsg
                .text "*KEY "
                .byte 0
                lda $AD
                sta $AE
                lda #0
                sta $AF
                jsr OUTIAC2     ; Print key#in decimal
                jsr Space1

NotMaster:
                ldx $AD         ; Print Key def for No in AD
                lda $B00,x      ; Start offset
                sta $AE
                lda #$FF
                sta $AF         ; Set max finish offset
                ldx #15         ; Find the next lowest start offset as this will be finish for this key
L1_3:           cpx $AD
                beq L2_3        ; Dont compare with self
                lda $B00,x
                cmp $AE
                bcc L2_3        ; Less than start
                cmp $AF
                bcs L2_3        ; Not the lowest
                sta $AF
L2_3:           dex
                bpl L1_3
                ldy $AE
                cpy $AF
                beq Nokey
L3_0:           lda $B01,y
                bpl L4_1
                pha
                lda #"|"
                jsr OSWRCH
                lda #"!"
                jsr OSWRCH
                pla
                and #$7F

L4_1:           cmp #32
                bcc L4b
                cmp #$7F        ; =|?
                beq L4b
                cmp #$22        ; Quote
                beq L4a         ; =|"
                cmp #$7C        ; bar=||
                bne L5          ; Normal ascii

L4a:            eor #$40
L4b:            pha
                lda #"|"
                jsr OSWRCH
                pla
                eor #$40
L5:             jsr OSWRCH
                iny
                cpy $AF
                bcc L3_0
Nokey:          jmp OSNEWL


                ; include_end: FKEYS
                ; include_start: MEMEDIT
                .if include_MEMEDIT


;  ********************************
;  * MEMORY EDITOR
;  * for ELECTRON
;  ********************************
P_2=$80

Sptr=P_2
Saddr=P_2+2
MEStart=P_2+4
MEFinish=P_2+6
Width=P_2+8
Char=P_2+9
Shift=P_2+10
Ctrl=P_2+11
Writeflag=P_2+12
RTemp=P_2+13
Maxtrack=P_2+14
MELines=P_2+15
Wtop=P_2+16
MEPtr=P_2+17
MEAddr=P_2+19
MEOffset=P_2+21
Side=P_2+22
Maxsector=P_2+23

Rom_1=P_2+24

;  ******************************

MEMEDIT:
                tya             ; Save oscli ptr
                pha
                lda #252        ; Set default parameters..
                ldx #0
                ldy #$FF
                jsr OSBYTE      ; Read lang rom no
                stx Rom_1
                lda #131
                jsr OSBYTE      ; Read OSHWM in XY
                stx Sptr
                sty Sptr+1      ; Set default address
                stx Saddr
                sty Saddr+1
                pla
                tay

                jsr Nextoscl
                beq ME2         ; CR, no parameters
                jsr HEXBIN
                bcc ME3         ; bad Hex
                ldx $AE         ; LSB
                stx Sptr
                stx Saddr
                ldx $AF         ; MSB
                stx Sptr+1      ; Set users address
                stx Saddr+1

ME3:            cmp#"@"         ; ROM #?
                bne ME2
                iny
                jsr HEXBIN
                bcc ME2         ; Bad hex
                lda $AE
                sta Rom_1       ; Set user Rom#

ME2:
                ldx #0
                stx MEStart
                stx MEStart+1
                dex             ; =FF
                stx MEFinish
                stx MEFinish+1
                stx Wtop        ; Silly number, no window
                lda #25
                sta MELines
                jsr Modes
; No Headings
                jsr Editor
                jmp E3

Medit:          lda #15
                tax
                jsr OSBYTE      ; Flush ip buffers
                jsr Wait

E3:             bit $FF
                bmi MEdone      ; Escaped
                ldx Ctrl
                bmi Medit       ; Ignore ctrls

MEdone:
                jsr Curnorm
                ldx #0
                lda #4
                jsr OSBYTE      ; Restore cursor keys
                ldx #0
                ldy #24
                jsr Tab
                jsr OSNEWL
                jmp Alldone

;  *****************************

;  MEMORY EDITOR / DISPLAY
;  USES MODES 3 or 6 DEPENDING ON
;  ENTRY MODE
;  LIMITS SET BY (START)/(FINISH)
;  Initial Ptr in Sptr
;  Apparent Addr in SADDR
; 
;  Top line of window in Wtop
;  Number of lines in MELines

Modes:
                lda #135
                jsr OSBYTE      ; Get display mode 0..7
                ldx #$6         ; Mode 6
                lda #8          ; Width in columns
                cpy #4          ; Mode
                bcs Mode        ; Use mode 6 for modes 4..7
                ldx #$3         ; Use Mode 3 for mode 0..3
                asl a           ; =16
Mode:           sta Width
                lda #22
                jsr OSWRCH
                txa
                jsr OSWRCH      ; select mode 
                lda #12
                jmp OSWRCH      ; CLS as well

;  * * * * * * * * * * * * * * * * * *

Initial_Screen:
                jsr Windowon
                lda #4
                ldx #1
                jsr OSBYTE      ; Set Cursor keys to asci
                jsr Blockcur
; Print out initial screen full
                jsr Setptrs
                lda MELines
                sta Ctrl        ; Line count

Line_2:         jsr Prntline
                jsr MECheckfinish
                bcs done_4
                jsr Updateptrs
A2:             dec Ctrl
                bne Line_2
done_4:         jmp Setptrs     ; Reset MEPtr/MEAddr

;  * * * * * * * * * * * * * * * * * *

Editor:
                jsr Copy_Selects
                jsr Initial_Screen
                ldx #6          ; Tab to byte 1 Hex
                ldy #0
                sty Side        ; 0=Hex, FF=Asci
                sty MEOffset    ; (MEPtr),MEOffset 0-15
                jsr Tab

Wait:                           ; Wait for Key down
                jsr OSRDCH
                bcs Quit        ; error, ie escaped
Gotkey:         sta Char
                lda #121
                ldx #(0 ^ $80)  ; Check shift
                jsr OSBYTE
                cpx #$FF
                bne *+4
                ldx #0          ; not down
                stx Shift       ; -ve = down
                ldx #(1 ^ $80)  ; Check Ctrl
                jsr OSBYTE
                cpx #$FF
                bne *+4
                ldx #0          ; not down
                stx Ctrl        ; -ve = down
                lda Char
                cmp #$7F
                bcc *+5
                jmp Cursors
                cmp #13
                beq CR_4
                cmp #9
                bne Key

; Char=9, TAB
                ldx Ctrl
                bmi Key         ; Ctrl I
; Toggle sides - Asci/Hex
                bit Side
                bmi TLft
; Move to asci on RHS
                jsr Goright
                jmp LL

TLft:           jsr Goleft
LL:             lda Side
                eor #$FF
                sta Side
                jmp Wait

CR_4:                           ; Char=13
                ldx Ctrl
                bmi Key         ; Ctrl M
Quit:           rts

Key:            bit Side
                bpl Hex_edit

Asci_edit:                      ; Chr in A
                ldy MEOffset
                jsr Writeram    ; Alter ram
                jsr Goleft      ; Tab to Hex side
                lda Char
                jsr Halfhex     ; Update Hex
                jsr Updateasci
                jmp CRight2     ; Update offset etc.

Updateasci:
                lda #$FF
                sta Writeflag
                jsr Goright     ; back to Asci
                lda Char
                jmp Printasci_dot; Update asci

Hex_edit:                       ; Chr in A
                jsr Hex
                bcc Wait        ; Bad hex
                sta Ctrl        ; Temp store
                jsr Up_or_Low   ; Which nybble?
                php
                ldy MEOffset
                bcc Hexlow      ; C=0 if low nybble

Hexhigh:        lda Ctrl
                asl a
                asl a
                asl a
                asl a
                sta Ctrl
                jsr Readram
                and #$0F
                bcc HL2         ; C=0 from ASL A

Hexlow:         jsr Readram
                and #$F0

HL2:            ora Ctrl
                jsr Writeram
                sta Char        ; New chr
                jsr Updateasci
                jsr Goleft      ; back to hex, upper nybble
                lda Char
                jsr Hex_asci    ; Update Hex
                plp             ; C=0 if lower nybble edited
                bcc CR3_1       ; Move on to next byte
                lda #8
                jsr OSWRCH      ; Back onto lower
                jmp Wait

Shifted:        cmp#139
                beq Up8
                cmp#135
                beq Curcopy
                cmp#138
                bne JW

Down8:          ldx #16
                stx Shift
D8a:            jsr C_down
                dec Shift
                bne D8a
                beq JW

Up8:            ldx #16
                stx Shift
U8a:            jsr C_up
                dec Shift
                bne U8a
                beq JW

Cursors:
                ldx Shift
                bmi Shifted
                ldx Ctrl
                bpl *+3
                rts             ; CTRL CURSORS

                cmp #136
                bne *+5
                jmp Curleft
                cmp #137
                beq Curight
                cmp #138
                beq Curdown
                cmp #139
                bne JW
                jmp Curup

Curcopy:                        ; Copy key,
                jsr Curposn
                txa
                pha
                tya
                pha
                lda #26
                jsr OSWRCH      ; No window
                jsr Copy_scr
                jsr Windowon
                pla
                tay
                pla
                tax
                jsr Tab
JW:             jmp Wait

Curight:
                bit Side
                bpl HexCR
CR3_1:          lda #9
                bne CR5_1
HexCR:          jsr Up_or_Low   ; Which nybble?
                php
                lda #9
                jsr OSWRCH      ; Forward 1
                plp
                bcs JW          ; C=1 if Upper
CR5_1:          jsr OSWRCH      ; Forward
CRight2:        inc MEOffset
                lda MEOffset
                cmp Width
                bcc JW          ; Not line end
                lda #0
                sta MEOffset
                bit Side
                bpl CR4
                jsr Goright     ; Tab to column 0 in asci
                jmp Curdown     ; Newline

CR4:            jsr Goleft      ; Tab to column 0 in Hex, then fall into Curdown..

Curdown:        jsr C_down
JW2:            jmp Wait

C_down:         jsr MECheckfinish; See if a new line would exceed end addr
                bcs Rts_1
                jsr Updateptrs
                jsr Curposn
                iny
                cpy MELines     ; Bottom line?
                beq Rolldown
                lda #10
                jmp OSWRCH      ; and rts

Rolldown:       stx Ctrl        ; Temp save
                jsr Prntline    ; Newline
                ldy MELines
                dey

Rollcom:        ldx Ctrl
                jsr Tab
Rts_1:          rts

Curleft:        bit Side
                bpl HexCL       ; Hex side
                lda #8
                bne CL2
HexCL:          jsr Up_or_Low
                php
                lda #8
                jsr OSWRCH      ; Back 1
                plp             ; C=1 for Upper nybble
                bcc JW2         ; Was lower, now upper
CL2:            jsr OSWRCH      ; Back 1
                dec MEOffset
                bpl JW2         ; Same line still
                ldy Width
                dey
                sty MEOffset    ; Reset to 7/15
                bit Side
                bpl CL4
                jsr Goright     ; Tab to New column in asci
                jmp Curup
CL4:            jsr Goleft      ; Tab to New column in hex
; Now fall into Cursor up

Curup:          jsr C_up
                jmp Wait

C_up:           jsr Checkstart
                bcc Rts_1       ; cant move
                jsr Updateptr2
                jsr Curposn
                lda #11
                jsr OSWRCH      ; Up 1
                cpy #0          ; Top line?
                bne Rts_1       ; No, done

Rollup:         stx Ctrl
                lda #13
                jsr OSWRCH
                jsr Prntln2     ; New line
                ldy #0
                beq Rollcom     ; Tab back to old X

Windowon:                       ; Set Textwindow
                lda #28
                jsr OSWRCH
                lda #0
                jsr OSWRCH      ; Left=0
                ldx Wtop
                dex
                txa
                clc
                adc MELines
                jsr OSWRCH      ; Bottom= Wtop+MELines-1
                lda #39
                ldx Width
                cpx #8
                beq W2
                lda #79
W2:             jsr OSWRCH      ; Right=39 or 79
                lda Wtop
                jmp OSWRCH      ; Top

Prntline:       jsr OSNEWL
Prntln2:        ldy MEAddr+1
                beq lsb
                tya
                jsr Hex_asci    ; msb
lsb:            lda MEAddr
                jsr Hex_asci    ; lsb
                tya
                bne L4_2
                jsr Space2
L4_2:           jsr Space2
                ldy #0
                ldx Width       ; 8 or 16
Hexline:        jsr Readram
                jsr Halfhex
L2_4:           jsr Space1
                iny
                dex
                bne Hexline
                ldy #1
                ldx Width
                cpx #8
                beq L3_1
                ldy #8
; Add 1 space if 40 col, 7 for 80
L3_1:           jsr Space1
                dey
                bne L3_1
; Y=0, X=Width
Ascline:        jsr Readram
                jsr Printasci_dot
                iny
                dex
                bne Ascline
                rts

Goright:        jsr Curposn
                lda #31
                ldx Width
                cpx #8
                beq *+3
                asl a           ; =62
                clc
                adc MEOffset
                bne Jump

Goleft:         jsr Curposn
                lda MEOffset
                asl a
                adc MEOffset    ; x3
                adc #6          ; Addr width
Jump:           tax
                jmp Tab

Up_or_Low:                      ; See if cursor is on upper or lower nybble
                jsr Curposn
                txa
                sec
UL2:            sbc #3
                beq UL3         ; Rtn C=1 for upper, 3/6/9..
                bcs UL2
UL3:            rts             ; C=0 for lower

MECheckfinish:                  ; See if newline possible
                lda MEPtr
                clc
                adc Width
                tay             ; lsb
                lda MEPtr+1
                adc #0
                cmp MEFinish+1
                bcc CF2         ; Ok, rtn C=0
                bne CF2         ; Past, C=1
                cpy MEFinish
CF2:            rts             ; C=0 OK, C=1 too far

Updateptrs:     sta MEPtr+1     ; msb
                sty MEPtr       ; lsb
                lda MEAddr
                clc
                adc Width
                sta MEAddr
                bcc Ud2
                inc MEAddr+1
Ud2:            rts

Checkstart:     lda MEPtr
                sec
                sbc Width
                tay             ; lsb
                lda MEPtr+1
                sbc #0
                cmp MEStart+1
                bcc CS2_1       ; Too far, C=0
                bne CS2_1       ; Ok, C=1
                cpy MEStart
CS2_1:          rts

Updateptr2:     sta MEPtr+1
                sty MEPtr
                lda MEAddr
                sec
                sbc Width
                sta MEAddr
                bcs UD3
                dec MEAddr+1
UD3:            rts

Setptrs:        ldx #3          ; Transfer Saddr and Sptr
Sp2:            lda Sptr,x      ; to MEAddr and MEPtr
                sta MEPtr,x
                dex
                bpl Sp2
                rts

;  ********************************

Halfhex:        cmp #$10
                bcc Half
                jmp Hex_asci
Half:           pha
                jsr Space1
                pla
                jmp Nybble

Tab:            lda #31
                jsr OSWRCH
                txa
                jsr OSWRCH
                tya
                jmp OSWRCH

Curposn:        lda #134
                jmp OSBYTE

Printasci_dot:                  ; Print chr in A if possible, else dot.
                cmp #$7F
                bcs dot
                cmp #32
                bcs print
dot:            lda #"."
print:          jmp OSWRCH

Curnorm:        lda #26
                jsr OSWRCH      ; No window
                ldy #114
                bne Bc1

Blockcur:
                ldy #96

Bc1:            rts             ;  *** NO CURSOR CHANGES ***

                ldx #9
Bc2:            lda Block,x
                bpl *+3
                tya             ; Required size
                jsr OSWRCH
                dex
                bpl Bc2
                rts

Block:          .word 0
                .dword 0
                .byte $FF       ; Variable
                .byte 10        ; Reg 10
                .byte 0         ; CRTC..
                .byte 23        ; Define chr

; **********************************
Readram=$100
Writeram=$111

Copy_Selects:                   ; Copy read/write routines to ram
                ldx #0
C2_1:           lda Copystart,x
                sta $100,x
                inx
                cpx #Copyend-Copystart
                bcc C2_1
                rts

Copystart:
;  ELECTRON rom select is at FE05, BBC at FE30
; Readram - LDA(MEPtr),Y after selecting swrom, preserves XY

                sei             ; No interrupts, as F4 is not correct..
                lda #$C
                sta $FE05       ; page out basic by selecting a rom C to F
                lda Rom_1
                sta $FE05
                lda (MEPtr),y
                pha
                lda $F4
                sta $FE05       ; Reselect Probe rom
                pla
                cli
                rts

Copymid:
; Writeram - STA(MEPtr),Y, Corrupts X
                ldx #$C
                sei
                stx $FE05
                ldx Rom_1
                stx $FE05
                sta (MEPtr),y
                ldx $F4
                stx $FE05
                cli
                rts
Copyend:


                .endif
                ; include_end: MEMEDIT

                ; include_start: TXCOPY
                .if include_TXCOPY

;  *******************************************
;  * TXCOPY - Copy text screen to printer    *
;  *******************************************

TXCOPY:
                jsr Curposn
                txa
                pha
                tya
                pha
                jsr Copy_scr
                pla
                tay
                pla
                tax
                jsr Tab         ; Restore cursor posn
                jmp Alldone

;  Entry point also used by MEMEDIT..

Copy_scr:       lda #2
                jsr OSWRCH      ; Printer on
                lda #236
                ldx #$40
                ldy #$BF
                jsr OSBYTE      ; Disable printer except 1,..
                lda #30
                jsr OSWRCH      ; Home
                lda $30A        ; Window rt
                sec
                sbc $308        ; left
                sta $AE         ; Chrs/line
                lda $309        ; Bottom
                sbc $30B        ; Top
                sta $AF         ; lines in window

Loop_2:         bit $FF
                bmi Copied      ; Escaped
                lda #135
                jsr OSBYTE      ; Get chr at cursor
                lda #1
                jsr OSWRCH      ; Next chr to printer
                txa
                jsr Printasci_dot
                jsr Curposn
                cpx $AE         ; Width
                bcc next
                lda #13
                jsr Printit     ; CR to printer
                cpy $AF         ; Lines
                beq Copied      ; Last
                ldx #0
                ldy #$FF
                lda #246
                jsr OSBYTE      ; Read printer ignore chr
                cpx #10         ; Ignore lfs?
                beq next        ; Printer must be auto LF
                lda #10
                jsr Printit     ; LF 

next:           lda #9
                jsr OSWRCH
                jmp Loop_2

Copied:
                lda #10
                jsr Printit     ; Final LF
                lda #236
                ldx #0
                ldy #$BF
                jsr OSBYTE      ; Reset printer drive
                lda #3
                jmp OSWRCH      ; printer off, RTS

                .endif
                ; include_end: TXCOPY


