; I couldn't find my original disassembly of 1.32, so this is a
; scrappily modified version of the earliest buildable code I have
; that builds to an exact match.

; Sigh... doesn't build in case-insensitive mode...
;.include "../submodules/beeb/include/beeb.s65"

osnewl=$ffe7
oswrch=$ffee
osbyte=$fff4
osrdch=$ffe0
osword=$fff1
osfile=$ffdd
oscli=$fff7
                
;-------------------------------------------------------------------------

ENABLE_DEBUG=false
ELECTRON=false
ORIGINAL_CTRL_UP_DOWN=true
                
                .weak

acornsoft_version=false
bet2_version=false
                
                .endweak

;-------------------------------------------------------------------------

*=0
                .dsection zp
                .cerror *>$8f,"zp overflow"

*=$60
                .dsection basic_unused_zp
                .cerror *>$90,"basic unused zp overflow"

;-------------------------------------------------------------------------

                .include "../../cmds.s65"

                .if bet2_version
CMD_unknown_BA=$ba              ; shift+tab??
CMD_unknown_CA=$CA              ; tab??
CMD_UTILS=$EC
CMD_UPDATE=$ED
                .endif
                
                .include "../pres_constants.s65"

                .if acornsoft_version
brkv_routine=brk_handler
                .else
brkv_routine=LBFEB
                .endif

                .if bet2_version
rom_switch_thunk=$a00
                .endif
                

;-------------------------------------------------------------------------
; SLRE---1-
; S=service
; L=language
; R=copro relocation
; E=electron soft key

ROM_FLAGS = %11000010
                
;-------------------------------------------------------------------------
                
                .dsection code
                * = $8000

rom_start:
                JMP     language_entry
                JMP     service_entry

                .byte ROM_FLAGS

                .byte  copyright-rom_start ;
                .if acornsoft_version
                .byte     5
                .else
                .byte 1
                .endif
                .if bet2_version
rom_name: .text "BASIC Editor & Toolkit"
                .else
                .text "The BASIC Editor",0
                .endif
version_number_string:
                .if bet2_version
                .text " 1.00"
                .else
                .text " 1.32"
                .endif
version_number_string_end:
copyright:
                .byte 0
aC1984Acornsoft:
                .text "(C)"
                .if bet2_version
                .text " 1990 B.E."
                .else
                .text " 1984 Acornsoft"
                .endif
                .byte 0
                
; A = code, X = ROM number, Y = parameter.

service_entry .proc
                php
                pha
                tya
                pha
                lda $a8
                pha
                lda $a9
                pha
                txa
                pha
                .if bet2_version
                stx $a8
                sty $a9
                .endif
                cld
                tsx
                lda $105,x
                cmp #4
                beq star_command
                cmp #9
                beq help
                .if bet2_version
                cmp #8
                beq new_osword
                .endif
exit:
                .if bet2_version
                jmp restore_a8_a9
                .else
                pla
                tax
                pla
                sta $a9
                pla
                sta $a8
                pla
                tay
                pla
                plp
                rts
                .endif
                .endproc

                .if bet2_version
star_command:
                jsr L80D4
                lda #3
                jmp call_other_rom

new_osword:
                jsr LBC8B
                pha
                jmp LA95A

help:
                jsr L807C
                cmp #2
                beq service_entry.exit
                cmp #1
                beq L8077
                jsr L80A4
                jmp service_entry.exit

L8077:
                lda #2
                jmp call_other_rom

L807C:
                ldy $a9
L807E:
                lda ($f2),y
                cmp #' '
                bne L8087
                iny
                bne L807E
L8087:
                cmp #13
                bne L808E
                lda #0
                rts

L808E:
                clc
                tya
                adc $f2
                sta $a8
                lda #0
                adc $f3
                sta $a9
                jsr L8107
                lda #1
                bcs L80A3
                lda #2
L80A3:
                rts

L80A4:
                jsr osnewl
                ldy #0
L80A9:
                lda aBasicEditorToolkit,y
                beq L80B4
                jsr oswrch
                iny
                bne L80A9
L80B4:
                ldy #0
L80B6:
                lda version_number_string,y
                jsr oswrch
                iny
                cpy #version_number_string_end-version_number_string
                bcc L80B6
                jsr osnewl

                ldy #0
L80C6:
                lda be_help_subject,y
                jsr oswrch
                iny
                cpy #size(be_help_subject)
                bcc L80C6
                jmp osnewl

L80D4:
                lda $a8
                pha
                lda $a9
                clc
                adc $f2
                sta $a8
                lda #0
                adc $f3
                sta $a9
                ldy #0
                lda ($a8),y
                and #$df
                cmp #'P'
                bne L80F9
                lda $a8
                clc
                adc #1
                sta $a8
                bne L80F9
                inc $a9
L80F9:
                jsr L8107
                bcc L8105
                pla
                tax
                lda #$8e
                jmp osbyte

L8105:
                pla
                rts

L8107:
                ldy #$ff
L8109:
                iny
                lda be_cmd,y
                tax
                lda ($a8),y
                cmp #'.'
                bne L811E
                cpy #0
                beq L8132
                cpx #0
                beq L8132
L811C:
                sec
                rts

L811E:
                cmp #13
                beq L8126
                cmp #' '
                bne L812B
L8126:
                txa
                beq L811C
                bne L8132
L812B:
                and #$df
                cmp be_cmd,y
                beq L8109
L8132:
                clc
                rts

L8134: .block
                pha
                lda $f4
                eor #1
                sta $f4
                sta $fe30
                pla
                jmp (LBFEE)
                .endblock

                .include "pres_bedit.execute_key_command.s65"
                .include "pres_bedit.atoi_from_command_line.s65"
                .include "pres_bedit.AA41.s65"
                .include "pres_bedit.token_table.s65"
                .include "pres_bedit.itoa.s65"
                .include "pres_bedit.brk_handler.s65"
                .include "pres_bedit.edit_mode_loop.s65"

L87DC:
                .if acornsoft_version
                ldx #$11
                .else
                lda #$11
                .endif
                jsr oswrch
                txa
                jsr oswrch
                lda #$11
                jsr oswrch
                tya
                jsr oswrch
                clc
                lda #0
                adc cursor_offset
                tax
                lda #4
                adc unk_11
                tay
                lda #1
                jsr print_n_chars
                jmp position_edit_mode_cursor

                .include "pres_bedit.967A.s65"
                .include "pres_bedit.A8C0.s65"
                .include "pres_bedit.commands.info.s65"
                .include "pres_bedit.compare_cmd_char_to_input_char.s65"
                .include "pres_bedit.commands.renumber.s65"
                .include "pres_bedit.commands.back.fore.insert.overtype.s65"
                .include "pres_bedit.commands.help.s65"
                .include "pres_bedit.commands.goto.s65"
           
                .else

help:
                lda ($f2),y
                cmp #' '
                bne L8062
                iny
                bne help

L8062:
                cmp #13
                bne service_entry.exit
                jsr osnewl
                ldy #0
print_ROM_name_loop:
                lda aTheBasicEditor,y
                beq print_version_number
                jsr oswrch
                iny
                bne print_ROM_name_loop

print_version_number:
                ldy #0
print_version_number_loop:
                lda version_number_string,y
                jsr oswrch
                iny
                cpy #version_number_string_end-version_number_string
                bcc print_version_number_loop
                jsr osnewl
                jmp service_entry.exit

star_command: .proc
                clc
                tya
                adc $f2
                sta $a8
                lda #0
                adc $f3
                sta $a9
                ldy #0
L8097:
                lda be_cmd,y
                tax
                lda ($a8),y
                cmp #'.'
                bne L80B0
                cpy #0
                beq service_entry.exit
                cpx #0
                beq service_entry.exit

L80A9:
                pla
                tax
                lda #$8e
                jmp osbyte

L80B0:
                cmp #13
                beq end_of_line
                cmp #' '
                bne check_char

end_of_line:
                txa
                beq L80A9
                bne service_entry.exit

check_char:
                and #$df
                cmp be_cmd,y
                bne service_entry.exit
                iny
                bne L8097

                .endproc
                
                .endif

                ; fall through to language entry
                
language_entry: .proc
                CMP     #1              ; normal language entry?
                BEQ     language_start
                RTS

language_start:
                ; lda #0
                ; sta $100
                ; lda #255
                ; sta $101
                ; lda #"A"
                ; sta $102
                ; lda #"R"
                ; sta $103
                ; lda #"S"
                ; sta $104
                ; lda #"E"
                ; sta $105
                ; lda #0
                ; sta $106
                ; jmp $100
                
                JSR     init_brkv_and_oshwm
                JSR     clear_line_commands
                JSR     sub_B358
                JSR     reset_program_name
                LDX     #5
                STX     unk_61
                LDX     #0
                LDA     #$D2
                JSR     osbyte_with_y0
                LDX     #$60 ; '`'
                STX     unk_31
                LDX     #0
                stx is_insert_mode
                STX     byte_62
                INX
                STX     scroll_status   ; 1=scroll, 0=noscroll
                LDA     #$E4
                JSR     osbyte_with_y0
                JSR     clear_5B1_to_600
                LDA   #$87            ; get MODE in Y (and char under cursor in X)
                JSR   OSBYTE
                JSR     validate_mode
                lda #4
                sta background_colour
                lda #7
                sta foreground_colour
                lda #22
                jsr oswrch
                lda #7
                jsr oswrch

                
                ; LDA     #7
                ; STA     foreground_colour

                ; ; print_n_chars skips control chars if editor_mode_id
                ; ; isn't 1. And since aResetOSWRCH is entirely control
                ; ; chars...
                ; lda #1
                ; sta editor_mode_id
                ; ldx #<aResetOSWRCH
                ; ldy #>aResetOSWRCH
                ; lda #aResetOSWRCHEnd-aResetOSWRCH
                ; jsr print_n_chars
                
                JSR     sub_8314
                JSR     find_program
                BCC     language_start_good_program
                JSR     clear_program
                JSR     clear_5B1_to_600

language_start_good_program:                            
                                        
                LDX     #$FF
                TXS
                JSR     initialise
                JSR     find_program
                BCS     loc_8147
                JSR     is_program_empty ; sets C if no program
                BCS     loc_8147
                LDA     current_line_no_lsb
                STA     byte_2B
                LDA     current_line_no_msb
                STA     byte_2C
                JSR     find_line_by_number ; finds a line, given a line number
                                        ;
                                        ; Entry:
                                        ; byte_2B: line number MSB
                                        ; byte_2C: line number LSB
                                        ;
                                        ; Exit:
                                        ; (byte_2B) points to most suitable line
                LDY     #1
                LDA     ($2B),Y
                BPL     loc_8144
                JSR     sub_AA77        ; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_8144:                               
                JSR     save_line_number ; saves line number from program.
                                        ;
                                        ; Entry:
                                        ; (byte_2b) points to current line
                                        ;
                                        ; Exit:
                                        ; current_line_no_lsb, current_line_no_msb = the line number

loc_8147:                               
                                        
                JSR     print_command_screen
                JSR     do_command_line

loc_814D:                               
                                        
                LDA     editor_mode_id  ; 1=command mode, 2=edit mode
                CMP     #2              ; edit mode?
                BNE     language_start_good_program     ; branch taken if not edit mode
; edit mode
                LDA     byte_15
                BEQ     loc_8163
                LDA     current_line_no_lsb
                STA     byte_50
                LDA     current_line_no_msb
                STA     byte_51
                JMP     language_start_good_program

loc_8163:                               
                LDA     byte_6C1
                CMP     #-1
                BEQ     language_start_good_program
                STA     byte_3A
                LDA     byte_6C0
                STA     byte_39
                LDY     #1
                LDA     ($39),Y
                STA     byte_50
                INY
                LDA     ($39),Y
                STA     byte_51
                JMP     language_start_good_program
; End of function language_entry
                .pend



init_brkv_and_oshwm: .proc
                                        
                CLI
                CLD
                LDA     #<brkv_routine
                STA     $202            ; BRKV+0
                LDA     #>brkv_routine
                STA     $203            ; BRKV+1
                LDA     #0
                STA     oshwm
                STA     unk_6AD
                LDA     #$83
                JSR     OSBYTE          ; Read OSHWM
                STY     oshwm+1         ; $18 = MSB
                LDA     #$82
                JSR     OSBYTE          ; Read machine higher order address
                STX     higher_order_address
                STY     higher_order_address+1
                LDA     #0
                STA     unk_6B8
                LDA     #$A
                STA     unk_6B9
                RTS
; End of function init_brkv_and_oshwm
                .endproc

                .if bet2_version
                .include "pres_bedit.command_table.s65"
                .include "pres_bedit.B0AC.s65"
                .include "pres_bedit.commands.cursor_stuff.s65"
                .include "pres_bedit.rstrip_and_cr_terminate_detokenized_line.s65"
                .include "pres_bedit.detokenize_one_line.s65"
                .include "pres_bedit.commands.delete_stuff.s65"
                .else
                .include "pres_bedit.validate_mode.s65"
                .endif

print_command_screen .proc
TEXT_WINDOW_TOP = 7
                JSR     make_cursor_invisible
                JSR     get_text_window_left_bottom
                STX     byte_25
                STY     byte_26
                LDX     #$A
                JSR     OSBYTE
                STX     byte_27
                STY     byte_28
                LDA     #$86
                JSR     OSBYTE
                TYA
                PHA

                ; see if text window is set up. if it is, obviously
                ; (?) the HUD just needs updating. otherwise, redraw
                ; it completely.
                LDA     #26
                JSR     OSWRCH
                JSR     get_text_window_left_bottom
                CPY     byte_26
                BNE     loc_8218
                LDA     #0
                CMP     byte_25
                BNE     loc_8218
                lda #39
                cmp byte_27
                BNE     loc_8218
                LDA     #TEXT_WINDOW_TOP
                CMP     byte_28
                BEQ     loc_823B

loc_8218:                               
                                        
                LDA     #0
                STA     byte_25         ; text window left
                LDA   #39
                STA   byte_27         ; text window right
                LDA     #TEXT_WINDOW_TOP
                STA     byte_28         ; text window top
                LDA   #$13            ; wait for vsync
                JSR   OSBYTE
; print "The BASIC Editor", "Program size" (etc.)
                LDX     #<hud_text_begin
                LDY     #>hud_text_begin
                LDA     #hud_text_end-hud_text_begin
                JSR     print_n_chars
                JSR     get_text_window_left_bottom
                STY     byte_26
                PLA
                LDA     #0
                PHA

loc_823B:                               
                LDA     #26             ; restore default text window
                JSR     OSWRCH
; print program size
                LDX     #15
                LDY     #3
                JSR     gotoxy
                LDA     unk_16
                BNE     loc_8259
                LDX     TOP
                SEC
                LDA     TOP+1
                SBC     oshwm+1
                TAY
                JSR     itoa            ; Gets string representation of 16-bit number.
                                        ;
                                        ; Entry:
                                        ; Y,X = value
                                        ;
                                        ; Exit:
                                        ; unk_0 holds digit count
                                        ; unk_1... filled with string
                JSR     print_number    ; print number.
                                        ;
                                        ; Suitable for use with the result of itoa.
                                        ;
                                        ; Entry:
                                        ; unk_0 = digit count
                                        ; unk_1... = digits

loc_8259:                               
                JSR     print_5_spaces
; print bytes free
                LDX     #15
                LDY     #4
                JSR     gotoxy
                LDA     unk_16
                BNE     loc_8278
                SEC
                LDA     HIMEM
                SBC     TOP
                TAX
                LDA     HIMEM+1
                SBC     TOP+1
                TAY
                JSR     itoa            ; Gets string representation of 16-bit number.
                                        ;
                                        ; Entry:
                                        ; Y,X = value
                                        ;
                                        ; Exit:
                                        ; unk_0 holds digit count
                                        ; unk_1... filled with string
                JSR     print_number    ; print number.
                                        ;
                                        ; Suitable for use with the result of itoa.
                                        ;
                                        ; Entry:
                                        ; unk_0 = digit count
                                        ; unk_1... = digits

loc_8278:                               
                JSR     print_5_spaces

                ldx #$f
                ldy #5
                jsr gotoxy

                .if bet2_version
                jsr is_Electron
                .endif
                
                ldx screen_mode
                .if bet2_version
                bcc L9670
                cpx #7
                bne L9670
                lda #$85
                jsr osbyte
                cpy #$7c
                bne L966E
                ldx #7
                bne L9670
L966E:
                ldx #6
L9670:
                .endif
                ldy #0
                jsr itoa
                jsr print_number
                jsr print_5_spaces

; print program name

                ; ldx #6
                ; ldy #1
                ; jsr gotoxy
                ; jsr print_program_name_padded

                ; LDX     #<hud_text_2_begin
                ; LDY     #>hud_text_2_begin
                ; LDA     #hud_text_2_end-hud_text_2_begin
                ; JSR     print_n_chars

                
; set screen window
                LDA     #28
                STA     byte_24
                LDX     #$24 ; '$'
                LDY     #0
                LDA     #5
                JSR     print_n_chars
                PLA
                TAY
                LDX     #0
                JSR     gotoxy
                LDA     byte_15
                BEQ     loc_82CB
                JSR     OSNEWL
                .if acornsoft_version
                LDX     #$4F ; 'O'
                LDY     #$28 ; '('
                .else
                ldy #$4e
                .endif

loc_82AE:
                .if acornsoft_version
                LDA     $5D7,Y
                .else
                lda unk_5B1,y
                .endif
                CMP     #$20 ; ' '
                BNE     loc_82BA
                DEY
                .if bet2_version
                beq loc_82BA
                .endif
                BNE     loc_82AE
                .if acornsoft_version
                LDX     #$27 ; '''
                .endif

loc_82BA:
                .if acornsoft_version
                TXA
                .else
                iny
                tya
                .endif
                LDX     #<unk_5B1
                LDY     #>unk_5B1
                JSR     print_n_chars
                JSR     OSNEWL
                JSR     OSNEWL
                JSR     beep

loc_82CB:                               
                LDA     #'>'
                JSR     OSWRCH
                LDA     is_insert_mode  ; 0=overtype 1=insert
                PHA
                LDA     unk_31
                PHA
                LDA     #0
                STA     is_insert_mode  ; 0=overtype 1=insert
                LDA     #$60 ; '`'
                STA     unk_31
                JSR     reset_cursor_shape
                PLA
                STA     unk_31
                PLA
                STA     is_insert_mode  ; 0=overtype 1=insert
                RTS
; End of function print_command_screen



.pend
print_5_spaces .proc                               
                                        
                LDX     #<six_spaces_string
                LDY     #>six_spaces_string
                LDA     #5
                JMP     print_n_chars
.pend
; End of function print_5_spaces




get_text_window_left_bottom:            
                                        
                LDX     #8
                LDA     #$A0
                JMP     OSBYTE
; End of function get_text_window_left_bottom

                .if bet2_version
                .include "pres_bedit.get_line_dimensions.s65"
                .include "pres_bedit.enter_edit_mode.s65"
                .include "pres_bedit.9FD8.s65"
                .include "pres_bedit.9DEA.s65"
                .include "pres_bedit.AB1E.s65"

L99DC:
                pha
                txa
                pha
                tya
                pha
                lda #$88
                jmp call_other_rom

L99E6:
                pha
                txa
                pha
                tya
                pha
                lda #$89
                jmp call_other_rom

                .include "pres_bedit.find_line_by_number.s65"
                .include "pres_bedit.execute_command.s65"
                .include "pres_bedit.commands.split_statement.s65"
                .include "pres_bedit.commands.toggle_insert_overtype.s65"
                .include "pres_bedit.command_jump_table.s65"
                .include "pres_bedit.commands.continue_edit_mode.s65"
                .include "pres_bedit.commands.execute_edit_mode.s65"
                .include "pres_bedit.commands.join_statements.s65"
                .include "pres_bedit.commands.tab_key.s65"
                .include "pres_bedit.read_line.s65"

LA301:
                tay
                pla
                tax
LA304:
                pla
                sta rom_switch_thunk,x
                dex
                bpl LA304
                tya
                cmp #1
                bne LA311
                rts

LA311:
                cmp #2
                bne LA318
                ; butils->bedit code 2
                jmp restore_a8_a9

LA318:
                cmp #3
                bne LA31F
                ; butils->bedit code 3
                jmp LA95A

LA31F:
                cmp #5
                bne LA35C
                ; butils->bedit code 5
                tsx
                lda $105,x
                cmp #9
                bne LA345
                jsr L807C
                cmp #2
                bne LA337
LA332:
                lda #$87
LA334:
                jmp call_other_rom

LA337:
                cmp #1
                beq LA341
                jsr L80A4
                jmp LA332

LA341:
                lda #$82
                bne LA334

LA345:
                cmp #4
                bne LA350
                jsr L80D4
                lda #$83
                bne LA334

LA350:
                cmp #8
                bne LA332
                jsr LBC8B
                pha
                lda #$84
                bne LA334
LA35C:
                cmp #$a
                bne LA363
                ; butils->bedit code $a
                jmp language_entry.loc_814D

LA363:
                cmp #$b
                bne LA36A
                ; butils->bentry code $b
                jmp loc_9D2D

LA36A:
                jmp brk_handler

                .include "pres_bedit.commands.label.s65"
                .include "pres_bedit.AEB9.s65"
                .include "pres_bedit.AC08.s65"
                .include "pres_bedit.AD39.s65"
                .include "pres_bedit.redraw_line_number.s65"
                .include "pres_bedit.get_line_height.s65"

restore_a8_a9:
                pla
                tax
                pla
                sta $a9
                pla
                sta $a8
                pla
                tay
                pla
                plp
                rts

LA95A:
                pla
                beq LA960
                jmp restore_a8_a9

LA960:
                pla
                tax
                pla
                sta $a9
                pla
                sta $a8
                pla
                tay
                pla
                lda #0
                plp
                rts

                .include "pres_bedit.strings.s65"

LABD2:
                ;  ???? - are these command codes?
                .byte $C1 
                .byte $B8 
                .byte $A8 
                .byte $CF 
                .byte $CE 
                .byte $B6 
                .byte $B7 
                .byte $C5 
                .byte $C6 
                .byte $C0 
                .byte   0
                .byte $C4 
                .byte $AC 
                .byte $AD 
                .byte $AE 
                .byte $AF 
                .byte $A2 
                .byte $C7 
                .byte $A5 
                .byte $A6 
                .byte $A0 
                .byte $C8 
                .byte   0
                .byte $A7 
                .byte $A1 
                .byte $C3 
                .byte $CC 
                .byte $CD 
                .byte $B5 
                .byte $B0 
                .byte $B1 
                .byte   0
                .byte $A9 
                .byte $A4 
                .byte $C2 
                .byte $CA 
                .byte $B2 
                .byte   0
                .byte   0
                .byte $B4 
                .byte   0
                .byte $A3 
                .byte $BD 
                .byte $BC 
                .byte $BA 
                .byte $B3 
                .byte $BF 
                .byte $BE

                .include "pres_bedit.A069.s65"
                .include "pres_bedit.commands.load.s65"

update_command:
                lda program_name+0
                cmp #$20
                bne LACF5
                lda #$28
LACF2:
                jmp loc_859D

LACF5:
                lda #$27
                ldx unk_60
                cpx #$20
                bne LACF2
                lda #$52
                sta byte_C
                lda #0
                sta byte_D
                lda #0
                sta byte_E
                sta byte_3E
                lda #7
                sta byte_F
                sta byte_3F
                ldx #0
                ldy #$f
                jsr memmove
                lda #$d
                sta unk_700+$e
                jmp save_command

                .include "pres_bedit.AA06.s65"
                .include "pres_bedit.find_first_non_alpha_char.s65"
                .include "pres_bedit.do_command_line.s65"
                .include "pres_bedit.memset.s65"
                .include "pres_bedit.B358.s65"
                
                .endif

clear_program:                          
                                        
                LDY     #0
                LDA     #$D
                STA     ($17),Y
                INY
                LDA     #-1
                STA     ($17),Y
                JSR     find_program
                LDA     #0
                STA     current_line_no_lsb
                LDA     #$A
                STA     current_line_no_msb
                JSR     sub_B358
                JMP     clear_line_commands
; End of function clear_program


sub_8314:                               
                                        
                LDA     #0
                STA     current_line_no_lsb
                STA     current_line_no_msb
                STA     byte_50
                STA     byte_51
                RTS
; End of function sub_8314

                .if bet2_version
                .include "pres_bedit.B7A1.s65"
                .include "pres_bedit.clear_5B1_to_600.s65"
                .include "pres_bedit.osbyte_with_y0.s65"
                .include "pres_bedit.BE98.s65"
                .include "pres_bedit.print_number.s65"
                .include "pres_bedit.8492.s65"
                .include "pres_bedit.BDD3.s65"
                .include "pres_bedit.commands.change_or_qchange.s65"
                .include "pres_bedit.reset_keys_settings.s65"
                .include "pres_bedit.B4B7.s65"
                .include "pres_bedit.commands.number.s65"
                .include "pres_bedit.commands.return_key.s65"
                .include "pres_bedit.BA69.s65"
                .include "pres_bedit.commands.find.s65"
                .include "pres_bedit.set_palette.s65"

get_error:
                ldx byte_15
                bne LBA74
                pha
                jsr clear_5B1_to_600
                pla
                sta byte_15
                lda #1
                jmp call_other_rom

LBA74:
                rts

                .include "pres_bedit.commands.mode.s65"
                .include "pres_bedit.memmove.s65"

call_other_rom:
                tay             ; Y=input A
                ldx #0
LBB38:
                lda rom_switch_thunk,x
                pha
                lda L8134,x
                sta rom_switch_thunk,x
                inx
                cpx #size(L8134)
                bne LBB38
                lda #size(L8134)-1
                pha            ; save indication of # bytes to restore
                tya            ; A = input A
                jmp rom_switch_thunk

                .include "pres_bedit.parse_command_line.s65"
                .include "pres_bedit.gotoxy.s65"

is_Electron:
                ldx #0
                ldy #$ff
                lda #$81
                jsr osbyte
                cpx #1
                bne LBC89
                sec
                rts

LBC89:
                clc
                rts

LBC8B:
                lda $a8
                pha
                lda $a9
                pha
                lda $f0         ; osword X
                sta $a8
                lda $f1         ; osword Y
                sta $a9
                lda $ef         ; osword A
                cmp #$b5        ; osword code
                bne LBCA7       ; taken if not $B5
                ldy #2
                lda ($a8),y
                cmp #3
                bcc LBCB0       ; taken if +2<3
LBCA7:
                pla
                sta $a9
                pla
                sta $a8
                lda #8
                rts

LBCB0:
                iny             ; Y=3
                ldx #0
LBCB3:
                cpx #size(rom_name)-1 ; is the -1 a bug???
                beq LBCC2
                lda ($a8),y
                cmp rom_name,x
                bne LBCA7
                inx
                iny
                bne LBCB3

LBCC2:
                ldy #2
                lda ($a8),y
                bne LBCDC       ; taken if code!=0

                ; code==0
                ldx #$c
LBCCA:
                lda new_osword_stuff-2,y
                sta ($a8),y
                iny
                dex
                bpl LBCCA
                pla
                sta $a9
                pla
                sta $a8
                lda #0
                rts

LBCDC:
                cmp #2
                beq LBCE4       ; taken if code=2

                ; code==1
                lda #'L'        ; L for LOAD
                bne LBCE6       ; jmp, in effect

LBCE4:
                lda #'A'        ; A for APPEND
LBCE6:
                jsr insert_into_keyboard_buffer
                lda #' '
                jsr insert_into_keyboard_buffer
                ldy #$18
                lda ($a8),y
                beq LBCF5
                iny
LBCF5:
                iny
LBCF6:
                lda ($a8),y
                beq LBD00
                jsr insert_into_keyboard_buffer
                iny
                bne LBCF6

LBD00:
                lda #$d
                jsr insert_into_keyboard_buffer
                ldx #<LBFE8
                ldy #>LBFE8
                jmp oscli

insert_into_keyboard_buffer:
                tax
                tya
                pha             ; save Y
                txa             ; restore input A
                tay             ; Y=input A
                ldx #0
                lda #$8a
                jsr osbyte      ; insert char in keyboard buffer
                pla
                tay
                rts

                .endif

find_program:                           
                                        
                LDA     #0
                STA     unk_16
                STA     byte_38
                STA     byte_C
                STA     byte_D
                PHA
                LDA     #$FF
                PHA
                PHA
                LDA     oshwm+1
                STA     byte_39

find_program_scan_line:                         
                LDY     #0
                LDA     (byte_38),Y     ; get first char in line
                CMP     #$D             ; is it the required 13?
                BEQ     line_start_ok

bad_program:                            
                PLA
                PLA
                PLA
                INC     unk_16
                LDA     #1
                JSR     get_error       ; A = error code
                SEC                     ; bad program
                RTS

line_start_ok:                          
                INY
                LDA     (byte_38),Y     ; line MSB
                BPL     scan_valid_line ; if +ve, not end
; reached end, so set TOP to just past the terminating $FF
                CLC
                LDA     byte_38
                ADC     #2
                STA     TOP
                LDA     #0
                ADC     byte_39
; gone past the relevant HIMEM?
                STA     TOP+1
                CMP     HIMEM+1
                BCC     TOP_in_bounds
                BNE     force_mode_7
                LDA     HIMEM
                CMP     TOP
                BCS     TOP_in_bounds

force_mode_7:                           
                LDY     #7
                JSR     validate_mode
                LDA     #3
                JSR     get_error       ; A = error code

TOP_in_bounds:                          
                                        
                PLA
                PLA
                PLA
                BEQ     find_program_good_program
                JSR     sub_8495

find_program_good_program:
                CLC
                RTS
; (seems to be maintaining its own notion of line numbering - not sure what for - it never does anything particular if it encounters a discrepancy)

scan_valid_line:                        
                LDA     byte_C
                BMI     loc_8387
                CLC
                LDA     byte_D
                ADC     #10
                STA     byte_D
                BCC     loc_8387
                INC     byte_C

loc_8387:                               
                                        
                PLA
                BMI     loc_83A0
                CMP     (byte_38),Y
                BEQ     loc_8392
                BCC     loc_83A0
                BCS     loc_839A

loc_8392:                               
                INY
                PLA
                CMP     (byte_38),Y
                BCS     loc_839B
                BCC     loc_83A1

loc_839A:                               
                PLA

loc_839B:                               
                PLA
                LDA     #1
                PHA
                PHA

loc_83A0:                               
                                        
                PLA

loc_83A1:                               
                LDY     #2

loc_83A3:                               
                LDA     (byte_38),Y
                PHA
                DEY
                BNE     loc_83A3
                LDY     #3
                LDA     (byte_38),Y     ; get line length
                BMI     next_line       ; if >=128, it's fine
                CMP     #4
                BCC     bad_program     ; if <4, bad program

next_line:                              
                CLC
                ADC     byte_38
                STA     byte_38
                BCC     scan_next_line
                INC     byte_39

scan_next_line:                         
                JMP     find_program_scan_line
; End of function find_program

                .if bet2_version
                .include "pres_bedit.validate_mode.s65"
                .endif

initialise:                             
                JSR     init_brkv_and_oshwm
                LDY     screen_mode
                JSR     validate_mode
                LDX     #0              ; default output streams
                LDA     #3              ; select output streams (AUG p119)
                JSR     osbyte_with_y0
                LDX     #0              ; keyboard on, rs423 off
                LDA     #2              ; select input stream (AUG p118)
                JSR     OSBYTE
                LDX     #0              ; enable cursor editing
                LDA     #4              ; enable/disable cursor editing (AUG p120)
                JSR     OSBYTE
                LDA     #13             ; Disable events (AUG p129)
                LDX     #9
                STX     byte_3A

disable_all_events_loop:                
                LDX     byte_3A
                JSR     osbyte_with_y0
; X=0 now
                DEC     byte_3A
                BPL     disable_all_events_loop
                LDA     #200            ; set ESCAPE, BREAK effect (AUG p205)
                LDY     #%11111110      ; normal ESCAPE action (bit 0 reset)
                JSR     OSBYTE
                .if bet2_version
                jsr is_Electron
                bcs LBE2B
                .endif
                LDX     #0              ; TAB key produces CHR$0
                LDA     #219            ; read/write TAB key char (AUG p222)
                JSR     osbyte_with_y0
                .if bet2_version
LBE2B:
                .endif
                LDX     #27             ; ESCAPE key produces CHR$27
                LDA     #220            ; read/write Escape char (AUG p223)
                JSR     osbyte_with_y0
                .if acornsoft_version
                LDX     #0              ; ignore key
                .else
                ldx #1
                .endif
                LDA     #225            ; read/write function key status (AUG p225)
                JSR     osbyte_with_y0
                .if acornsoft_version
                LDX     #0              ; ignore key
                .else
                ldx #1
                .endif
                LDA     #226            ; read/write SHIFT+function key status (AUG p225)
                JSR     osbyte_with_y0
                .if acornsoft_version
                LDX     #0              ; ignore key
                .else
                ldx #1
                .endif
                LDA     #227            ; read/write CTRL+function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ESCAPE has normal action
                LDA     #229            ; read/write status of ESCAPE key (AUG p227)
                JSR     osbyte_with_y0
                LDX     #0              ; ESCAPE has normal effects
                LDA     #230            ; read/write flags determining ESCAPE effects (AUG p228)
                JSR     osbyte_with_y0
                LDA     #3              ; printer off
                JSR     OSWRCH
                ASL                     ; VDU6 - enable VDU drivers
                JSR     OSWRCH
                LDA     #1
                STA     editor_mode_id  ; 1=command mode, 2=edit mode
                LDA     #0
                STA     byte_6B3
                RTS
; End of function initialise


loc_8437:
; Set cursor keys and COPY to produce ASCII                 
                LDX     #2
                LDA     #4
                JSR     OSBYTE
; Set function keys to produce ASCII $A0...$A9
                LDX     #$A0
                LDA     #225
                JSR     osbyte_with_y0
; Set SHIFT+function keys to produce ASCII $B0...$B9
                LDX     #$B0
                LDA     #226
                JSR     osbyte_with_y0
; Set Ctrl+function keys to produce ASCII $C0...$C9
                LDX     #$C0 ; 'À'
                LDA     #227
                JMP     osbyte_with_y0

                .if acornsoft_version
                .include "pres_bedit.brk_handler.s65"
                .include "pres_bedit.8492.s65"

error_message: .macro text
                .text \text|$80
                .endm
                
error_messages_table:
                .error_message "Bad program" ;1
                .error_message "Unknown error message" ;2
                .error_message "No room - Mode reset" ;3
                .error_message "Line too long" ;4
		.error_message "No room"   ;5
                .error_message "Missing line command" ;6
                .error_message "Target not found" ;7
                .error_message "String not found" ;8
                .error_message "Invalid command" ;9
                .error_message "Invalid argument" ;10
                .error_message "Bad number" ;11
                .error_message "Too many arguments" ;12
                .error_message "Only modes 0,1,3,4,6,7 are valid"
                .error_message "No room for this mode" ;14
                .error_message "No references to labels were found" ;15
                .error_message "Unresolved labels - please check" ;16
                .error_message "Line too long to be numbered" ;17
                .error_message "Line too long to contain label" ;18
                .error_message "No labels reinstated" ;19
                .error_message "Lines too long to be joined" ;20
                .error_message "Only colours N,R,G,Y,B,M,C,W are valid" ;21
                .error_message "Invalid line number" ;22
                .error_message "Replace string missing" ;23
                .error_message "Only two strings allowed" ;24
                .error_message "Start line/Increment too big" ;25
                .error_message "Too many line commands" ;26
                .error_message "Incompatible line commands" ;27
                .error_message "Invalid delete command" ;28
                .error_message "Invalid destination" ;29
                .error_message "Destination missing" ;30
                .error_message "Incomplete line command" ;31
                .error_message "Argument missing" ;32
                .error_message "Tab stop must be in range 0-80" ;33
                .error_message "No marked line" ;34
                .error_message "No search string set up" ;35
                .error_message "Line has been truncated" ;36
                .error_message "Updates would make line too long" ;37
                .error_message "Increment must be in range 1-255" ;38
                .byte  $FF ;

                .include "pres_bedit.strings.s65"
                .include "pres_bedit.do_command_line.s65"
                .include "pres_bedit.command_table.s65"
                .include "pres_bedit.parse_command_line.s65"
                .include "pres_bedit.itoa.s65"
                .include "pres_bedit.compare_cmd_char_to_input_char.s65"
                .include "pres_bedit.find_first_non_alpha_char.s65"
                .include "pres_bedit.memset.s65"
                .include "pres_bedit.osbyte_with_y0.s65"
                .include "pres_bedit.print_number.s65"
                .include "pres_bedit.memmove.s65"
                .include "pres_bedit.gotoxy.s65"
                .endif

print_n_chars .proc			
		STX	byte_C
		STY	byte_D
		TAX
		BEQ done
                LDY	#0
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		BEQ done
		CMP	#1
                BEQ start
		LDY	#$20 ; ' '

start:				
		STY	byte_3A
                LDY	#0

loop:
		LDA	($C),Y
		CMP	#$7F ; ''
                BEQ print_space
                pha
                lda screen_mode
                cmp #7
                beq mode7
                pla
                jmp check_char

mode7:
                pla
		CMP	#141
		BEQ print_space
                cmp #$ff
                beq print_space

check_char:
		CMP	byte_3A
		BCS print_char

print_space:				
					
		LDA	#$20 ; ' '

print_char				
		JSR	OSWRCH
		INY
		DEX
		BNE loop

done:
					
		RTS
                .endproc
; End of function print_n_chars

                .if acornsoft_version
                .include "pres_bedit.get_line_dimensions.s65"
                .include "pres_bedit.atoi_from_command_line.s65"
                .include "pres_bedit.execute_command.s65"
                .include "pres_bedit.clear_5B1_to_600.s65"

; A = error code

get_error:				
					
		PHA
		LDA	byte_15		; already got an error?
		BEQ	copy_error	; taken	if no error yet
		PLA
		RTS

copy_error:				
		JSR	clear_5B1_to_600
		PLA
		STA	byte_15		; store	error code
		LDA	#<error_messages_table
		STA	byte_C
		LDA	#>error_messages_table
		STA	byte_D
		LDY	#0		; offset into errors table
		LDX	#0		; current error	index

find_error_loop:			
					
		LDA	($C),Y		; next byte from table
		BPL	loc_90C5	; taken	if still looking at the	current	error
; hit a negative char, so this means it's looking at the next error, so bump the error index.
		INX

loc_90C5:				
		CPX	byte_15		; reached the desired error?
		BEQ	found_error	; taken	if desired error reached
		INC	byte_C
		BNE	find_error_loop
		INC	byte_D
		BNE	find_error_loop

found_error:				
		LDX	#0

copy_error_loop:			
		AND	#$7F		; mask out top bit (in case)
		STA	unk_5B1,X	; store	in error message buffer
		INY			; next source byte...
		INX			; next dest byte...
		LDA	($C),Y		; load next byte from error table
		BPL	copy_error_loop	; taken	if haven't ended up in the next error
		RTS
; End of function get_error

                .include "pres_bedit.commands.find.s65"
                .include "pres_bedit.commands.change_or_qchange.s65"
                .include "pres_bedit.commands.load.s65"
                .include "pres_bedit.read_line.s65"
                .include "pres_bedit.reset_keys_settings.s65"
                .include "pres_bedit.command_jump_table.s65"
                .include "pres_bedit.967A.s65"
                .include "pres_bedit.commands.tab_key.s65"
                .include "pres_bedit.commands.continue_edit_mode.s65"
                .include "pres_bedit.commands.split_statement.s65"
                .include "pres_bedit.commands.renumber.s65"
                .include "pres_bedit.edit_mode_loop.s65"
                .include "pres_bedit.detokenize_one_line.s65"
                .include "pres_bedit.enter_edit_mode.s65"
                .include "pres_bedit.9DEA.s65"
                .include "pres_bedit.find_line_by_number.s65"
                .include "pres_bedit.get_line_height.s65"
                .include "pres_bedit.set_palette.s65"
                .endif

                .if bet2_version
                .include "pres_bedit.A0B1.s65"
                .endif



sub_9F00:				
		JSR	make_cursor_invisible
		LDA	#1
		LDX	unk_8
		LDY	unk_9
		JSR	sub_A0B1
		LDX	#0
		STX	byte_36

loc_9F10:				
		LDX	#0
		CLC
		LDA	byte_36
		BEQ	loc_9F26
		ADC	byte_3B
		TAY
		JSR	gotoxy
		LDX	#<six_spaces_string
		LDY	#>six_spaces_string
		LDA	#6
		JSR	print_n_chars

loc_9F26:				
		INC	byte_36
		LDA	byte_36
		CMP	byte_2D
		BNE	loc_9F10
		JMP	redraw_line_number
; End of function sub_9F00

                .if bet2_version
LBFB2:
                pha
                jsr is_Electron
                bcc LBFC9
                pla
                pha
                sec
                sbc #$a0
                bmi LBFC9
                cmp #$30
                bcs LBFC9
                tax
                pla
                lda LABD2,x
                pha
LBFC9:
                pla
                rts

                .fill $bfe2-*,0
LBFE2:
                jmp L99DC
LBFE5:
                jmp L99E6
LBFE8:
                .text "BE",13
LBFEB:
                jmp brk_handler
LBFEE:
                .word LA301

                ; PLD paging region follows...
                .cerror *!=$bff0
                .fill 16,$20
                .endif
                

                .if acornsoft_version
                .include "pres_bedit.execute_key_command.s65"
                .include "pres_bedit.9FD8.s65"
                .include "pres_bedit.A069.s65"
                .include "pres_bedit.A0B1.s65"
                .include "pres_bedit.redraw_line_number.s65"
                .include "pres_bedit.token_table.s65"
                .include "pres_bedit.commands.toggle_insert_overtype.s65"
                .include "pres_bedit.commands.cursor_stuff.s65"
                .include "pres_bedit.A8C0.s65"
                .include "pres_bedit.AA06.s65"
                .include "pres_bedit.AA41.s65"
                .include "pres_bedit.commands.delete_stuff.s65"
                .include "pres_bedit.AB1E.s65"
                .include "pres_bedit.rstrip_and_cr_terminate_detokenized_line.s65"
                .include "pres_bedit.AC08.s65"
                .include "pres_bedit.commands.execute_edit_mode.s65"
                .include "pres_bedit.AD39.s65"
                .include "pres_bedit.AEB9.s65"
                .include "pres_bedit.commands.return_key.s65"
                .include "pres_bedit.B0AC.s65"
                .include "pres_bedit.commands.mode.s65"
                .include "pres_bedit.B358.s65"
                .include "pres_bedit.commands.number.s65"
                .include "pres_bedit.B4B7.s65"
                .include "pres_bedit.commands.label.s65"
                .include "pres_bedit.B7A1.s65"
                .include "pres_bedit.commands.join_statements.s65"
                .include "pres_bedit.BA69.s65"
                .include "pres_bedit.commands.back.fore.insert.overtype.s65"
                .include "pres_bedit.commands.help.s65"
                .include "pres_bedit.commands.goto.s65"
                .include "pres_bedit.commands.info.s65"
                .include "pres_bedit.BDD3.s65"
                .include "pres_bedit.BE98.s65"
                .endif

                .if acornsoft_version
                .fill $c000-*,0
                .endif
                