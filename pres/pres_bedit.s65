; I couldn't find my original disassembly of 1.32, so this is a
; scrappily modified version of the earliest buildable code I have
; that builds to an exact match.

; Sigh... doesn't build in case-insensitive mode...
;.include "../submodules/beeb/include/beeb.s65"

osnewl=$ffe7
oswrch=$ffee
osbyte=$fff4
osrdch=$ffe0
osword=$fff1
osfile=$ffdd
oscli=$fff7
                
;-------------------------------------------------------------------------

ENABLE_DEBUG=false
ELECTRON=false
ORIGINAL_CTRL_UP_DOWN=true
                
                .weak

acornsoft_version=false
bet2_version=false
                
                .endweak

;-------------------------------------------------------------------------

                .if bet2_version
; bodge region
                
call_other_rom=$bb35
LBC8B=$bc8b
LBFEE=$bfee
is_Electron=$bc7a
LB4EA=$b4ea
LBFB2=$bfb2
LBE85=$be85
LB249=$b249
                .endif
                
;-------------------------------------------------------------------------

*=0
                .dsection zp
                .cerror *>$8f,"zp overflow"

*=$60
                .dsection basic_unused_zp
                .cerror *>$90,"basic unused zp overflow"

;-------------------------------------------------------------------------

                .include "../cmds.s65"

                .if bet2_version
CMD_UTILS=$EC
CMD_UPDATE=$ED
                .endif
                
                .include "pres_constants.s65"

;-------------------------------------------------------------------------
; SLRE---1-
; S=service
; L=language
; R=copro relocation
; E=electron soft key

ROM_FLAGS = %11000010
                
;-------------------------------------------------------------------------
                
                .dsection code
                * = $8000

rom_start:
                JMP     language_entry
                JMP     service_entry

                .byte ROM_FLAGS

                .byte  copyright-rom_start ;
                .byte     5
                .if bet2_version
                .text "BASIC Editor & Toolkit"
                .else
                .text "The BASIC Editor",0
                .endif
version_number_string:
                .if bet2_version
                .text " 1.00"
                .else
                .text " 1.32"
                .endif
version_number_string_end:
copyright:
                .byte 0
aC1984Acornsoft:
                .text "(C)"
                .if bet2_version
                .text " 1990 B.E."
                .else
                .text " 1984 Acornsoft"
                .endif
                .byte 0
                
; A = code, X = ROM number, Y = parameter.

service_entry .proc
                php
                pha
                tya
                pha
                lda $a8
                pha
                lda $a9
                pha
                txa
                pha
                .if bet2_version
                stx $a8
                sty $a9
                .endif
                cld
                tsx
                lda $105,x
                cmp #4
                beq star_command
                cmp #9
                beq help
                .if bet2_version
                cmp #8
                beq new_osword
                .endif
exit:
                .if bet2_version
                jmp restore_a8_a9
                .else
                pla
                tax
                pla
                sta $a9
                pla
                sta $a8
                pla
                tay
                pla
                plp
                rts
                .endif
                .endproc

                .if bet2_version
star_command:
                jsr L80D4
                lda #3
                jmp call_other_rom

new_osword:
                jsr LBC8B
                pha
                jmp LA95A

help:
                jsr L807C
                cmp #2
                beq service_entry.exit
                cmp #1
                beq L8077
                jsr L80A4
                jmp service_entry.exit

L8077:
                lda #2
                jmp call_other_rom

L807C:
                ldy $a9
L807E:
                lda ($f2),y
                cmp #' '
                bne L8087
                iny
                bne L807E
L8087:
                cmp #13
                bne L808E
                lda #0
                rts

L808E:
                clc
                tya
                adc $f2
                sta $a8
                lda #0
                adc $f3
                sta $a9
                jsr L8107
                lda #1
                bcs L80A3
                lda #2
L80A3:
                rts

L80A4:
                jsr osnewl
                ldy #0
L80A9:
                lda aBasicEditorToolkit,y
                beq L80B4
                jsr oswrch
                iny
                bne L80A9
L80B4:
                ldy #0
L80B6:
                lda version_number_string,y
                jsr oswrch
                iny
                cpy #version_number_string_end-version_number_string
                bcc L80B6
                jsr osnewl

                ldy #0
L80C6:
                lda be_help_subject,y
                jsr oswrch
                iny
                cpy size(be_help_subject)
                bcc L80C6
                jmp osnewl

L80D4:
                lda $a8
                pha
                lda $a9
                clc
                adc $f2
                sta $a8
                lda #0
                adc $f3
                sta $a9
                ldy #0
                lda ($a8),y
                and #$df
                cmp #'P'
                bne L80F9
                lda $a8
                clc
                adc #1
                sta $a8
                bne L80F9
                inc $a9
L80F9:
                jsr L8107
                bcc L8105
                pla
                tax
                lda #$8e
                jmp osbyte

L8105:
                pla
                rts

L8107:
                ldy #$ff
L8109:
                iny
                lda be_cmd,y
                tax
                lda ($a8),y
                cmp #'.'
                beq L811E
                cpy #0
                beq L8132
                cpx #0
                beq L8132
L811C:
                sec
                rts

L811E:
                cmp #13
                beq L8126
                cmp #' '
                bne L812B
L8126:
                txa
                beq L811C
                bne L8132
L812B:
                and #$df
                cmp be_cmd,y
                beq L8109
L8132:
                clc
                rts

L8134:
                pha
                lda $f4
                eor #1
                sta $f4
                sta $fe30
                pla
                jmp (LBFEE)

                .include "pres_bedit.execute_key_command.s65"
                .include "pres_bedit.atoi_from_command_line.s65"
                .include "pres_bedit.AA41.s65"
                .include "pres_bedit.token_table.s65"
                .include "pres_bedit.itoa.s65"
                .include "pres_bedit.brk_handler.s65"
                .include "pres_bedit.edit_mode_loop.s65"

L87DC:
                ldx #$11
                jsr oswrch
                txa
                jsr oswrch
                lda #$11
                jsr oswrch
                tya
                jsr oswrch
                clc
                lda #0
                adc cursor_offset
                tax
                lda #4
                adc unk_11
                tay
                lda #1
                jsr LBE85
                jmp position_edit_mode_cursor

                .include "pres_bedit.967A.s65"
                .include "pres_bedit.A8C0.s65"
                .include "pres_bedit.commands.info.s65"
                .include "pres_bedit.compare_cmd_char_to_input_char.s65"
                .include "pres_bedit.commands.renumber.s65"
                .include "pres_bedit.commands.back.fore.insert.overtype.s65"
                .include "pres_bedit.commands.help.s65"
                .include "pres_bedit.commands.goto.s65"
           
                .else

help:
                lda ($f2),y
                cmp #' '
                bne L8062
                iny
                bne help

L8062:
                cmp #13
                bne service_entry.exit
                jsr osnewl
                ldy #0
print_ROM_name_loop:
                lda aTheBasicEditor,y
                beq print_version_number
                jsr oswrch
                iny
                bne print_ROM_name_loop

print_version_number:
                ldy #0
print_version_number_loop:
                lda version_number_string,y
                jsr oswrch
                iny
                cpy #version_number_string_end-version_number_string
                bcc print_version_number_loop
                jsr osnewl
                jmp service_entry.exit

star_command: .proc
                clc
                tya
                adc $f2
                sta $a8
                lda #0
                adc $f3
                sta $a9
                ldy #0
L8097:
                lda be_cmd,y
                tax
                lda ($a8),y
                cmp #'.'
                bne L80B0
                cpy #0
                beq service_entry.exit
                cpx #0
                beq service_entry.exit

L80A9:
                pla
                tax
                lda #$8e
                jmp osbyte

L80B0:
                cmp #13
                beq end_of_line
                cmp #' '
                bne check_char

end_of_line:
                txa
                beq L80A9
                bne service_entry.exit

check_char:
                and #$df
                cmp be_cmd,y
                bne service_entry.exit
                iny
                bne L8097

                .endproc
                
                .endif

                ; fall through to language entry
                
language_entry: .proc
                CMP     #1              ; normal language entry?
                BEQ     language_start
                RTS

language_start:
                ; lda #0
                ; sta $100
                ; lda #255
                ; sta $101
                ; lda #"A"
                ; sta $102
                ; lda #"R"
                ; sta $103
                ; lda #"S"
                ; sta $104
                ; lda #"E"
                ; sta $105
                ; lda #0
                ; sta $106
                ; jmp $100
                
                JSR     init_brkv_and_oshwm
                JSR     clear_line_commands
                JSR     sub_B358
                JSR     reset_program_name
                LDX     #5
                STX     unk_61
                LDX     #0
                LDA     #$D2
                JSR     osbyte_with_y0
                LDX     #$60 ; '`'
                STX     unk_31
                LDX     #0
                stx is_insert_mode
                STX     byte_62
                INX
                STX     scroll_status   ; 1=scroll, 0=noscroll
                LDA     #$E4
                JSR     osbyte_with_y0
                JSR     clear_5B1_to_600
                LDA   #$87            ; get MODE in Y (and char under cursor in X)
                JSR   OSBYTE
                JSR     validate_mode
                lda #4
                sta background_colour
                lda #7
                sta foreground_colour
                lda #22
                jsr oswrch
                lda #7
                jsr oswrch

                
                ; LDA     #7
                ; STA     foreground_colour

                ; ; print_n_chars skips control chars if editor_mode_id
                ; ; isn't 1. And since aResetOSWRCH is entirely control
                ; ; chars...
                ; lda #1
                ; sta editor_mode_id
                ; ldx #<aResetOSWRCH
                ; ldy #>aResetOSWRCH
                ; lda #aResetOSWRCHEnd-aResetOSWRCH
                ; jsr print_n_chars
                
                JSR     sub_8314
                JSR     find_program
                BCC     language_start_good_program
                JSR     clear_program
                JSR     clear_5B1_to_600

language_start_good_program:                            
                                        
                LDX     #$FF
                TXS
                JSR     initialise
                JSR     find_program
                BCS     loc_8147
                JSR     is_program_empty ; sets C if no program
                BCS     loc_8147
                LDA     current_line_no_lsb
                STA     byte_2B
                LDA     current_line_no_msb
                STA     byte_2C
                JSR     find_line_by_number ; finds a line, given a line number
                                        ;
                                        ; Entry:
                                        ; byte_2B: line number MSB
                                        ; byte_2C: line number LSB
                                        ;
                                        ; Exit:
                                        ; (byte_2B) points to most suitable line
                LDY     #1
                LDA     ($2B),Y
                BPL     loc_8144
                JSR     sub_AA77        ; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_8144:                               
                JSR     save_line_number ; saves line number from program.
                                        ;
                                        ; Entry:
                                        ; (byte_2b) points to current line
                                        ;
                                        ; Exit:
                                        ; current_line_no_lsb, current_line_no_msb = the line number

loc_8147:                               
                                        
                JSR     print_command_screen
                JSR     do_command_line

loc_814D:                               
                                        
                LDA     editor_mode_id  ; 1=command mode, 2=edit mode
                CMP     #2              ; edit mode?
                BNE     language_start_good_program     ; branch taken if not edit mode
; edit mode
                LDA     byte_15
                BEQ     loc_8163
                LDA     current_line_no_lsb
                STA     byte_50
                LDA     current_line_no_msb
                STA     byte_51
                JMP     language_start_good_program

loc_8163:                               
                LDA     byte_6C1
                CMP     #-1
                BEQ     language_start_good_program
                STA     byte_3A
                LDA     byte_6C0
                STA     byte_39
                LDY     #1
                LDA     ($39),Y
                STA     byte_50
                INY
                LDA     ($39),Y
                STA     byte_51
                JMP     language_start_good_program
; End of function language_entry
                .pend



init_brkv_and_oshwm: .proc
                                        
                CLI
                CLD
                LDA     #<brk_handler
                STA     $202            ; BRKV+0
                LDA     #>brk_handler
                STA     $203            ; BRKV+1
                LDA     #0
                STA     oshwm
                STA     unk_6AD
                LDA     #$83
                JSR     OSBYTE          ; Read OSHWM
                STY     oshwm+1         ; $18 = MSB
                LDA     #$82
                JSR     OSBYTE          ; Read machine higher order address
                STX     higher_order_address
                STY     higher_order_address+1
                LDA     #0
                STA     unk_6B8
                LDA     #$A
                STA     unk_6B9
                RTS
; End of function init_brkv_and_oshwm
                .endproc

                .if bet2_version
                .include "pres_bedit.command_table.s65"
                .include "pres_bedit.B0AC.s65"
                .include "pres_bedit.commands.cursor_stuff.s65"
                .include "pres_bedit.rstrip_and_cr_terminate_detokenized_line.s65"
                .include "pres_bedit.detokenize_one_line.s65"
                .include "pres_bedit.commands.delete_stuff.s65"
                .else
                .include "pres_bedit.validate_mode.s65"
                .endif

print_command_screen .proc
TEXT_WINDOW_TOP = 7
                JSR     make_cursor_invisible
                JSR     get_text_window_left_bottom
                STX     byte_25
                STY     byte_26
                LDX     #$A
                JSR     OSBYTE
                STX     byte_27
                STY     byte_28
                LDA     #$86
                JSR     OSBYTE
                TYA
                PHA

                ; see if text window is set up. if it is, obviously
                ; (?) the HUD just needs updating. otherwise, redraw
                ; it completely.
                LDA     #26
                JSR     OSWRCH
                JSR     get_text_window_left_bottom
                CPY     byte_26
                BNE     loc_8218
                LDA     #0
                CMP     byte_25
                BNE     loc_8218
                lda #39
                cmp byte_27
                BNE     loc_8218
                LDA     #TEXT_WINDOW_TOP
                CMP     byte_28
                BEQ     loc_823B

loc_8218:                               
                                        
                LDA     #0
                STA     byte_25         ; text window left
                LDA   #39
                STA   byte_27         ; text window right
                LDA     #TEXT_WINDOW_TOP
                STA     byte_28         ; text window top
                LDA   #$13            ; wait for vsync
                JSR   OSBYTE
; print "The BASIC Editor", "Program size" (etc.)
                LDX     #<hud_text_begin
                LDY     #>hud_text_begin
                LDA     #hud_text_end-hud_text_begin
                JSR     print_n_chars
                JSR     get_text_window_left_bottom
                STY     byte_26
                PLA
                LDA     #0
                PHA

loc_823B:                               
                LDA     #26             ; restore default text window
                JSR     OSWRCH
; print program size
                LDX     #15
                LDY     #3
                JSR     gotoxy
                LDA     unk_16
                BNE     loc_8259
                LDX     TOP
                SEC
                LDA     TOP+1
                SBC     oshwm+1
                TAY
                JSR     itoa            ; Gets string representation of 16-bit number.
                                        ;
                                        ; Entry:
                                        ; Y,X = value
                                        ;
                                        ; Exit:
                                        ; unk_0 holds digit count
                                        ; unk_1... filled with string
                JSR     print_number    ; print number.
                                        ;
                                        ; Suitable for use with the result of itoa.
                                        ;
                                        ; Entry:
                                        ; unk_0 = digit count
                                        ; unk_1... = digits

loc_8259:                               
                JSR     print_5_spaces
; print bytes free
                LDX     #15
                LDY     #4
                JSR     gotoxy
                LDA     unk_16
                BNE     loc_8278
                SEC
                LDA     HIMEM
                SBC     TOP
                TAX
                LDA     HIMEM+1
                SBC     TOP+1
                TAY
                JSR     itoa            ; Gets string representation of 16-bit number.
                                        ;
                                        ; Entry:
                                        ; Y,X = value
                                        ;
                                        ; Exit:
                                        ; unk_0 holds digit count
                                        ; unk_1... filled with string
                JSR     print_number    ; print number.
                                        ;
                                        ; Suitable for use with the result of itoa.
                                        ;
                                        ; Entry:
                                        ; unk_0 = digit count
                                        ; unk_1... = digits

loc_8278:                               
                JSR     print_5_spaces

                ldx #$f
                ldy #5
                jsr gotoxy

                .if bet2_version
                jsr is_Electron
                .endif
                
                ldx screen_mode
                .if bet2_version
                bcc L9670
                cpx #7
                bne L9670
                lda #$85
                jsr osbyte
                cpy #$7c
                bne L966E
                ldx #7
                bne L9670
L966E:
                ldx #6
L9670:
                .endif
                ldy #0
                jsr itoa
                jsr print_number
                jsr print_5_spaces

; print program name

                ; ldx #6
                ; ldy #1
                ; jsr gotoxy
                ; jsr print_program_name_padded

                ; LDX     #<hud_text_2_begin
                ; LDY     #>hud_text_2_begin
                ; LDA     #hud_text_2_end-hud_text_2_begin
                ; JSR     print_n_chars

                
; set screen window
                LDA     #28
                STA     byte_24
                LDX     #$24 ; '$'
                LDY     #0
                LDA     #5
                JSR     print_n_chars
                PLA
                TAY
                LDX     #0
                JSR     gotoxy
                LDA     byte_15
                BEQ     loc_82CB
                JSR     OSNEWL
                .if acornsoft_version
                LDX     #$4F ; 'O'
                LDY     #$28 ; '('
                .else
                ldy #$4e
                .endif

loc_82AE:                               
                LDA     $5D7,Y
                CMP     #$20 ; ' '
                BNE     loc_82BA
                DEY
                .if bet2_version
                beq loc_82BA
                .endif
                BNE     loc_82AE
                .if acornsoft_version
                LDX     #$27 ; '''
                .endif

loc_82BA:
                .if acornsoft_version
                TXA
                .else
                iny
                tya
                .endif
                LDX     #<unk_5B1
                LDY     #>unk_5B1
                JSR     print_n_chars
                JSR     OSNEWL
                JSR     OSNEWL
                JSR     beep

loc_82CB:                               
                LDA     #'>'
                JSR     OSWRCH
                LDA     is_insert_mode  ; 0=overtype 1=insert
                PHA
                LDA     unk_31
                PHA
                LDA     #0
                STA     is_insert_mode  ; 0=overtype 1=insert
                LDA     #$60 ; '`'
                STA     unk_31
                JSR     reset_cursor_shape
                PLA
                STA     unk_31
                PLA
                STA     is_insert_mode  ; 0=overtype 1=insert
                RTS
; End of function print_command_screen



.pend
print_5_spaces .proc                               
                                        
                LDX     #<six_spaces_string
                LDY     #>six_spaces_string
                LDA     #5
                JMP     print_n_chars
.pend
; End of function print_5_spaces




get_text_window_left_bottom:            
                                        
                LDX     #8
                LDA     #$A0
                JMP     OSBYTE
; End of function get_text_window_left_bottom

                .if bet2_version
                .include "pres_bedit.get_line_dimensions.s65"
                .include "pres_bedit.enter_edit_mode.s65"
                .include "pres_bedit.9FD8.s65"
                .include "pres_bedit.9DEA.s65"
                .include "pres_bedit.AB1E.s65"

L99DC:
                pha
                txa
                pha
                tya
                pha
                lda #$88
                jmp call_other_rom

L99E6:
                pha
                txa
                pha
                tya
                pha
                lda #$89
                jmp call_other_rom

                .include "pres_bedit.find_line_by_number.s65"
                .include "pres_bedit.execute_command.s65"
                .include "pres_bedit.commands.split_statement.s65"
                .include "pres_bedit.commands.toggle_insert_overtype.s65"
                .include "pres_bedit.command_jump_table.s65"
                .include "pres_bedit.commands.continue_edit_mode.s65"
                .include "pres_bedit.commands.execute_edit_mode.s65"
                .include "pres_bedit.commands.join_statements.s65"
                .include "pres_bedit.commands.tab_key.s65"
                .include "pres_bedit.read_line.s65"

LA301:
                tay
                pla
                tax
LA304:
                pla
                sta $a00,x
                dex
                bpl LA304
                tya
                cmp #1
                bne LA311
                rts

LA311:
                cmp #2
                bne LA318
                jmp restore_a8_a9

LA318:
                cmp #3
                bne LA31F
                jmp LA95A

LA31F:
                cmp #5
                bne LA35C
                tsx
                lda $105,x
                cmp #9
                bne LA345
                jsr L807C
                cmp #2
                bne LA337
LA332:
                lda #$87
LA334:
                jmp call_other_rom

LA337:
                cmp #1
                beq LA341
                jsr L80A4
                jmp LA332

LA341:
                lda #$82
                bne LA334

LA345:
                cmp #4
                bne LA350
                jsr L80D4
                lda #$83
                bne LA334

LA350:
                cmp #8
                bne LA332
                jsr LBC8B
                pha
                lda #$84
                bne LA334
LA35C:
                cmp #$a
                bne LA363
                jmp language_entry.loc_814D

LA363:
                cmp #$b
                bne LA36A
                jmp loc_9D2D

LA36A:
                jmp brk_handler

                .include "pres_bedit.commands.label.s65"
                .include "pres_bedit.AEB9.s65"
                .include "pres_bedit.AC08.s65"
                .include "pres_bedit.AD39.s65"
                .include "pres_bedit.redraw_line_number.s65"
                .include "pres_bedit.get_line_height.s65"

restore_a8_a9:
                pla
                tax
                pla
                sta $a9
                pla
                sta $a8
                pla
                tay
                pla
                plp
                rts

LA95A:
                pla
                beq LA960
                jmp restore_a8_a9

LA960:
                pla
                tax
                pla
                sta $a9
                pla
                sta $a8
                pla
                tay
                pla
                lda #0
                plp
                rts

                .include "pres_bedit.strings.s65"

LABD2:
                ;  ???? - are these command codes?
                .byte $C1 
                .byte $B8 
                .byte $A8 
                .byte $CF 
                .byte $CE 
                .byte $B6 
                .byte $B7 
                .byte $C5 
                .byte $C6 
                .byte $C0 
                .byte   0
                .byte $C4 
                .byte $AC 
                .byte $AD 
                .byte $AE 
                .byte $AF 
                .byte $A2 
                .byte $C7 
                .byte $A5 
                .byte $A6 
                .byte $A0 
                .byte $C8 
                .byte   0
                .byte $A7 
                .byte $A1 
                .byte $C3 
                .byte $CC 
                .byte $CD 
                .byte $B5 
                .byte $B0 
                .byte $B1 
                .byte   0
                .byte $A9 
                .byte $A4 
                .byte $C2 
                .byte $CA 
                .byte $B2 
                .byte   0
                .byte   0
                .byte $B4 
                .byte   0
                .byte $A3 
                .byte $BD 
                .byte $BC 
                .byte $BA 
                .byte $B3 
                .byte $BF 
                .byte $BE

                .include "pres_bedit.A069.s65"
                .include "pres_bedit.commands.load.s65"

update_command:
                lda program_name+0
                cmp #$20
                bne LACF5
                lda #$28
LACF2:
                jmp LB249

LACF5:
                lda #$27
                ldx unk_60
                cpx #$20
                bne LACF2
                lda #$52
                sta byte_C
                lda #0
                sta byte_D
                lda #0
                sta byte_E
                sta byte_3E
                lda #7
                sta byte_F
                sta byte_3F
                ldx #0
                ldy #$f
                jsr memmove
                lda #$d
                sta unk_700+$e
                jmp save_command

                .include "pres_bedit.AA06.s65"
                .include "pres_bedit.find_first_non_alpha_char.s65"
                .include "pres_bedit.do_command_line.s65"
                .include "pres_bedit.memset.s65"
                
                .endif

clear_program:                          
                                        
                LDY     #0
                LDA     #$D
                STA     ($17),Y
                INY
                LDA     #-1
                STA     ($17),Y
                JSR     find_program
                LDA     #0
                STA     current_line_no_lsb
                LDA     #$A
                STA     current_line_no_msb
                JSR     sub_B358
                JMP     clear_line_commands
; End of function clear_program




sub_8314:                               
                                        
                LDA     #0
                STA     current_line_no_lsb
                STA     current_line_no_msb
                STA     byte_50
                STA     byte_51
                RTS
; End of function sub_8314




find_program:                           
                                        
                LDA     #0
                STA     unk_16
                STA     byte_38
                STA     byte_C
                STA     byte_D
                PHA
                LDA     #$FF
                PHA
                PHA
                LDA     oshwm+1
                STA     byte_39

find_program_scan_line:                         
                LDY     #0
                LDA     (byte_38),Y     ; get first char in line
                CMP     #$D             ; is it the required 13?
                BEQ     line_start_ok

bad_program:                            
                PLA
                PLA
                PLA
                INC     unk_16
                LDA     #1
                JSR     get_error       ; A = error code
                SEC                     ; bad program
                RTS

line_start_ok:                          
                INY
                LDA     (byte_38),Y     ; line MSB
                BPL     scan_valid_line ; if +ve, not end
; reached end, so set TOP to just past the terminating $FF
                CLC
                LDA     byte_38
                ADC     #2
                STA     TOP
                LDA     #0
                ADC     byte_39
; gone past the relevant HIMEM?
                STA     TOP+1
                CMP     HIMEM+1
                BCC     TOP_in_bounds
                BNE     force_mode_7
                LDA     HIMEM
                CMP     TOP
                BCS     TOP_in_bounds

force_mode_7:                           
                LDY     #7
                JSR     validate_mode
                LDA     #3
                JSR     get_error       ; A = error code

TOP_in_bounds:                          
                                        
                PLA
                PLA
                PLA
                BEQ     find_program_good_program
                JSR     sub_8495

find_program_good_program:
                CLC
                RTS
; (seems to be maintaining its own notion of line numbering - not sure what for - it never does anything particular if it encounters a discrepancy)

scan_valid_line:                        
                LDA     byte_C
                BMI     loc_8387
                CLC
                LDA     byte_D
                ADC     #10
                STA     byte_D
                BCC     loc_8387
                INC     byte_C

loc_8387:                               
                                        
                PLA
                BMI     loc_83A0
                CMP     (byte_38),Y
                BEQ     loc_8392
                BCC     loc_83A0
                BCS     loc_839A

loc_8392:                               
                INY
                PLA
                CMP     (byte_38),Y
                BCS     loc_839B
                BCC     loc_83A1

loc_839A:                               
                PLA

loc_839B:                               
                PLA
                LDA     #1
                PHA
                PHA

loc_83A0:                               
                                        
                PLA

loc_83A1:                               
                LDY     #2

loc_83A3:                               
                LDA     (byte_38),Y
                PHA
                DEY
                BNE     loc_83A3
                LDY     #3
                LDA     (byte_38),Y     ; get line length
                BMI     next_line       ; if >=128, it's fine
                CMP     #4
                BCC     bad_program     ; if <4, bad program

next_line:                              
                CLC
                ADC     byte_38
                STA     byte_38
                BCC     scan_next_line
                INC     byte_39

scan_next_line:                         
                JMP     find_program_scan_line
; End of function find_program




initialise:                             
                JSR     init_brkv_and_oshwm
                LDY     screen_mode
                JSR     validate_mode
                LDX     #0              ; default output streams
                LDA     #3              ; select output streams (AUG p119)
                JSR     osbyte_with_y0
                LDX     #0              ; keyboard on, rs423 off
                LDA     #2              ; select input stream (AUG p118)
                JSR     OSBYTE
                LDX     #0              ; enable cursor editing
                LDA     #4              ; enable/disable cursor editing (AUG p120)
                JSR     OSBYTE
                LDA     #13             ; Disable events (AUG p129)
                LDX     #9
                STX     byte_3A

disable_all_events_loop:                
                LDX     byte_3A
                JSR     osbyte_with_y0
; X=0 now
                DEC     byte_3A
                BPL     disable_all_events_loop
                LDA     #200            ; set ESCAPE, BREAK effect (AUG p205)
                LDY     #%11111110      ; normal ESCAPE action (bit 0 reset)
                JSR     OSBYTE
                LDX     #0              ; TAB key produces CHR$0
                LDA     #219            ; read/write TAB key char (AUG p222)
                JSR     osbyte_with_y0
                LDX     #27             ; ESCAPE key produces CHR$27
                LDA     #220            ; read/write Escape char (AUG p223)
                JSR     osbyte_with_y0
                LDX     #0              ; ignore key
                LDA     #225            ; read/write function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ignore key
                LDA     #226            ; read/write SHIFT+function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ignore key
                LDA     #227            ; read/write CTRL+function key status (AUG p225)
                JSR     osbyte_with_y0
                LDX     #0              ; ESCAPE has normal action
                LDA     #229            ; read/write status of ESCAPE key (AUG p227)
                JSR     osbyte_with_y0
                LDX     #0              ; ESCAPE has normal effects
                LDA     #230            ; read/write flags determining ESCAPE effects (AUG p228)
                JSR     osbyte_with_y0
                LDA     #3              ; printer off
                JSR     OSWRCH
                ASL                     ; VDU6 - enable VDU drivers
                JSR     OSWRCH
                LDA     #1
                STA     editor_mode_id  ; 1=command mode, 2=edit mode
                LDA     #0
                STA     byte_6B3
                RTS
; End of function initialise


loc_8437:
; Set cursor keys and COPY to produce ASCII                 
                LDX     #2
                LDA     #4
                JSR     OSBYTE
; Set function keys to produce ASCII $A0...$A9
                LDX     #$A0
                LDA     #225
                JSR     osbyte_with_y0
; Set SHIFT+function keys to produce ASCII $B0...$B9
                LDX     #$B0
                LDA     #226
                JSR     osbyte_with_y0
; Set Ctrl+function keys to produce ASCII $C0...$C9
                LDX     #$C0 ; 'À'
                LDA     #227
                JMP     osbyte_with_y0

                .if acornsoft_version
                .include "pres_bedit.brk_handler.s65"
                .endif

sub_8492:				
		JSR	find_program
; End of function sub_8492




sub_8495:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2
		BNE	loc_849F
		JSR	make_cursor_invisible

loc_849F:				
		LDX	#10
		LDA	byte_C
		BPL	loc_84A7
		LDX	#3

loc_84A7:				
		STX	byte_3A
		LDA	oshwm
		STA	unk_33
		STA	byte_27
		LDA	oshwm+1
		STA	byte_28

loc_84B3:				
		LDY	#1
		LDA	(byte_27),Y
		BPL	loc_84BC
		JMP	loc_854F

loc_84BC:				
		LDY	#3
		LDA	(byte_27),Y
		STA	unk_37
		LDA	#0
		STA	byte_38
		INY
		STY	unk_34

loc_84C9:				
		LDY	unk_34
		CLC
		TYA
		ADC	#3
		BCS	loc_84D5
		CMP	unk_37
		BCC	loc_84D8

loc_84D5:				
		JMP	loc_853F

loc_84D8:				
		LDA	byte_38
		BEQ	loc_84DF

loc_84DC:				
		JMP	loc_852E

loc_84DF:				
		LDA	(byte_27),Y
		CMP	#$8D
		BNE	loc_84DC
		JSR	decode_line_number ; decode line number	from program.
					;
					; Entry:
					; (unk_27),Y points to 8D token
					;
					; Exit:
					; unk_21.w is line number.
		JSR	sub_85AC

loc_84EB:				
		LDY	#1
		LDA	(byte_25),Y
		BPL	loc_8505
		LDX	#4
		STX	unk_33
		LDY	unk_34
		LDA	#$40 ; '@'

loc_84F9:				
		STA	($27),Y
		INY
		DEX
		BNE	loc_84F9
		DEY

loc_8500:				
		STY	unk_34
		JMP	loc_852E

loc_8505:				
		CMP	byte_21
		BNE	loc_8529
		INY
		LDA	($25),Y
		CMP	byte_22
		BNE	loc_8529
		LDX	byte_35
		LDY	byte_36
		JSR	sub_85D8
		STX	byte_36
		STY	byte_35
		LDY	unk_34
		LDX	#2

loc_851F:				
		INY
		STA	($27),Y
		LDA	$34,X
		DEX
		BPL	loc_851F
		BMI	loc_8500

loc_8529:				
		JSR	sub_85BF
		BNE	loc_84EB

loc_852E:				
		LDA	($27),Y
		CMP	#$22 ; '"'
		BNE	loc_853A
		LDA	byte_38
		EOR	#1
		STA	byte_38

loc_853A:				
		INC	unk_34
		JMP	loc_84C9

loc_853F:				
		LDY	#3
		CLC
		LDA	($27),Y
		ADC	byte_27
		STA	byte_27
		BCC	loc_854C
		INC	byte_28

loc_854C:				
		JMP	loc_84B3

loc_854F:				
		JSR	sub_85AC

loc_8552:				
		LDY	#1
		LDA	($25),Y
		BMI	loc_858A
		LDX	#$11

loc_855A:				
		LDY	#2
		LDA	$40,X
		CMP	($25),Y
		BNE	loc_8575
		DEX
		DEY
		LDA	$40,X
		CMP	($25),Y
		BNE	loc_8576
		LDA	byte_35
		ORA	#$80 ; '€'
		STA	$40,X
		INX
		LDA	byte_36
		STA	$40,X

loc_8575:				
		DEX

loc_8576:				
		DEX
		DEX
		BPL	loc_855A
		LDY	#1
		LDA	byte_35
		STA	($25),Y
		INY
		LDA	byte_36
		STA	($25),Y
		JSR	sub_85BF
		BNE	loc_8552

loc_858A:				
		LDX	#$10

loc_858C:				
		LDA	$40,X
		AND	#$7F ; ''
		STA	$40,X
		DEX
		DEX
		DEX
		BPL	loc_858C
		LDA	unk_33
		BEQ	locret_85BE
		LDA	#7

loc_859D:				
					
		LDX	unk_6AD
		BEQ	loc_85A6
		STA	unk_6AD
		RTS

loc_85A6:				
		JSR	get_error	; A = error code
		JMP	language_entry.loc_814D
; End of function sub_8495




sub_85AC:				
		LDA	oshwm
		STA	byte_25
		LDA	oshwm+1
		STA	byte_26
		LDA	unk_6B8
		STA	byte_35
		LDA	unk_6B9
		STA	byte_36

locret_85BE:				
		RTS
; End of function sub_85AC




sub_85BF:				
		LDY	#3
		CLC
		LDA	($25),Y
		ADC	byte_25
		STA	byte_25
		BCC	loc_85CC
		INC	byte_26

loc_85CC:				
		CLC
		LDA	byte_3A
		ADC	byte_36
		STA	byte_36
		BCC	locret_85D7
		INC	byte_35

locret_85D7:				
		RTS
; End of function sub_85BF




sub_85D8:				
		STX	byte_C
		STY	byte_D
		LDX	#1
		STX	byte_E

loc_85E0:				
		LDA	$C,X
		ASL
		ROL	byte_E
		ASL
		ROL	byte_E
		SEC
		ROR
		LSR
		STA	$C,X
		DEX
		BPL	loc_85E0
		LDA	byte_E
		ASL
		ASL
		EOR	#$14
		LDX	byte_D
		LDY	byte_C
		RTS
                ; End of function sub_85D8
                ; 0

error_message: .macro text
                .text \text|$80
                .endm
                
error_messages_table:
                .error_message "Bad program" ;1
                .error_message "Unknown error message" ;2
                .error_message "No room - Mode reset" ;3
                .error_message "Line too long" ;4
		.error_message "No room"   ;5
                .error_message "Missing line command" ;6
                .error_message "Target not found" ;7
                .error_message "String not found" ;8
                .error_message "Invalid command" ;9
                .error_message "Invalid argument" ;10
                .error_message "Bad number" ;11
                .error_message "Too many arguments" ;12
                .error_message "Only modes 0,1,3,4,6,7 are valid"
                .error_message "No room for this mode" ;14
                .error_message "No references to labels were found" ;15
                .error_message "Unresolved labels - please check" ;16
                .error_message "Line too long to be numbered" ;17
                .error_message "Line too long to contain label" ;18
                .error_message "No labels reinstated" ;19
                .error_message "Lines too long to be joined" ;20
                .error_message "Only colours N,R,G,Y,B,M,C,W are valid" ;21
                .error_message "Invalid line number" ;22
                .error_message "Replace string missing" ;23
                .error_message "Only two strings allowed" ;24
                .error_message "Start line/Increment too big" ;25
                .error_message "Too many line commands" ;26
                .error_message "Incompatible line commands" ;27
                .error_message "Invalid delete command" ;28
                .error_message "Invalid destination" ;29
                .error_message "Destination missing" ;30
                .error_message "Incomplete line command" ;31
                .error_message "Argument missing" ;32
                .error_message "Tab stop must be in range 0-80" ;33
                .error_message "No marked line" ;34
                .error_message "No search string set up" ;35
                .error_message "Line has been truncated" ;36
                .error_message "Updates would make line too long" ;37
                .error_message "Increment must be in range 1-255" ;38
                .byte  $FF ;

                .if acornsoft_version
                .include "pres_bedit.strings.s65"
                .include "pres_bedit.do_command_line.s65"
                .include "pres_bedit.command_table.s65"
                .endif


parse_command_line:			
		LDY	#0
		STY	current_command_id
		LDA	#0
		STA	byte_C
		LDA	#7
		STA	byte_D
; Skip spaces at the start of the command line

skip_initial_spaces_loop:		
		LDA	(byte_C),Y
		CMP	#32
		BNE	found_non_space
		INC	byte_C
		BNE	loc_8CB0
		INC	byte_D

loc_8CB0:				
		BNE	skip_initial_spaces_loop

found_non_space:			
		CMP	#$D
		BEQ	done2

try_star:				; is it	looking	like a * command?
		CMP	#'*'
		BNE	try_number	; branch taken if it's not a * command
		LDA	#CMD_star	; ok, it IS a *	command

store_current_command:			
					
		STA	current_command_id

done2:					
		RTS

try_number:				
		JSR	atoi		; entry: (unk_C) points	to text;
					; exit:	C set if error,	or (byte_3E,byte_3F) holds value
		BCS	try_command	; branch taken if it doesn't look like a number
		LDY	#0

skip_number_loop:			
		LDA	(byte_C),Y	; get number char
		CMP	#13
		BEQ	is_line_number	; branch taken if end of command line
		CMP	#32
		BEQ	skip_post_number_spaces_loop ; branch taken if end of number
		INY
		BNE	skip_number_loop

skip_post_number_spaces_loop:		
					
		INY
		LDA	(byte_C),Y	; get whitespace char
		CMP	#13		; end of command line?
		BEQ	is_line_number	; branch taken if end of command line
		CMP	#32            ; just a space?
		BEQ	skip_post_number_spaces_loop ; keep going if so
; any non-space chars after the line number are invalid.
		LDA	#$16		; "Invalid line	number"
		JMP	loc_859D

is_line_number:				
					
		LDA	#CMD_goto_line
		BNE	store_current_command ;	JMP, in	effect

try_command:				
		JSR	find_first_non_alpha_char
		LDA	#<command_table
		STA	byte_E
		LDA	#>command_table
		STA	byte_F

try_this_command:			
		LDY	#0
		LDA	(byte_E),Y	; get next char	from command table
		BMI	invalid_command	; invalid, if reached end of table
		JSR	compare_cmd_char_to_input_char ; entry:	(unk_C)	points to input	char, (unk_E) points to	command	table char
					; exit:	C set if matched
		BCS	char_matched
; advance to next command in table

find_end_of_command_name_loop:		
		LDA	(byte_E),Y
		BEQ	found_end_of_command_name
		INY
		BNE	find_end_of_command_name_loop

found_end_of_command_name:		
		INY			; skip terminating 0
		INY			; skip args byte
		INY			; skip command ID
; add Y to table pointer
		CLC
		TYA
		ADC	byte_E
		STA	byte_E
		BCC	loc_8D12
		INC	byte_F

loc_8D12:				
		BNE	try_this_command ; JMP,	in effect

invalid_command:			
		LDA	#9		; "Invalid command"
		JMP	loc_859D

char_matched:				
		STY	byte_3A

find_end_of_command_name_loop_2:	
		LDA	(byte_E),Y
		BEQ	found_end_of_command_name_2
		INY
		BNE	find_end_of_command_name_loop_2

found_end_of_command_name_2:		
		INY			; skip terminating 0
		STY	byte_39		; $39 =	Y pointing into	data
		LDA	($E),Y		; get first byte of command data
		STA	byte_49		; $49 =	first byte of command data
		LDY	byte_3A
		LDA	($C),Y		; get last matched input char
		LDX	#0
		CMP	#13		; end of line there?
		BEQ	loc_8D52
		CMP	#'.'            ; abbreviated input?
		BNE	skip_spaces	; branch taken if not abbreviated
		INY			; just skip the	'.'
; Skip spaces after command

skip_spaces:				
					
		LDA	(byte_C),Y
		CMP	#32
		BNE	spaces_skipped
		INY
		BNE	skip_spaces

spaces_skipped:				
		CMP	#13		; end of command line?
		BEQ	loc_8D52
		INX			; X=1
; Set ($3E) to point to remainder of command line
		CLC
		TYA
		ADC	byte_C
		STA	byte_3E
		LDA	byte_D
		ADC	#0
		STA	byte_3F

loc_8D52:				
					
		TXA			; get 0	(no args entered) or 1 (args entered)
		EOR	byte_49		; Set bit 0 if state differs from command's requirements
		AND	#1		; Extract bit 0
		BEQ	loc_8D69	; Branch taken if command wants	args and some were entered/it doesn't and there weren't
		LDA	byte_49
		AND	#4		; String arg?
		BNE	loc_8D69	; branch taken if string arg wanted but	one wasn't supplied
; "Invalid argument" if an unnecessary one was specified; "Argument missing" if a necessary one wasn't.
		LDA	#$A		; "Invalid argument"
		DEX
		BEQ	loc_8D66
		LDA	#$20 ; ' '      ; "Argument missing"

loc_8D66:				
		JMP	loc_859D

loc_8D69:				
					
		TXA			; get 0	(no args entered) or 1 (args entered)
		BEQ	no_args_entered	; branch taken if no args entered
		LDA	byte_49		; get args byte
		AND	#2		; test bit 1 (single numeric arg)
		BEQ	loc_8D94	; branch taken if command wants	something else
; command wants single numeric argument
		JSR	atoi_from_command_line ; entry:	(byte_3E) points to command line;
					; exit:	C set if error,	or (byte_3E, byte_3F) holds result.
		BCC	skip_post_number_spaces
		LDA	#$B		; "Bad number"
		JMP	loc_859D

skip_post_number_spaces:		
					
		LDA	(byte_C),Y
		CMP	#32
		BNE	skipped_post_number_spaces
		INY
		BNE	skip_post_number_spaces

skipped_post_number_spaces:		
		CMP	#13		; end of command line after the	number?
		BEQ	loc_8D94	; branch taken if so
					;
					; (This	branch is wrong, I think, as 8D94...
					; keeps	scanning from (byte_3E), even
					; though that now contains the number.
					; It wants to go to got_command	instead.)
		LDA	#$C		; "Too many arguments"
		JMP	loc_859D

no_args_entered:			
		LDA	#$FF		; mark lack of args ($FF isn't the MSB of any valid number)
		STA	byte_3F
		BNE	got_command	; JMP, in effect

loc_8D94:				
					
		LDY	#0

find_end_of_command_line_loop:		
		LDA	(byte_3E),Y
		CMP	#$D
		BEQ	found_end_of_command_line
		INY
		BNE	find_end_of_command_line_loop

found_end_of_command_line:		
		DEY

find_end_of_last_argument_loop:		
		LDA	(byte_3E),Y
		CMP	#$20 ; ' '
		BNE	found_end_of_last_argument
		DEY
		JMP	find_end_of_last_argument_loop

found_end_of_last_argument:		
		INY
		STY	byte_6BE

got_command:				
		LDY	byte_39		; get index into table (currently pointing at args byte)
		INY
		LDA	($E),Y		; get command ID
		JMP	store_current_command
; End of function parse_command_line


                .if acornsoft_version
                .include "pres_bedit.itoa.s65"
                .include "pres_bedit.compare_cmd_char_to_input_char.s65"
                .include "pres_bedit.find_first_non_alpha_char.s65"
                .include "pres_bedit.memset.s65"
                .endif








osbyte_with_y0:.proc
					
		LDY	#0
		JSR	OSBYTE
                RTS
.pend
; End of function osbyte_with_y0



; print	number.
;
; Suitable for use with	the result of itoa.
;
; Entry:
; unk_0	= digit	count
; unk_1... = digits

print_number:				
					
		LDX	#1
		LDY	#0
		LDA	byte_0
		JSR	print_n_chars
		RTS
; End of function print_number



; move (maybe overlapping) memory regions.
;
; Entry:
; (byte_C) points to src
; (byte_E) points to dest
; X is MSB of size
; Y is LSB of size

memmove: .proc			
		LDA	byte_D		; get src MSB
		CMP	byte_F		; compare to dest MSB
		BCC	copy_down	; taken	if src<dest
		BEQ	copying_same_page ; taken if src MSB==dest MSB

copy_up:				
		TYA
		PHA			; save original	Y
		LDY	#0
		CPX	#0		; Any whole pages?
		BEQ	copy_up_last_page ; branch taken if no whole pages to copy

copy_up_pages_loop:			
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		INY
		BNE	copy_up_pages_loop ; branch taken if not copied	whole page yet
		INC	byte_D		; next src page
		INC	byte_F		; next dest page
		DEX			; one more page	done
		BNE	copy_up_pages_loop ; branch taken if not done all pages	yet

copy_up_last_page:			
		PLA
		TAX			; get original Y in X
		BNE	copy_up_last_page_loop ; branch	taken if any bytes to copy in last page
		RTS

copy_up_last_page_loop:			
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		INY
		DEX			; one more byte	done
		BNE	copy_up_last_page_loop ; branch	taken if not done all bytes yet
		RTS

copying_same_page:			
		LDA	byte_C		; get src LSB
		CMP	byte_E		; compare to dest LSB
		BCS	copy_up		; branch taken if src>=dest

copy_down:				
		TXA			; get page count
; Point src and dest at last page of each
		CLC
		ADC	byte_D
		STA	byte_D
		TXA
		CLC
		ADC	byte_F
		STA	byte_F
		CPY	#0		; any bytes to copy at the end?
		BEQ	copy_down_pages	; branch taken if no bytes to copy at the end

copy_down_last_page_loop:		
		DEY
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		CPY	#0		; was that the last byte just copied?
		BNE	copy_down_last_page_loop ; branch taken	if not on last byte

copy_down_pages:			
		CPX	#0		; any pages to copy?
		BEQ	memmove_done		; branch taken if no pages to copy

copy_down_pages_loop:			
		DEC	byte_D		; point	to last	whole page in src
		DEC	byte_F		; point	to last	whole page in dest

copy_down_page_loop:			
		DEY
		LDA	(byte_C),Y	; load from src...
		STA	(byte_E),Y	; store	to dest...
		CPY	#0		; was that the last byte just copied?
		BNE	copy_down_page_loop ; branch taken if not on last byte
		DEX			; one more page	done
		BNE	copy_down_pages_loop ; branch taken if more pages to copy

memmove_done:					
		RTS
; End of function memmove



.pend
gotoxy: .proc					
					
		LDA	#31		; set cursor location
		JSR	OSWRCH
		TXA
		JSR	OSWRCH
		TYA
		JMP	OSWRCH
; End of function gotoxy



.pend
print_n_chars .proc			
		STX	byte_C
		STY	byte_D
		TAX
		BEQ done
                LDY	#0
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		BEQ done
		CMP	#1
                BEQ start
		LDY	#$20 ; ' '

start:				
		STY	byte_3A
                LDY	#0

loop:
		LDA	($C),Y
		CMP	#$7F ; ''
                BEQ print_space
                pha
                lda screen_mode
                cmp #7
                beq mode7
                pla
                jmp check_char

mode7:
                pla
		CMP	#141
		BEQ print_space
                cmp #$ff
                beq print_space

check_char:
		CMP	byte_3A
		BCS print_char

print_space:				
					
		LDA	#$20 ; ' '

print_char				
		JSR	OSWRCH
		INY
		DEX
		BNE loop

done:
					
		RTS
                .endproc
; End of function print_n_chars

                .if acornsoft_version
                .include "pres_bedit.get_line_dimensions.s65"
                .include "pres_bedit.atoi_from_command_line.s65"
                .include "pres_bedit.execute_command.s65"
                .endif

clear_5B1_to_600:			
					
		LDA	#0
		STA	byte_15
		LDA	#<unk_5B1
		STA	byte_C
		LDA	#>unk_5B1
		STA	byte_D
		LDX	#0
		LDY	#$4F
		LDA	#$20
		JSR	memset		; Set memory to	value.
					;
					; ($C) points to memory	to clear.
					; X holds number of pages to clear.
					; Y holds number of bytes to clear in Xth page.
					; A holds value	to write.
		RTS
; End of function clear_5B1_to_600



; A = error code

get_error:				
					
		PHA
		LDA	byte_15		; already got an error?
		BEQ	copy_error	; taken	if no error yet
		PLA
		RTS

copy_error:				
		JSR	clear_5B1_to_600
		PLA
		STA	byte_15		; store	error code
		LDA	#<error_messages_table
		STA	byte_C
		LDA	#>error_messages_table
		STA	byte_D
		LDY	#0		; offset into errors table
		LDX	#0		; current error	index

find_error_loop:			
					
		LDA	($C),Y		; next byte from table
		BPL	loc_90C5	; taken	if still looking at the	current	error
; hit a negative char, so this means it's looking at the next error, so bump the error index.
		INX

loc_90C5:				
		CPX	byte_15		; reached the desired error?
		BEQ	found_error	; taken	if desired error reached
		INC	byte_C
		BNE	find_error_loop
		INC	byte_D
		BNE	find_error_loop

found_error:				
		LDX	#0

copy_error_loop:			
		AND	#$7F		; mask out top bit (in case)
		STA	unk_5B1,X	; store	in error message buffer
		INY			; next source byte...
		INX			; next dest byte...
		LDA	($C),Y		; load next byte from error table
		BPL	copy_error_loop	; taken	if haven't ended up in the next error
		RTS
; End of function get_error




find_command:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	byte_50
		PHA
		LDA	byte_51
		PHA
		LDX	byte_3F		; get MSB of pointer to	arg
		INX			; X=0 if it was	FF before
		BNE	got_search_string ; branch taken if pointer to arg appears valid
		JSR	get_search_string ; gets search	string.
					;
					; Exit:
					; (byte_3E) points to result
					; byte_6BE is length of	input excluding	final CR.
					; C set	if nothing entered.
		BCS	loc_912C

got_search_string:			
		LDY	byte_6BE
		STY	byte_62		; ?byte_62 = search string length

copy_search_string_loop:		
		DEY
		LDA	(byte_3E),Y
		STA	unk_643,Y
		CPY	#0
		BNE	copy_search_string_loop
		LDA	#0
		STA	byte_6AF
; point (byte_2B) at OSHWM
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_910F:				
		LDA	#0
		STA	byte_3B		; reset	"found anything" flag

loc_9113:				
		LDY	#1		; index	of MSB of line number
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	(byte_2B),Y	; fetch	MSB of line number
		BPL	line_valid	; branch taken if line appears valid
; reached end of program
		LDA	byte_3B		; was anything found?
		BEQ	loc_9122	; branch taken if nothing was found
		JMP	loc_91A6

loc_9122:				
		LDA	byte_6AF
		BNE	loc_912C
		LDA	#8		; "String not found"
		JSR	get_error	; A = error code

loc_912C:				
					
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JMP	language_entry.loc_814D

line_valid:				
		JSR	detokenize_one_line
		JSR	sub_9260
		BCC	loc_91A0
		LDY	byte_6AF
		BNE	loc_918A
		INY
		STY	byte_6AF
		JSR	enter_edit_mode
		LDA	current_command_id
                CMP	#CMD_EDIT ;was this EDIT?
                BNE	loc_918A  ;taken if not EDIT (i.e., FIND)
                
loc_9163:
                ; command was EDIT.
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	cls_and_reset_6c0_to_6ff
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069
		JSR	position_edit_mode_cursor
		JMP	edit_mode_loop

loc_918A:				

                ; command was FIND.
		LDA	byte_3B
		BNE	loc_9191
		JSR	cls_and_reset_6c0_to_6ff

loc_9191:				
		JSR	sub_9E5F
		BCC	loc_91A6
		JSR	sub_9E82
		CLC
		LDA	byte_3B
		ADC	byte_2D
		STA	byte_3B

loc_91A0:				
		JSR	advance_2b_to_next_line
		JMP	loc_9113

loc_91A6:				
					
		LDA	#0
		STA	byte_3B

loc_91AA:				
					
		LDX	#0
		LDY	byte_3B
		JSR	gotoxy
                JSR	find_mode_getch

		CMP	#$1B
		BNE	loc_91BB
		JMP	loc_912C

loc_91BB:				
		CMP	#$A7 ; -$59 ;	'§'
                bne loc_91C5
edit_found_line:
		JSR	sub_9247
		JMP	loc_9DA8

loc_91C5:				
		CMP	#$AF ; -$51 ;	'¯'
		BNE	loc_91E3
		LDA	byte_3B
		BNE	loc_91DE
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69
		TXA
		LSR
		STA	byte_3B
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30

loc_91DE:				
		DEC	byte_3B
		JMP	loc_91AA

loc_91E3:				
		CMP	#$AE
		BNE	loc_9203
		LDX	byte_3B
		INX
		CPX	screen_height
		BEQ	loc_91F5
		BCC	loc_91F5
		LDX	#0
		BEQ	loc_91FE

loc_91F5:				
					
		TXA
		ASL
		TAY
		LDA	$6C1,Y
		BNE	loc_91FE
		TAX

loc_91FE:				
					
		STX	byte_3B

loc_9200:				
		JMP	loc_91AA

loc_9203:				
		CMP	#$A5
		BNE	loc_920A
		JMP	loc_910F

loc_920A:				
		CMP	#$A2
		BNE	loc_9211
		JMP	top_edit_mode_command

loc_9211:				
		CMP	#$A3
		BNE	loc_9218
		JMP	end_edit_mode_command

loc_9218:				
		CMP	#$C1
		BNE	loc_922E
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	goto_edit_mode_command
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JMP	loc_91AA

loc_922E:				
		CMP	#$C0
		BNE	loc_9200
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_9247
		JSR	mark_edit_mode_command
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JMP	loc_91AA
; End of function find_command




sub_9247:				
					
		LDA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JMP	save_line_number ; saves line number from program.
; End of function sub_9247		;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number



advance_2b_to_next_line:		
					
		LDY	#3		; offset of line length
		CLC
		LDA	($2B),Y		; get line length
		ADC	byte_2B
		STA	byte_2B
		BCC	advance_2b_to_next_line_done
		INC	byte_2C

advance_2b_to_next_line_done:					
		RTS
                ; End of function advance_2b_to_next_line
                
; normalize_search_case .proc
;                 bit case_insensitive_search
;                 bpl done
;                 cmp #'a'
;                 bcc done
;                 cmp #1+'z'
;                 bcs done
;                 and #$df
; done:
;                 rts
; .pend
sub_9260 .proc			
					
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CMP	byte_400
		BEQ	loc_926B
		BCC	loc_926B

loc_9269:				
		CLC

locret_926A:				
		RTS

loc_926B:				
		CLC
		ADC	byte_6BE
		BCC	loc_9275
		CMP	#$26 ; '&'
		BCS	loc_9269

loc_9275:				
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		CLC
		ADC	#<byte_400
		STA	byte_C
                LDA	#0
		ADC	#>byte_400
		STA	byte_D

                ldx #0
                ldy #0

loc_9286:
                lda (byte_C,X)
                cmp (byte_3E),Y
                BNE	loc_929A
next_byte:
		INY
		INC	byte_C
		BNE	loc_9293
		INC	byte_D

loc_9293:				
		CPY	byte_6BE
		BCS	locret_926A
		BCC	loc_9286

loc_929A:				
		INC	cursor_offset	; offset of cursor in detokenized buffer
                BNE	sub_9260
.pend

change_or_qchange_command .proc	
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	byte_50
		PHA
		LDA	byte_51
		PHA
		LDX	byte_3F
		INX
		BEQ	loc_9308
		LDY	#0

loc_92B1:				
		LDA	($3E),Y
		CMP	#$20 ; ' '
		BEQ	loc_92C3
		CMP	#$D
		BEQ	loc_92BE
		INY
		BNE	loc_92B1

loc_92BE:				
		LDA	#$17

loc_92C0:				
		JMP	loc_859D

loc_92C3:				
		STY	byte_6BE

loc_92C6:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_92BE
		CMP	#$20 ; ' '
		BNE	loc_92D3
		INY
		BNE	loc_92C6

loc_92D3:				
		CLC
		TYA
		ADC	byte_3E
		STA	unk_6BA
		LDA	byte_3F
		ADC	#0
		STA	unk_6BB
		LDX	#0

loc_92E3:				
		LDA	($3E),Y
		CMP	#$20 ; ' '
		BEQ	loc_92F1
		CMP	#$D
		BEQ	loc_9302
		INX
		INY
		BNE	loc_92E3

loc_92F1:				
		LDA	($3E),Y
		CMP	#$D
		BEQ	loc_9302
		CMP	#$20 ; ' '
		BNE	loc_92FE
		INY
		BNE	loc_92F1

loc_92FE:				
		LDA	#$18
		BNE	loc_92C0

loc_9302:				
		STX	unk_6BC
		JMP	loc_932C

loc_9308:				
		JSR	get_search_string ; gets search	string.
					;
					; Exit:
					; (byte_3E) points to result
					; byte_6BE is length of	input excluding	final CR.
					; C set	if nothing entered.
		BCS	loc_9312
		JSR	get_replace_string
		BCC	loc_932C

loc_9312:				
					
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		RTS

loc_932C:				
		LDA	#0
		STA	byte_6AF
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_9337:				
		LDY	#0
		STY	byte_6B3
		STY	unk_11
		INY
		STY	cursor_offset	; offset of cursor in detokenized buffer
		LDA	($2B),Y
		BMI	loc_9369
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line

loc_934B:				
					
		JSR	sub_9260
		BCS	loc_9359
		JSR	sub_93CF
		JSR	advance_2b_to_next_line
		JMP	loc_9337

loc_9359:				
		LDA	current_command_id
		STA	byte_6AF
		CMP	#$E2
		BEQ	loc_937E
		JSR	sub_BDD3
		JMP	loc_934B

loc_9369:				
		LDA	byte_6AF
		BNE	loc_9312
		PLA
		PLA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		LDA	#8
		JSR	get_error	; A = error code

loc_937B:				
		JMP	language_entry.loc_814D

loc_937E:				
		LDA	editor_mode_id	; 1=command mode, 2=edit mode
		CMP	#2
		BEQ	loc_9388
		JSR	enter_edit_mode

loc_9388:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	#0
		STA	byte_3B
		CLC
		JSR	sub_9DEA
		LDX	#1
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	sub_A069
		JSR	position_edit_mode_cursor

loc_93A9:				
		JSR	find_mode_getch
		CMP	#$1B
		BEQ	loc_937B
		CMP	#$A7
		BNE	loc_93B7
		JMP	edit_mode_loop

loc_93B7:				
		AND	#$DF
		CMP	#'Y'
		BNE	loc_93C6
		JSR	sub_BDD3
		JSR	sub_93CF
		JMP	loc_934B

loc_93C6:				
		CMP	#'N'
		BNE	loc_93A9
		INC	cursor_offset	; offset of cursor in detokenized buffer
		JMP	loc_934B
; End of function sub_9260




sub_93CF:				
					
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	sub_A8C0
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
                RTS
.pend
; End of function sub_93CF


                .if acornsoft_version
                .include "pres_bedit.commands.load.s65"
                .include "pres_bedit.read_line.s65"
                .endif




reset_keys_settings:			
					
		LDX	#0		; Enable cursor	editing	(default)
		LDA	#4		; Enable/disable cursor	editing	(AUG P120)
		JSR	OSBYTE
		LDX	#9
		LDA	#219		; set TAB key to 9
		JSR	osbyte_with_y0
		JSR	kbflush
		LDX	#1
		LDA	#225		; reset	F key status?
		JSR	osbyte_with_y0
		LDX	#128
		LDA	#226		; reset	Shift+F	key status?
		JSR	osbyte_with_y0
		LDX	#0
		LDA	#227
		JMP	osbyte_with_y0
; End of function reset_keys_settings




run_star_command:			
		LDX	#7
		JSR	validate_mode.get_HIMEM_for_mode_X
		JSR	reset_keys_settings
		LDX	#0
		LDY	#7
		JSR	OSCLI
		JMP	clear_5B1_to_600
; End of function run_star_command




getch:					
					
		JSR	OSRDCH
; End of function getch




clear_escape_condition:			
		PHA
		LDA	#$7E ; '~'
		JSR	OSBYTE
		PLA
; End of function clear_escape_condition

		RTS

                .if acornsoft_version
                .include "pres_bedit.command_jump_table.s65"
                .include "pres_bedit.967A.s65"
                .include "pres_bedit.commands.tab_key.s65"
                .include "pres_bedit.commands.continue_edit_mode.s65"
                .include "pres_bedit.commands.split_statement.s65"
                .include "pres_bedit.commands.renumber.s65"
                .include "pres_bedit.edit_mode_loop.s65"
                .include "pres_bedit.detokenize_one_line.s65"
                .include "pres_bedit.enter_edit_mode.s65"
                .include "pres_bedit.9DEA.s65"
                .include "pres_bedit.find_line_by_number.s65"
                .include "pres_bedit.get_line_height.s65"
                .endif

set_palette:				
					
		LDX	#0		; set colour 0
		LDY	background_colour ; get	BACK colour
                JSR	set_palette_entry ; X=logical colour, Y=physical colour
                inx                       ; set colour 1
                lda screen_mode
                cmp #1
                bne L9EE5
                ldx #3
L9EE5:
                ldy foreground_colour

set_palette_entry:			
		LDA	#19		; X=logical colour, Y=physical colour
		JSR	OSWRCH
		TXA
		JSR	OSWRCH
		TYA
		JSR	OSWRCH
		LDA	#0
		JSR	OSWRCH
		JSR	OSWRCH
                JSR	OSWRCH
set_palette_done:
		RTS
; End of function set_palette




sub_9F00:				
		JSR	make_cursor_invisible
		LDA	#1
		LDX	unk_8
		LDY	unk_9
		JSR	sub_A0B1
		LDX	#0
		STX	byte_36

loc_9F10:				
		LDX	#0
		CLC
		LDA	byte_36
		BEQ	loc_9F26
		ADC	byte_3B
		TAY
		JSR	gotoxy
		LDX	#<six_spaces_string
		LDY	#>six_spaces_string
		LDA	#6
		JSR	print_n_chars

loc_9F26:				
		INC	byte_36
		LDA	byte_36
		CMP	byte_2D
		BNE	loc_9F10
		JMP	redraw_line_number
; End of function sub_9F00

                .if acornsoft_version
                .include "pres_bedit.execute_key_command.s65"
                .include "pres_bedit.9FD8.s65"
                .include "pres_bedit.A069.s65"
                .endif












sub_A0B1:				
		CPX	#0
		BNE	loc_A0B6
		RTS

loc_A0B6:				
		STA	byte_28
		DEC	byte_28
		STY	byte_27
		DEX
		STX	byte_26
		JSR	make_cursor_invisible
		LDA	#$FF
		STA	byte_24
		STA	byte_23
		LDA	#0
		SEC
		SBC	code_area_width
		STA	byte_25

loc_A0D0:				
		CLC
		LDA	byte_25
		ADC	code_area_width
		STA	byte_25
		CLC
		LDA	byte_23
		ADC	code_area_width
		STA	byte_23
		BCC	loc_A0E4
		INC	byte_24

loc_A0E4:				
		LDA	#1
		STA	byte_20
		LDA	#4
		STA	byte_21
; (byte_20) points at detokenized line
		LDA	byte_24
		BNE	loc_A0F8
		LDA	byte_28
		CMP	byte_23
		BEQ	loc_A0F8
		BCS	loc_A0D0

loc_A0F8:				
		LDA	byte_28
		CMP	byte_25
		BCS	loc_A100
		LDA	byte_25

loc_A100:				
		STA	byte_22
		CLC
		ADC	byte_20
		STA	byte_20
		BCC	loc_A10B
		INC	byte_21

loc_A10B:				
		LDA	byte_27
		BNE	loc_A115
		LDA	byte_26
		CMP	byte_25
		BCC	locret_A16C

loc_A115:				
		LDX	#0
		LDA	byte_27
		CMP	byte_24
		BEQ	loc_A121
		BCS	loc_A129
		BCC	loc_A127

loc_A121:				
		LDA	byte_26
		CMP	byte_23
		BCS	loc_A129

loc_A127:				
		LDX	#3

loc_A129:				
		SEC
		LDA	byte_23,X
		SBC	byte_22
		CLC
		ADC	#1
		PHA
		LDX	byte_22
		LDY	#0
		JSR	get_line_dimensions ; work out dimensions of line.
					;
					; Entry:
					; X=line length
					; Y=starting Y
					;
					; Exit:
					; X=line length	MOD screen width
					; Y=ending Y
		CLC
		TXA			; get X	coordinate
		ADC	#6		; offset by line numbers width
		TAX			; back in X
		CLC
		TYA			; get Y	coordinate
		ADC	byte_3B		; add base Y
		TAY			; back in Y
		JSR	gotoxy		; positino cursor
		LDA	byte_3B		; get screen Y
		ASL
		TAX
		LDA	$6C0,X
		PHA
		LDA	$6C1,X
		PHA
		TYA
		ASL
		TAX
		PLA
		STA	$6C1,X
		PLA
		STA	$6C0,X
		PLA
		LDX	byte_20
		LDY	byte_21
		JSR	print_n_chars
		LDA	byte_24
		BNE	locret_A16C
		JMP	loc_A0D0

locret_A16C:				
		RTS
; End of function sub_A0B1


                .if acornsoft_version
                .include "pres_bedit.redraw_line_number.s65"
                .include "pres_bedit.token_table.s65"
                .include "pres_bedit.commands.toggle_insert_overtype.s65"
                .include "pres_bedit.commands.cursor_stuff.s65"
                .include "pres_bedit.A8C0.s65"
                .include "pres_bedit.AA06.s65"
                .include "pres_bedit.AA41.s65"
                .include "pres_bedit.commands.delete_stuff.s65"
                .include "pres_bedit.AB1E.s65"
                .include "pres_bedit.rstrip_and_cr_terminate_detokenized_line.s65"
                .include "pres_bedit.AC08.s65"
                .include "pres_bedit.commands.execute_edit_mode.s65"
                .include "pres_bedit.AD39.s65"
                .include "pres_bedit.AEB9.s65"
                .endif




return_key_command:			
		LDA	#0
		PHA

loc_AF54:				
		LDA	byte_3B
		ASL
		TAX
		INX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented

loc_AF5C:				
		JSR	advance_2b_to_next_line
		LDY	#2
		LDA	($2B),Y
		STA	byte_38
		DEY
		LDA	($2B),Y
		STA	unk_37
		BPL	loc_AF70
		LDA	#$A
		BNE	loc_AF72

loc_AF70:				
		LDA	#1

loc_AF72:				
		TAY
		CLC
		ADC	current_line_no_msb
		STA	byte_3A
		LDA	#0
		ADC	current_line_no_lsb
		STA	byte_39
		BPL	loc_AF8C
		DEY
		BNE	loc_AF70

loc_AF83:				
		JSR	sub_8492
		PLA
		LDA	#1
		PHA
		BNE	loc_AF54

loc_AF8C:				
		LDX	byte_39
		LDY	byte_3A
		CPX	unk_37
		BNE	loc_AF9A
		CPY	byte_38
		BNE	loc_AF9A
		BEQ	loc_AF83

loc_AF9A:				
		PLA
		STA	byte_36
		TXA
		PHA
		TYA
		PHA
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	byte_36
		PHA
		STX	current_line_no_lsb
		STY	current_line_no_msb
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		LDA	#1
		STA	byte_400
		LDA	#$20 ; ' '
		STA	unk_401

loc_AFBB:				
		STX	byte_36
		LDA	byte_6B3
		PHA
		LDA	#1
		STA	byte_6B3
		LDA	#-1
		STA	byte_2C
		LDA	#1
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		JSR	sub_A8C0
		LDA	#2
		STA	editor_mode_id	; 1=command mode, 2=edit mode
		PLA
		STA	byte_6B3
		PLA
		BEQ	loc_AFE9
		CMP	#1
		BEQ	loc_B03B
		CMP	#3
		BNE	loc_B01B
		JMP	end_edit_mode_command

loc_AFE9:				
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA
		CLC
		ADC	byte_3B
		ADC	byte_36
		SEC
		SBC	#1
		CMP	screen_height
		BEQ	loc_B025
		BCC	loc_B025
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		PLA
		PLA
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line

loc_B00D:				
		LDA	scroll_status	; 1=scroll, 0=noscroll
		PHA
		LDA	#1
		STA	scroll_status	; 1=scroll, 0=noscroll
		JSR	ctrl_cursor_right_edit_mode_command
		PLA
		STA	scroll_status	; 1=scroll, 0=noscroll
		RTS

loc_B01B:				
		JSR	cls_and_reset_6c0_to_6ff
		LDA	#0
		STA	byte_3B
		CLC
		BCC	loc_B026

loc_B025:				
		SEC

loc_B026:				
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JSR	sub_9FD8
		JMP	edit_mode_loop

loc_B03B:				
		PLA
		PLA
		PLA
		TAX
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		PHA
		TXA
		PHA
		JSR	sub_9698
		BCS	loc_B05C

loc_B04C:				
		JSR	sub_9706
		SEC
		JSR	sub_9DEA
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		JMP	sub_9FD8

loc_B05C:				
		JSR	sub_AA47
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JMP	loc_B04C

it_cmd:					
		JSR	sub_B0A3
		LDY	#1
		LDA	($17),Y
		BNE	loc_B07F
		INY
		LDA	($17),Y
		CMP	#2
		BCS	loc_B07F
		JSR	sub_8492

loc_B07F:				
		LDA	#2
		PHA
		LDX	#0
		LDY	#1
		STX	current_line_no_lsb
		STY	current_line_no_msb
		JMP	loc_AF9A

ie_cmd:					
		JSR	sub_B0A3
		LDA	#3
		PHA
		LDA	#-1
		STA	byte_2B
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	loc_AF5C



sub_B0A3:				
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_B0A9
		RTS

loc_B0A9:				
		JMP	loc_9DA8
; End of function sub_B0A3


                .if acornsoft_version
                .include "pres_bedit.B0AC.s65"
                .endif

mode_command:
                lda screen_mode
                pha
                ldy byte_3F
                beq loc_B304

loc_B2FF:				
		LDA	#$D		; "Only	modes 0,1,3,4,6,7 are valid"
		JMP	loc_859D

loc_B304:				
		LDY	byte_3E
                cpy #2
                beq loc_B2FF
                cpy #5
                beq loc_B2FF
                cpy #8
                bcs loc_B2FF
                sty screen_mode
		JSR	validate_mode
		JSR	find_program
                pla
		LDX	byte_15
		BEQ	locret_B329
                sta screen_mode
		JSR	clear_5B1_to_600
		LDA	#$E		; "No room for this mode"
		JMP	loc_859D

locret_B329:
		RTS
; End of function mode_command


mode_edit_mode_command:			
                LDY	screen_mode
                

loc_B32C:				
		DEY
		CPY	#2
		BEQ	loc_B32C
		CPY	#5
		BEQ	loc_B32C
		CPY	#-1
		BNE	loc_B33B
		LDY	#7

loc_B33B:				
		STY	screen_mode
		JSR	validate_mode
		JSR	find_program
		LDA	byte_15
		BEQ	loc_B34A
		JMP	language_entry.loc_814D

loc_B34A:				
		JSR	loc_9D2D
		JSR	is_program_empty ; sets	C if no	program
		BCS	loc_B355
		JMP	loc_967A

loc_B355:				
		JMP	loc_9DA8



sub_B358:				
					
		LDA	#$FF
		STA	unk_4D
		RTS
; End of function sub_B358




mark_edit_mode_command:			
					
		LDA	current_line_no_lsb
		STA	unk_4D
		LDA	current_line_no_msb
		STA	unk_4E
		JMP	loc_AC08
; End of function mark_edit_mode_command




goto_edit_mode_command:			
					
		JSR	sub_B37B
		BEQ	loc_B370
		JMP	beep

loc_B370:				
					
		LDA	unk_4D
		STA	current_line_no_lsb
		LDA	unk_4E
		STA	current_line_no_msb
		JMP	loc_9DA8
; End of function goto_edit_mode_command




sub_B37B:				
					
		LDA	unk_4D
		CMP	#-1
		BNE	loc_B384
		LDA	#1
		RTS

loc_B384:				
		STA	byte_2B
		LDA	unk_4E
		STA	byte_2C
		JSR	find_line_by_number ; finds a line, given a line number
					;
					; Entry:
					; byte_2B: line	number MSB
					; byte_2C: line	number LSB
					;
					; Exit:
					; (byte_2B) points to most suitable line
		LDY	#1
		LDA	($2B),Y
		CMP	unk_4D
		BNE	locret_B39A
		INY
		LDA	($2B),Y
		CMP	unk_4E

locret_B39A:				
		RTS
; End of function sub_B37B


goto_command:				
		JSR	sub_B37B
		BNE	loc_B3A6
		JSR	enter_edit_mode
		JMP	loc_B370

loc_B3A6:				
		LDA	#$22 ; '"'
		JMP	loc_859D

number_command:				
		LDA	current_line_no_lsb
		PHA
		LDA	current_line_no_msb
		PHA
		LDA	#0
		STA	unk_1E
		STA	byte_2B
		LDA	oshwm+1
		STA	byte_2C

loc_B3BB:				
		LDY	#1
		LDA	($2B),Y
		BPL	loc_B3DB
		PLA
		STA	current_line_no_msb
		PLA
		STA	current_line_no_lsb
		LDA	unk_1E
		AND	#1
		BEQ	loc_B3D2
		LDA	#$10

loc_B3CF:				
		JMP	loc_859D

loc_B3D2:				
		LDA	unk_1E
		BNE	locret_B3DA
		LDA	#$F
		BNE	loc_B3CF

locret_B3DA:				
		RTS

loc_B3DB:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	byte_2B
		STA	byte_C
		LDA	byte_2C
		STA	byte_D
		LDA	#0
		STA	byte_E
		LDA	#5
		STA	byte_F
		LDX	#0
		LDY	#3
		LDA	($2B),Y
		TAY
		INY
		BNE	loc_B3F9
		INX

loc_B3F9:				
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDX	#0
		STX	unk_11
		STX	unk_37
		STX	byte_36
		STX	byte_6B3
		INX
		STX	cursor_offset	; offset of cursor in detokenized buffer
		LDA	#4
		STA	unk_1F
		LDA	#5
		STA	byte_20

loc_B412:				
		SEC
		LDA	unk_503
		SBC	#4
		CMP	cursor_offset	; offset of cursor in detokenized buffer
		BCC	loc_B476
		LDY	#0
		LDA	($1F),Y
		CMP	#$20 ; ' '
		BEQ	loc_B461
		CMP	#$22 ; '"'
		BNE	loc_B430
		STA	byte_36
		LDA	unk_37
		EOR	#1
		STA	unk_37

loc_B430:				
		LDA	unk_37
		BNE	loc_B461
		LDA	($1F),Y
		CMP	#$f4 ;-$C ; 'ô' REM
		BEQ	loc_B476
		CMP	#$DC ; -$24 ;	'Ü' DATA
		BEQ	loc_B476
		CMP	#$2A ; '*'
		BNE	loc_B446
		LDX	byte_36
		BEQ	loc_B476

loc_B446:				
		CMP	#$3A ; ':'
		BNE	loc_B44E
		STY	byte_36
		BEQ	loc_B461

loc_B44E:				
		LDX	#1
		STX	byte_36
		CMP	#$8D ; -$73 ;	'' line number
		BNE	loc_B45A
		LDX	#4
		BNE	loc_B463

loc_B45A:				
		CMP	#$40 ; '@'
		BNE	loc_B461
		JMP	loc_B4B7

loc_B461:				
		LDX	#1

loc_B463:				
		CLC
		TXA
		ADC	unk_1F
		STA	unk_1F
		BCC	loc_B46D
		INC	byte_20

loc_B46D:				
		CLC
		TXA
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		JMP	loc_B412

loc_B476:				
		LDA	byte_6B3
		BEQ	loc_B47E
		JSR	sub_B4A7

loc_B47E:				
		JSR	advance_2b_to_next_line
		JMP	loc_B3BB


sub_B484:				
		CMP	#'0'
		BCC	loc_B49C
		CMP	#':'
		BCC	loc_B49E
		CMP	#'A'
		BCC	loc_B49C
		CMP	#'['
		BCC	loc_B49E
		CMP	#'_'
		BCC	loc_B49C
		CMP	#'{'
		BCC	loc_B49E

loc_B49C:				
		CLC
		RTS

loc_B49E:				
		SEC
		RTS
; End of function sub_B484




sub_B4A0:				
		LDY	#1
		LDA	($C),Y
		JMP	sub_B484
; End of function sub_B4A0




sub_B4A7:				
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	loc_A8FF
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		RTS
; End of function sub_B4A7


loc_B4B7:				
		LDA	unk_1F
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		JSR	sub_B4A0
		BCS	loc_B4C7

loc_B4C4:				
		JMP	loc_B461

loc_B4C7:				
		LDA	#0
		STA	unk_33
		LDA	oshwm+1
		STA	unk_34

loc_B4CF:				
		LDY	#1
		LDA	($33),Y
		BPL	loc_B4DD
		LDA	unk_1E
		ORA	#1
		STA	unk_1E
		BNE	loc_B4C4

loc_B4DD:				
		LDA	unk_33
		PHA
		LDA	unk_34
		PHA
		LDY	#4

loc_B4E5:				
		LDA	($33),Y
		CMP	#$20 ; ' '
		BNE	loc_B4EF
		INY
		JMP	loc_B4E5

loc_B4EF:				
		CMP	#$F4 ; -$C ; 'ô'
		BNE	loc_B52F
		INY

loc_B4F4:				
		LDA	($33),Y
		CMP	#$20 ; ' '
		BNE	loc_B4FE
		INY
		JMP	loc_B4F4

loc_B4FE:				
		CLC
		TYA
		ADC	unk_33
		STA	unk_33
		BCC	loc_B508
		INC	unk_34

loc_B508:				
		LDY	#0
		LDA	($33),Y
		CMP	#$40 ; '@'
		BEQ	loc_B512
		BNE	loc_B52F

loc_B512:				
		INY

loc_B513:				
		LDA	($33),Y
		CMP	($1F),Y
		BNE	loc_B521
		JSR	sub_B484
		BCC	loc_B532
		INY
		BNE	loc_B513

loc_B521:				
		JSR	sub_B484
		BCS	loc_B52F
		LDA	($1F),Y
		JSR	sub_B484
		BCS	loc_B52F
		BCC	loc_B532

loc_B52F:				
		CLC
		BCC	loc_B533

loc_B532:				
		SEC

loc_B533:				
		PLA
		STA	unk_34
		PLA
		STA	unk_33
		BCS	loc_B53E
		JMP	loc_B5A3

loc_B53E:				
		STY	byte_35
		LDA	unk_503
		SEC
		SBC	byte_35
		CLC
		ADC	#4
		BCS	loc_B59E
		STA	unk_503
		CLC
		LDA	unk_1F
		ADC	byte_35
		STA	byte_C
		LDA	byte_20
		STA	byte_D
		STA	byte_F
		CLC
		LDA	unk_1F
		ADC	#4
		STA	byte_E
		SEC
		LDA	unk_503
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SEC
		SBC	#6
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDY	#1
		LDA	($33),Y
		TAX
		INY
		LDA	($33),Y
		TAY
		JSR	sub_85D8
		PHA
		TYA
		LDY	#3
		STA	($1F),Y
		DEY
		TXA
		STA	($1F),Y
		DEY
		PLA
		STA	($1F),Y
		DEY
		LDA	#$8d ; -$73 ;	''
		STA	($1F),Y
		STA	byte_6B3
		LDA	unk_1E
		ORA	#2
		STA	unk_1E
		LDX	#4
		JMP	loc_B463

loc_B59E:				
		LDA	#$11
		JMP	loc_859D

loc_B5A3:				
		LDY	#3
		CLC
		LDA	($33),Y
		ADC	unk_33
		STA	unk_33
		BCC	loc_B5B0
		INC	unk_34

loc_B5B0:				
		JMP	loc_B4CF

                .if acornsoft_version
                .include "pres_bedit.commands.label.s65"
                .endif





sub_B7A1:				
					
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	loc_B7AB
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_B7B7
		RTS

loc_B7AB:				
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_B7B2
		JMP	loc_B89A

loc_B7B2:				
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_B7BA

loc_B7B7:				
		JMP	edit_mode_loop

loc_B7BA:				
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		LDA	#0
		STA	byte_2B
		STA	byte_2C
		STA	byte_36
		JSR	sub_BA69
		TXA
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		TAX
		LDA	$6BF,X
		CMP	byte_2C
		BNE	loc_B7DD
		LDA	$6BE,X
		CMP	byte_2B
		BNE	loc_B7DD
		INC	byte_36

loc_B7DD:				
		LDY	#3
		CLC
		LDA	byte_2B
		ADC	($2B),Y
		STA	byte_C
		LDA	byte_2C
		ADC	#0
		STA	byte_D
		LDY	#1
		LDA	($C),Y
		BMI	loc_B7B7
		LDA	byte_2D
		STA	unk_34
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		STX	unk_37
		STX	byte_35
		LDA	byte_2B
		PHA
		LDA	byte_2C
		PHA
		JSR	advance_2b_to_next_line
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		JSR	sub_A01E
		CLC
		LDA	byte_2D
		ADC	unk_37
		ADC	byte_3B
		SEC
		SBC	#1
		SEC
		SBC	screen_height
		STA	unk_37
		BEQ	loc_B826
		BPL	loc_B829

loc_B826:				
		JMP	loc_B82C

loc_B829:				
		JSR	sub_B8BD

loc_B82C:				
		LDA	unk_37
		BEQ	loc_B832
		BPL	loc_B85D

loc_B832:				
		LDA	byte_36
		BNE	loc_B85D
		LDA	byte_6B3
		BEQ	loc_B852
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		LDX	unk_34
		JSR	loc_A021
		JSR	sub_AA17
		JMP	loc_B89D

loc_B852:				
		LDA	byte_35
		CMP	unk_34
		BNE	loc_B880

loc_B858:				
		PLA
		PLA
		JMP	loc_B89D

loc_B85D:				
		LDA	byte_6B3
		BEQ	loc_B880
		PLA
		STA	byte_2C
		PLA
		STA	byte_2B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		LDA	byte_3B
		PHA
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B
		JMP	loc_B89D

loc_B880:				
		CLC
		LDA	byte_3B
		PHA
		ADC	byte_35
		STA	byte_3B
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		SEC
		JSR	sub_9DEA
		PLA
		STA	byte_3B
		JMP	loc_B858

loc_B89A:				
		JSR	sub_AA06

loc_B89D:				
		LDA	byte_3B
		ASL
		TAX
		INX
		LDY	$6C0,X
		BNE	loc_B8AE
		DEY
		STY	current_line_no_lsb
		STY	current_line_no_msb
		BNE	loc_B8BA

loc_B8AE:				
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		INC	current_line_no_msb
		BNE	loc_B8BA
		INC	current_line_no_lsb

loc_B8BA:				
					
		JMP	sub_A069
; End of function sub_B7A1




sub_B8BD:				
		SEC
		LDA	unk_37
		SBC	#1
		ASL
		TAX
		TAY

loc_B8C5:				
		INY
		INY
		LDA	$6C0,X
		CMP	$6C0,Y
		BNE	loc_B8DB
		LDA	$6C1,X
		CMP	$6C1,Y
		BNE	loc_B8DB
		INC	unk_37
		BNE	loc_B8C5

loc_B8DB:				
		CLC
		TYA
		ADC	#-$40 ;	'À'
		STA	byte_C
		LDA	#6
		STA	byte_F
		ADC	#0
		STA	byte_D
		LDA	#-$40 ;	'À'
		STA	byte_E
		CLC
		LDA	screen_height
		ADC	#1
		SEC
		SBC	unk_37
		ASL
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		JSR	make_cursor_invisible
		LDX	#0
		LDY	screen_height
		STY	byte_6AB
		JSR	gotoxy
		LDA	#$13
		JSR	OSBYTE
		LDY	unk_37
		LDA	#$A

loc_B914:				
		JSR	OSWRCH
		DEY
		BNE	loc_B914
		SEC
		LDA	byte_3B
		SBC	unk_37
		STA	byte_3B
		RTS
; End of function sub_B8BD

                .if acornsoft_version
                .include "pres_bedit.commands.join_statements.s65"
                .endif





sub_BA69:				
					
		LDA	screen_height
		ASL
		STA	byte_3A
		LDX	#0

loc_BA71:				
		LDA	$6C0,X
		CMP	byte_2B
		BNE	loc_BA82
		INX
		LDA	$6C0,X
		CMP	byte_2C
		BNE	loc_BA83
		DEX
		RTS

loc_BA82:				
		INX

loc_BA83:				
		INX
		CPX	byte_3A
		BEQ	loc_BA71
		BCC	loc_BA71
		RTS
; End of function sub_BA69

                .if acornsoft_version
                .include "pres_bedit.commands.back.fore.insert.overtype.s65"
                .include "pres_bedit.commands.help.s65"
                .include "pres_bedit.commands.goto.s65"
                .include "pres_bedit.commands.info.s65"
                .endif

sub_BDD3:				
					
		LDA	byte_3E
		PHA
		LDA	byte_3F
		PHA
		LDA	unk_6BA
		STA	byte_3E
		LDA	unk_6BB
		STA	byte_3F
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	byte_6BE
		BCS	loc_BDF5
		SEC
		SBC	#1
		CMP	byte_400
		BEQ	loc_BE09
		BCC	loc_BE09

loc_BDF5:				
		CLC
		LDA	cursor_offset	; offset of cursor in detokenized buffer
		ADC	unk_6BC
		BCS	loc_BE23
		SEC
		SBC	#1
		CMP	#-4 ; 'ü'
		BCS	loc_BE23
		STA	byte_400
		BCC	loc_BE57

loc_BE09:				
		SEC
		LDA	unk_6BC
		SBC	byte_6BE
		STA	unk_6AE
		CLC
		ADC	byte_400
		PHA
		LDY	unk_6AE
		BMI	loc_BE2B
		BCS	loc_BE23
		CMP	#-4 ; 'ü'
		BCC	loc_BE2B

loc_BE23:				
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		LDA	#$25 ; '%'
		JMP	loc_859D

loc_BE2B:				
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		ADC	byte_6BE
		STA	byte_C
		ADC	unk_6AE
		STA	byte_E
		LDA	#4
		STA	byte_D
		STA	byte_F
		LDX	#0
		CLC
		LDA	byte_400
		ADC	#1
		SEC
		SBC	cursor_offset	; offset of cursor in detokenized buffer
		SEC
		SBC	byte_6BE
		TAY
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		PLA
		STA	byte_400

loc_BE57:				
		LDA	byte_3E
		STA	byte_C
		LDA	byte_3F
		STA	byte_D
		CLC
		LDA	#0
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_E
		LDA	#4
		STA	byte_F
		LDX	#0
		LDY	unk_6BC
		CLC
		TYA
		ADC	cursor_offset	; offset of cursor in detokenized buffer
		STA	cursor_offset	; offset of cursor in detokenized buffer
		STA	byte_6B3
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		PLA
		STA	byte_3F
		PLA
		STA	byte_3E
                RTS
; End of function sub_BDD3




find_mode_getch:				
					
		JSR	kbflush
		LDA	is_insert_mode	; 0=overtype 1=insert
		PHA
		LDA	#1
		STA	is_insert_mode	; 0=overtype 1=insert
		JSR	reset_cursor_shape
		PLA
		STA	is_insert_mode	; 0=overtype 1=insert
		JSR	getch
		JMP	make_cursor_invisible
; End of function find_mode_getch




sub_BE98:				
		JSR	is_line_empty	; determines whether current line is empty.
					;
					; Entry:
					; detokenized line at $400...
					;
					; Exit:
					; C set	if line	empty.
		BCC	loc_BEA2
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_BEB2
		RTS

loc_BEA2:				
		LDA	scroll_status	; 1=scroll, 0=noscroll
		BNE	loc_BEA9

loc_BEA6:				
		JMP	loc_BFBB

loc_BEA9:				
		LDA	byte_3B
		BNE	loc_BEA6
		JSR	is_program_empty ; sets	C if no	program
		BCC	loc_BEB5

loc_BEB2:				
		JMP	edit_mode_loop

loc_BEB5:				
		JSR	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		LDA	unk_30
		BEQ	loc_BEB2
		JSR	make_cursor_invisible
		LDA	byte_2D
		STA	byte_35
		JSR	sub_A8C0
		JSR	get_line_height	; get height of	current	line
					;
					; Entry:
					; ?byte_400 = line length
					;
					; Exit:
					; X = line height
		TXA
		SEC
		SBC	byte_35
		STA	byte_35
		LDA	unk_8
		PHA
		LDA	unk_9
		PHA
		JSR	find_current_line_by_number ; finds current line by number.
					;
					; Entry:
					; current_line_no_lsb,
					; current_line_no_msb =	line number to search for
					;
					; Exit:
					; (byte_2B) points to line found
		JSR	sub_AA77	; swap byte_2B with unk_2F, swap byte_2C with unk_30
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JSR	detokenize_one_line
		JSR	sub_A01E
		LDX	#0
		LDY	#0
		JSR	gotoxy
		LDA	#19
		STA	byte_6AB
		JSR	OSBYTE
		LDY	byte_2D
		LDA	#11

loc_BEF7:				
		JSR	OSWRCH
		DEY
		BNE	loc_BEF7
		LDA	byte_35
		BEQ	loc_BF04
		JMP	loc_BF5B

loc_BF04:				
		SEC
		LDA	screen_height
		SBC	byte_2D
		STA	byte_36
		INC	byte_36

loc_BF0E:				
		LDA	byte_36
		ASL
		TAX
		TAY
		INX
		LDA	$6C0,X
		BEQ	loc_BF5B
		DEY
		CMP	$6C0,Y
		BNE	loc_BF4F
		DEX
		DEY
		LDA	$6C0,X
		CMP	$6C0,Y
		BNE	loc_BF4F
		LDA	#0
		STA	$6C0,X
		STA	$6C1,X
		DEC	byte_36
		CLC
		LDA	byte_36
		ADC	byte_2D
		TAY
		LDX	#0
		JSR	gotoxy
		CLC
		LDA	code_area_width
		ADC	#6
		TAY
		LDA	#$20 ; ' '

loc_BF47:				
		JSR	OSWRCH
		DEY
		BNE	loc_BF47
		BEQ	loc_BF0E

loc_BF4F:				
		LDA	byte_36
		ASL
		TAX
		LDA	#0
		STA	$6C0,X
		STA	$6C1,X

loc_BF5B:				
		LDA	byte_2D
		ASL
		STA	byte_E
		LDA	#6
		STA	byte_D
		STA	byte_F
		LDA	#-$40 ;	'À'
		STA	byte_C
		CLC
		ADC	byte_E
		STA	byte_E
		BCC	loc_BF73
		INC	byte_F

loc_BF73:				
		CLC
		LDA	screen_height
		ADC	#1
		SEC
		SBC	byte_2D
		ASL
		TAY
		LDX	#0
		JSR	memmove		; move (maybe overlapping) memory regions.
					;
					; Entry:
					; (byte_C) points to src
					; (byte_E) points to dest
					; X is MSB of size
					; Y is LSB of size
		LDA	byte_2B
		STA	byte_6C0
		LDA	byte_2C
		STA	byte_6C1
		JSR	sub_9F00
		JSR	advance_2b_to_next_line
		LDA	byte_2D
		STA	byte_3B
		ASL
		TAX
		LDA	byte_2B
		STA	$6C0,X
		LDA	byte_2C
		STA	$6C1,X
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		PLA
		STA	unk_9
		PLA
		STA	unk_8
		LDA	byte_6B3
		BNE	loc_BFB5
		LDA	byte_35
		BEQ	loc_BFBE

loc_BFB5:				
		JSR	sub_AA17
		JMP	loc_BFBE

loc_BFBB:				
		JSR	sub_AA06

loc_BFBE:				
					
		LDA	byte_3B
		ASL
		TAX
		BNE	loc_BFCB
		STA	byte_2B
		STA	byte_2C
		JSR	sub_BA69

loc_BFCB:				
		DEX
		JSR	get_line_ptr	; gets pointer to line visible on screen.
					;
					; Entry:
					; X = screen line number * 2 + 1
					;
					; Exit:
					; (byte_2B) points to BASIC line
					; X decremented
		JSR	sub_BA69
		TXA
		LSR
		STA	byte_3B
		JSR	save_line_number ; saves line number from program.
					;
					; Entry:
					; (byte_2b) points to current line
					;
					; Exit:
					; current_line_no_lsb, current_line_no_msb = the line number
		JMP	sub_A069
; End of function sub_BE98



; finds	current	line by	number.
;
; Entry:
; current_line_no_lsb,
; current_line_no_msb =	line number to search for
;
; Exit:
; (byte_2B) points to line found

find_current_line_by_number:		
		LDA	current_line_no_lsb
		STA	byte_2B
		LDA	current_line_no_msb
		STA	byte_2C
		JMP	find_line_by_number ; finds a line, given a line number

                .if acornsoft_version
                .fill $c000-*,0
                .else
                .include "pres_bedit.validate_mode.s65"
                .endif
                